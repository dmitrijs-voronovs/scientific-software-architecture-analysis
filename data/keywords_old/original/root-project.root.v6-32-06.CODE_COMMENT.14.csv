id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Security,Inject,Inject,3,// Inject libfuzzer dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:125,Integrability,interface,interface,125,"// If there is a static runtime with no dynamic list, force all the symbols; // to be dynamic to be sure we export sanitizer interface functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:115,Security,sanitiz,sanitizer,115,"// If there is a static runtime with no dynamic list, force all the symbols; // to be dynamic to be sure we export sanitizer interface functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:286,Energy Efficiency,power,power-of-two,286,"// `-falign-functions` indicates that the functions should be aligned to a; // 16-byte boundary.; //; // `-falign-functions=1` is the same as `-fno-align-functions`.; //; // The scalar `n` in `-falign-functions=n` must be an integral value between; // [0, 65536]. If the value is not a power-of-two, it will be rounded up to; // the nearest power-of-two.; //; // If we return `0`, the frontend will default to the backend's preferred; // alignment.; //; // NOTE: icc only allows values between [0, 4096]. icc uses `-falign-functions`; // to mean `-falign-functions=16`. GCC defaults to the backend's preferred; // alignment. For unaligned functions, we default to the backend's preferred; // alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:341,Energy Efficiency,power,power-of-two,341,"// `-falign-functions` indicates that the functions should be aligned to a; // 16-byte boundary.; //; // `-falign-functions=1` is the same as `-fno-align-functions`.; //; // The scalar `n` in `-falign-functions=n` must be an integral value between; // [0, 65536]. If the value is not a power-of-two, it will be rounded up to; // the nearest power-of-two.; //; // If we return `0`, the frontend will default to the backend's preferred; // alignment.; //; // NOTE: icc only allows values between [0, 4096]. icc uses `-falign-functions`; // to mean `-falign-functions=16`. GCC defaults to the backend's preferred; // alignment. For unaligned functions, we default to the backend's preferred; // alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:86,Availability,avail,available,86,"// Let the linker choose between libunwind.so and libunwind.a; // depending on what's available, and depending on the -static flag",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:66,Integrability,depend,depending,66,"// Let the linker choose between libunwind.so and libunwind.a; // depending on what's available, and depending on the -static flag",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:101,Integrability,depend,depending,101,"// Let the linker choose between libunwind.so and libunwind.a; // depending on what's available, and depending on the -static flag",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:9,Availability,error,error,9,// Issue error diagnostic if libgcc is explicitly specified; // through command line as --rtlib option argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:930,Energy Efficiency,reduce,reduce,930,"/// SDLSearch: Search for Static Device Library; /// The search for SDL bitcode files is consistent with how static host; /// libraries are discovered. That is, the -l option triggers a search for; /// files in a set of directories called the LINKPATH. The host library search; /// procedure looks for a specific filename in the LINKPATH. The filename for; /// a host library is lib<libname>.a or lib<libname>.so. For SDLs, there is an; /// ordered-set of filenames that are searched. We call this ordered-set of; /// filenames as SEARCH-ORDER. Since an SDL can either be device-type specific,; /// architecture specific, or generic across all architectures, a naming; /// convention and search order is used where the file name embeds the; /// architecture name <arch-name> (nvptx or amdgcn) and the GPU device type; /// <device-name> such as sm_30 and gfx906. <device-name> is absent in case of; /// device-independent SDLs. To reduce congestion in host library directories,; /// the search first looks for files in the “libdevice” subdirectory. SDLs that; /// are bc files begin with the prefix “lib”.; ///; /// Machine-code SDLs can also be managed as an archive (*.a file). The; /// convention has been to use the prefix “lib”. To avoid confusion with host; /// archive libraries, we use prefix ""libbc-"" for the bitcode SDL archives.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:1236,Safety,avoid,avoid,1236,"/// SDLSearch: Search for Static Device Library; /// The search for SDL bitcode files is consistent with how static host; /// libraries are discovered. That is, the -l option triggers a search for; /// files in a set of directories called the LINKPATH. The host library search; /// procedure looks for a specific filename in the LINKPATH. The filename for; /// a host library is lib<libname>.a or lib<libname>.so. For SDLs, there is an; /// ordered-set of filenames that are searched. We call this ordered-set of; /// filenames as SEARCH-ORDER. Since an SDL can either be device-type specific,; /// architecture specific, or generic across all architectures, a naming; /// convention and search order is used where the file name embeds the; /// architecture name <arch-name> (nvptx or amdgcn) and the GPU device type; /// <device-name> such as sm_30 and gfx906. <device-name> is absent in case of; /// device-independent SDLs. To reduce congestion in host library directories,; /// the search first looks for files in the “libdevice” subdirectory. SDLs that; /// are bc files begin with the prefix “lib”.; ///; /// Machine-code SDLs can also be managed as an archive (*.a file). The; /// convention has been to use the prefix “lib”. To avoid confusion with host; /// archive libraries, we use prefix ""libbc-"" for the bitcode SDL archives.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper function used by driver for adding SDLs during link phase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:48,Modifiability,variab,variable,48,// Add search directories from LIBRARY_PATH env variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.h:59,Modifiability,variab,variables,59,"/// \p EnvVar is split by system delimiter for environment variables.; /// If \p ArgName is ""-I"", ""-L"", or an empty string, each entry from \p EnvVar; /// is prefixed by \p ArgName then added to \p Args. Otherwise, for each; /// entry of \p EnvVar, \p ArgName is added to \p Args first, then the entry; /// itself is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CrossWindows.cpp:46,Performance,optimiz,optimized,46,// Make sure the dynamic runtime thunk is not optimized out at link time; // to ensure proper SEH handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CrossWindows.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CrossWindows.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp:31,Deployability,install,installations,31,// Multilib cross-compiler GCC installations put ld in a triple-prefixed; // directory off of the parent of the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp:116,Deployability,install,installation,116,// Multilib cross-compiler GCC installations put ld in a triple-prefixed; // directory off of the parent of the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CSKYToolChain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:156,Deployability,install,installation,156,"// Try to find ptxas binary. If the executable is located in a directory; // called 'bin/', its parent directory might be a good guess for a valid; // CUDA installation.; // However, some distributions might installs 'ptxas' to /usr/bin. In that; // case the candidate would be '/usr' which passes the following checks; // because '/usr/include' exists as well. To avoid this case, we always; // check for the directory potentially containing files for libdevice,; // even if the user passes -nocudalib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:208,Deployability,install,installs,208,"// Try to find ptxas binary. If the executable is located in a directory; // called 'bin/', its parent directory might be a good guess for a valid; // CUDA installation.; // However, some distributions might installs 'ptxas' to /usr/bin. In that; // case the candidate would be '/usr' which passes the following checks; // because '/usr/include' exists as well. To avoid this case, we always; // check for the directory potentially containing files for libdevice,; // even if the user passes -nocudalib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:365,Safety,avoid,avoid,365,"// Try to find ptxas binary. If the executable is located in a directory; // called 'bin/', its parent directory might be a good guess for a valid; // CUDA installation.; // However, some distributions might installs 'ptxas' to /usr/bin. In that; // case the candidate would be '/usr' which passes the following checks; // because '/usr/include' exists as well. To avoid this case, we always; // check for the directory potentially containing files for libdevice,; // even if the user passes -nocudalib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:151,Integrability,depend,depends,151,// Insert map entries for specific devices with this compute; // capability. NVCC's choice of the libdevice library version is; // rather peculiar and depends on the CUDA version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:64,Integrability,wrap,wrap,64,// Add cuda_wrappers/* to our system include path. This lets us wrap; // standard library headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:341,Performance,optimiz,optimization,341,"// anonymous namespace; /// Define debug info level for the NVPTX devices. If the debug info for both; /// the host and device are disabled (-g0/-ggdb0 or no debug options at all). If; /// only debug directives are requested for the both host and device; /// (-gline-directvies-only), or the debug info only for the device is disabled; /// (optimization is on and --cuda-noopt-device-debug was not specified), the; /// debug directves only must be emitted for the device. Otherwise, use the same; /// debug info level just like for the host (with the limitations of only; /// supported DWARF2 standard).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:18,Deployability,install,installation,18,// Check that our installation's ptxas supports gpu_arch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:38,Performance,optimiz,optimization,38,"// ptxas does not accept -g option if optimization is enabled, so; // we ignore the compiler's -O* options if we want debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:85,Performance,optimiz,optimizations,85,"// If no -O was passed, pass -O0 to ptxas -- no opt flag should correspond; // to no optimizations, but ptxas's default is -O3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:131,Deployability,update,updates,131,// If we are invoking `nvlink` internally we need to output a `.cubin` file.; // FIXME: This should hopefully be removed if NVIDIA updates their tooling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:51,Modifiability,variab,variable,51,// Add paths specified in LIBRARY_PATH environment variable as -L options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:259,Deployability,update,updates,259,"// The 'nvlink' application performs RDC-mode linking when given a '.o'; // file and device linking when given a '.cubin' file. We always want to; // perform device linking, so just rename any '.o' files.; // FIXME: This should hopefully be removed if NVIDIA updates their tooling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:28,Performance,perform,performs,28,"// The 'nvlink' application performs RDC-mode linking when given a '.o'; // file and device linking when given a '.cubin' file. We always want to; // perform device linking, so just rename any '.o' files.; // FIXME: This should hopefully be removed if NVIDIA updates their tooling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:150,Performance,perform,perform,150,"// The 'nvlink' application performs RDC-mode linking when given a '.o'; // file and device linking when given a '.cubin' file. We always want to; // perform device linking, so just rename any '.o' files.; // FIXME: This should hopefully be removed if NVIDIA updates their tooling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:126,Performance,perform,performs,126,"/// CUDA toolchain. Our assembler is ptxas, and our ""linker"" is fatbinary,; /// which isn't properly a linker but nonetheless performs the step of stitching; /// together object files from the assembler into a single blob.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:22,Availability,avail,availible,22,// Detect NVIDIA GPUs availible on the system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:3,Safety,Detect,Detect,3,// Detect NVIDIA GPUs availible on the system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:518,Availability,toler,tolerate,518,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:35,Security,sanitiz,sanitizers,35,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:78,Security,sanitiz,sanitizer,78,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:266,Security,sanitiz,sanitizers,266,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:301,Security,sanitiz,sanitization,301,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:34,Deployability,install,installation,34,/// A class to find a viable CUDA installation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:50,Availability,error,error,50,// CUDA architectures for which we have raised an error in; // CheckCudaVersionSupportsArch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Availability,error,error,12,"/// Emit an error if Version does not support the given Arch.; ///; /// If either Version or Arch is unknown, does not emit an error. Emits at; /// most one error per Arch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:127,Availability,error,error,127,"/// Emit an error if Version does not support the given Arch.; ///; /// If either Version or Arch is unknown, does not emit an error. Emits at; /// most one error per Arch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:157,Availability,error,error,157,"/// Emit an error if Version does not support the given Arch.; ///; /// If either Version or Arch is unknown, does not emit an error. Emits at; /// most one error per Arch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:43,Deployability,install,install,43,/// Check whether we detected a valid Cuda install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:21,Safety,detect,detected,21,/// Check whether we detected a valid Cuda install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:46,Deployability,install,installation,46,/// Print information about the detected CUDA installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:32,Safety,detect,detected,32,/// Print information about the detected CUDA installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:26,Deployability,install,install,26,/// Get the detected Cuda install's version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Safety,detect,detected,12,/// Get the detected Cuda install's version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:26,Deployability,install,installation,26,/// Get the detected Cuda installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Safety,detect,detected,12,/// Get the detected Cuda installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Safety,detect,detected,12,/// Get the detected path to Cuda's bin directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Safety,detect,detected,12,/// Get the detected Cuda Include path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,Safety,detect,detected,12,/// Get the detected Cuda device library path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:24,Deployability,integrat,integrated,24,// Never try to use the integrated assembler with CUDA; always fork out to; // ptxas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:24,Integrability,integrat,integrated,24,// Never try to use the integrated assembler with CUDA; always fork out to; // ptxas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:68,Availability,error,error,68,/// Uses nvptx-arch tool to get arch of the system GPU. Will return error; /// if unable to find one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:136,Integrability,rout,routine,136,"// See arch(3) and llvm-gcc's driver-driver.c. We don't implement support for; // archs which Darwin doesn't use.; // The matching this routine does is fairly pointless, since it is neither the; // complete architecture list, nor a reasonable subset. The problem is that; // historically the driver accepts this and also ties its -march=; // handling to the architecture name, so we need to be careful before removing; // support for it.; // This code must be kept in sync with Clang's Darwin specific argument; // translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,Deployability,integrat,integrated-as,11,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:129,Deployability,integrat,integrated,129,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:210,Deployability,integrat,integrated-as,210,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,Integrability,integrat,integrated-as,11,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:129,Integrability,integrat,integrated,129,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:210,Integrability,integrat,integrated-as,210,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:248,Safety,detect,detect,248,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:120,Security,audit,audited,120,"// If we are using App Extension restrictions, pass a flag to the linker; // telling it that the compiled code has been audited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:131,Modifiability,extend,extend,131,"// If we are using full LTO, then automatically create a temporary file; // path for the linker to use, so that it's lifetime will extend past a; // possible dsymutil step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:89,Deployability,install,installed,89,"// Use -lto_library option to specify the libLTO.dylib path. Try to find; // it in clang installed libraries. ld64 will only look at this argument; // when it actually uses LTO, so libLTO.dylib only needs to exist at link; // time if ld64 decides that it needs to use LTO.; // Since this is passed unconditionally, ld64 will never look for libLTO.dylib; // next to it. That's ok since ld64 using a libLTO.dylib not matching the; // clang version won't work anyways.; // lld is built at the same revision as clang and statically links in; // LLVM libraries, so it doesn't need libLTO.dylib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:25,Deployability,Install,InstalledDir,25,// Search for libLTO in <InstalledDir>/../lib/libLTO.dylib,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:131,Safety,safe,safe,131,// ld64 version 262 and above runs the deduplicate pass by default.; // FIXME: lld doesn't dedup by default. Should we pass `--icf=safe`; // if `!shouldLinkerNotDedup()` if LinkerIsLLD here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,Deployability,deploy,deployment,11,// Add the deployment target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,Safety,abort,abort,11,// Disable abort and fall back to SDAG silently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:37,Availability,error,error,37,"// When enabling remarks, we need to error if:; // * The remark file is specified but we're targeting multiple architectures,; // which means more than one remark file is being generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:7,Testability,log,logic,7,// The logic here is derived from gcc's behavior; most of which; // comes from specs (starting with link_command). Consult gcc for; // more information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:31,Availability,error,errors,31,/// Hack(tm) to ignore linking errors when we are doing ARC migration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:64,Performance,load,loading,64,"// Forward -ObjC when either -ObjC or -ObjC++ is used, to force loading; // members of static archive libraries which implement Objective-C classes or; // categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:58,Safety,avoid,avoid,58,// No need to do anything for pthreads. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:52,Deployability,install,install,52,"// We expect 'as', 'ld', etc. to be adjacent to our install dir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:41,Integrability,rout,routine,41,// This is just a MachO name translation routine and there's no; // way to join this into ARMTargetParser without breaking all; // other assumptions. Maybe MachO should consider standardising; // their nomenclature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:10,Availability,error,error,10,// Always error about undefined 'TARGET_OS_*' macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:51,Availability,error,errors,51,"// For modern targets, promote certain warnings to errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:70,Availability,error,error,70,// Always enable -Wdeprecated-objc-isa-usage and promote it; // to an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:29,Availability,error,error,29,"// For iOS and watchOS, also error about implicit function declarations,; // as that can impact calling conventions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:3,Safety,Avoid,Avoid,3,// Avoid linking compatibility stubs on i386 mac.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:31,Testability,stub,stubs,31,// Avoid linking compatibility stubs on i386 mac.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,Deployability,integrat,integrated,115,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build (unless; // we explicitly force linking with this library).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,Integrability,integrat,integrated,115,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build (unless; // we explicitly force linking with this library).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:251,Energy Efficiency,reduce,reduce,251,"/// Add a sectalign directive for \p Segment and \p Section to the maximum; /// expected page size for Darwin.; ///; /// On iPhone 6+ the max supported page size is 16K. On macOS, the max is 4K.; /// Use a common alignment constant (16K) for now, and reduce the alignment on; /// macOS if it proves important.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:356,Deployability,continuous,continuous,356,"// Align __llvm_prf_{cnts,bits,data} sections to the maximum expected page; // alignment. This allows profile counters to be mmap()'d to disk. Note that; // it's not enough to just page-align __llvm_prf_cnts: the following section; // must also be page-aligned so that its data is not clobbered by mmap().; //; // The section alignment is only needed when continuous profile sync is; // enabled, but this is expected to be the default in Xcode. Specifying the; // extra alignment also allows the same binary to be used with/without sync; // enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:215,Integrability,rout,routines,215,"// Reject -static-libgcc for now, we can deal with this when and if someone; // cares. This is useful in situations where someone wants to statically link; // something like libstdc++, and needs its runtime support routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:59,Modifiability,variab,variable,59,/// Returns the OS version with the argument / environment variable that; /// specified it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:16,Deployability,deploy,deployment,16,/// Returns the deployment target that's specified using the -m<os>-version-min; /// argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:16,Deployability,deploy,deployment,16,/// Returns the deployment target that's specified using the; /// OS_DEPLOYMENT_TARGET environment variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:99,Modifiability,variab,variable,99,/// Returns the deployment target that's specified using the; /// OS_DEPLOYMENT_TARGET environment variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:165,Availability,avail,available,165,/// Tries to infer the deployment target from the SDK specified by -isysroot; /// (or SDKROOT). Uses the version specified in the SDKSettings.json file if; /// it's available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:23,Deployability,deploy,deployment,23,/// Tries to infer the deployment target from the SDK specified by -isysroot; /// (or SDKROOT). Uses the version specified in the SDKSettings.json file if; /// it's available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:53,Availability,avail,available,53,// Get the version from the SDKSettings.json if it's available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:16,Deployability,deploy,deployment,16,/// Returns the deployment target that's specified using the -target option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:16,Deployability,deploy,deployment,16,/// Returns the deployment target that's specified using the -mtargetos option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:44,Modifiability,variab,variable,44,"// Support allowing the SDKROOT environment variable used by xcrun and other; // Xcode tools to define the default sysroot, by making it the default for; // isysroot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:98,Availability,down,down,98,"// Read the SDKSettings.json file for more information, like the SDK version; // that we can pass down to the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:9,Deployability,deploy,deployment,9,"// If no deployment target was specified on the command line, check for; // environment defines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:93,Modifiability,variab,variable,93,"// If there is no command-line argument to specify the Target version and; // no environment variable defined, see if we can set the default based; // on -isysroot using SDKSettings.json if it exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:27,Deployability,deploy,deployment,27,"// For 32-bit targets, the deployment target for iOS has to be earlier than; // iOS 11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:10,Deployability,deploy,deployment,10,"// If the deployment target is explicitly specified, print a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:28,Deployability,install,installed,28,"// On Darwin, libc++ can be installed in one of the following places:; // 1. Alongside the compiler in <install>/include/c++/v1; // 2. Alongside the compiler in <clang-executable-folder>/../include/c++/v1; // 3. In a SDK (or a custom sysroot) in <sysroot>/usr/include/c++/v1; //; // The precedence of paths is as listed above, i.e. we take the first path; // that exists. Note that we never include libc++ twice -- we take the first; // path that exists and don't send the other paths to CC1 (otherwise; // include_next could break).; //; // Also note that in most cases, (1) and (2) are exactly the same path.; // Those two paths will differ only when the `clang` program being run; // is actually a symlink to the real executable.; // Check for (1); // Get from '<install>/bin' to '<install>/include/c++/v1'.; // Note that InstallBin can be relative, so we use '..' instead of; // parent_path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:104,Deployability,install,install,104,"// On Darwin, libc++ can be installed in one of the following places:; // 1. Alongside the compiler in <install>/include/c++/v1; // 2. Alongside the compiler in <clang-executable-folder>/../include/c++/v1; // 3. In a SDK (or a custom sysroot) in <sysroot>/usr/include/c++/v1; //; // The precedence of paths is as listed above, i.e. we take the first path; // that exists. Note that we never include libc++ twice -- we take the first; // path that exists and don't send the other paths to CC1 (otherwise; // include_next could break).; //; // Also note that in most cases, (1) and (2) are exactly the same path.; // Those two paths will differ only when the `clang` program being run; // is actually a symlink to the real executable.; // Check for (1); // Get from '<install>/bin' to '<install>/include/c++/v1'.; // Note that InstallBin can be relative, so we use '..' instead of; // parent_path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:766,Deployability,install,install,766,"// On Darwin, libc++ can be installed in one of the following places:; // 1. Alongside the compiler in <install>/include/c++/v1; // 2. Alongside the compiler in <clang-executable-folder>/../include/c++/v1; // 3. In a SDK (or a custom sysroot) in <sysroot>/usr/include/c++/v1; //; // The precedence of paths is as listed above, i.e. we take the first path; // that exists. Note that we never include libc++ twice -- we take the first; // path that exists and don't send the other paths to CC1 (otherwise; // include_next could break).; //; // Also note that in most cases, (1) and (2) are exactly the same path.; // Those two paths will differ only when the `clang` program being run; // is actually a symlink to the real executable.; // Check for (1); // Get from '<install>/bin' to '<install>/include/c++/v1'.; // Note that InstallBin can be relative, so we use '..' instead of; // parent_path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:785,Deployability,install,install,785,"// On Darwin, libc++ can be installed in one of the following places:; // 1. Alongside the compiler in <install>/include/c++/v1; // 2. Alongside the compiler in <clang-executable-folder>/../include/c++/v1; // 3. In a SDK (or a custom sysroot) in <sysroot>/usr/include/c++/v1; //; // The precedence of paths is as listed above, i.e. we take the first path; // that exists. Note that we never include libc++ twice -- we take the first; // path that exists and don't send the other paths to CC1 (otherwise; // include_next could break).; //; // Also note that in most cases, (1) and (2) are exactly the same path.; // Those two paths will differ only when the `clang` program being run; // is actually a symlink to the real executable.; // Check for (1); // Get from '<install>/bin' to '<install>/include/c++/v1'.; // Note that InstallBin can be relative, so we use '..' instead of; // parent_path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:825,Deployability,Install,InstallBin,825,"// On Darwin, libc++ can be installed in one of the following places:; // 1. Alongside the compiler in <install>/include/c++/v1; // 2. Alongside the compiler in <clang-executable-folder>/../include/c++/v1; // 3. In a SDK (or a custom sysroot) in <sysroot>/usr/include/c++/v1; //; // The precedence of paths is as listed above, i.e. we take the first path; // that exists. Note that we never include libc++ twice -- we take the first; // path that exists and don't send the other paths to CC1 (otherwise; // include_next could break).; //; // Also note that in most cases, (1) and (2) are exactly the same path.; // Those two paths will differ only when the `clang` program being run; // is actually a symlink to the real executable.; // Check for (1); // Get from '<install>/bin' to '<install>/include/c++/v1'.; // Note that InstallBin can be relative, so we use '..' instead of; // parent_path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:4,Deployability,install,install,4,// <install>/bin,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,Deployability,integrat,integrated,115,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,Integrability,integrat,integrated,115,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:362,Availability,down,down,362,"// FIXME: We really want to get out of the tool chain level argument; // translation business, as it makes the driver functionality much; // more opaque. For now, we follow gcc closely solely for the; // purpose of easily achieving feature parity & testability. Once we; // have something that works, we should reevaluate each translation; // and try to push it down into tool specific logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:249,Testability,test,testability,249,"// FIXME: We really want to get out of the tool chain level argument; // translation business, as it makes the driver functionality much; // more opaque. For now, we follow gcc closely solely for the; // purpose of easily achieving feature parity & testability. Once we; // have something that works, we should reevaluate each translation; // and try to push it down into tool specific logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:386,Testability,log,logic,386,"// FIXME: We really want to get out of the tool chain level argument; // translation business, as it makes the driver functionality much; // more opaque. For now, we follow gcc closely solely for the; // purpose of easily achieving feature parity & testability. Once we; // have something that works, we should reevaluate each translation; // and try to push it down into tool specific logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:61,Security,sanitiz,sanitizers,61,"// Embedded targets are simple at the moment, not supporting sanitizers and; // with different libraries for each member of the product { static, PIC } x; // { hard-float, soft-float }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:24,Usability,simpl,simple,24,"// Embedded targets are simple at the moment, not supporting sanitizers and; // with different libraries for each member of the product { static, PIC } x; // { hard-float, soft-float }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:10,Availability,avail,available,10,// Always available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:10,Availability,avail,available,10,// Always available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:21,Modifiability,variab,variables,21,// Give static local variables in inline functions hidden visibility when; // -fvisibility-inlines-hidden is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:74,Availability,avail,available,74,/// Pass the SDK version to the compiler when the SDK information is; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:89,Availability,avail,available,89,/// Pass the target variant SDK version to the compiler when the SDK; /// information is available and is required for target variant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:48,Deployability,deploy,deployment,48,// Add an explicit version min argument for the deployment target. We do this; // after argument translation because -Xarch_ arguments may add a version min; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:182,Deployability,deploy,deployment,182,"// For iOS 6, undo the translation to add -static for -mkernel/-fapple-kext.; // FIXME: It would be far better to avoid inserting those -static arguments,; // but we can't check the deployment target in the translation code until; // it is set here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:114,Safety,avoid,avoid,114,"// For iOS 6, undo the translation to add -static for -mkernel/-fapple-kext.; // FIXME: It would be far better to avoid inserting those -static arguments,; // but we can't check the deployment target in the translation code until; // it is set here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:14,Usability,undo,undo,14,"// For iOS 6, undo the translation to add -static for -mkernel/-fapple-kext.; // FIXME: It would be far better to avoid inserting those -static arguments,; // but we can't check the deployment target in the translation code until; // it is set here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:42,Deployability,deploy,deployment,42,"// Use an SDK version that's matching the deployment target if the SDK; // version is missing. This is preferred over an empty SDK version; // (0.0.0) as the system's runtime might expect the linked binary to; // contain a valid SDK version in order for the binary to work; // correctly. It's reasonable to use the deployment target version as; // a proxy for the SDK version because older SDKs don't guarantee; // support for deployment targets newer than the SDK versions, so that; // rules out using some predetermined older SDK version, which leaves; // the deployment target version as the only reasonable choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:315,Deployability,deploy,deployment,315,"// Use an SDK version that's matching the deployment target if the SDK; // version is missing. This is preferred over an empty SDK version; // (0.0.0) as the system's runtime might expect the linked binary to; // contain a valid SDK version in order for the binary to work; // correctly. It's reasonable to use the deployment target version as; // a proxy for the SDK version because older SDKs don't guarantee; // support for deployment targets newer than the SDK versions, so that; // rules out using some predetermined older SDK version, which leaves; // the deployment target version as the only reasonable choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:427,Deployability,deploy,deployment,427,"// Use an SDK version that's matching the deployment target if the SDK; // version is missing. This is preferred over an empty SDK version; // (0.0.0) as the system's runtime might expect the linked binary to; // contain a valid SDK version in order for the binary to work; // correctly. It's reasonable to use the deployment target version as; // a proxy for the SDK version because older SDKs don't guarantee; // support for deployment targets newer than the SDK versions, so that; // rules out using some predetermined older SDK version, which leaves; // the deployment target version as the only reasonable choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:562,Deployability,deploy,deployment,562,"// Use an SDK version that's matching the deployment target if the SDK; // version is missing. This is preferred over an empty SDK version; // (0.0.0) as the system's runtime might expect the linked binary to; // contain a valid SDK version in order for the binary to work; // correctly. It's reasonable to use the deployment target version as; // a proxy for the SDK version because older SDKs don't guarantee; // support for deployment targets newer than the SDK versions, so that; // rules out using some predetermined older SDK version, which leaves; // the deployment target version as the only reasonable choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:42,Availability,avail,available,42,/// The version of the linker known to be available in the tool chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:46,Availability,avail,available,46,/// Get the version of the linker known to be available for a particular; /// compiler invocation (via the `-mlinker-version=` arg).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:186,Deployability,deploy,deployment,186,"/// Returns true if the minimum supported macOS version for the slice that's; /// being built is less than the specified version. If there's no minimum; /// supported macOS version, the deployment target version is compared to the; /// specifed version instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:127,Deployability,deploy,deployment,127,/// Return true if c++17 aligned allocation/deallocation functions are not; /// implemented in the c++ standard library of the deployment target we are; /// targeting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/DragonFly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:18,Availability,error,error,18,// Ignore parsing error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:15,Energy Efficiency,power,power,15,// Only accept power of 2 values beteen RVVBitsPerBlock and 65536 that; // at least MinVLen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:415,Testability,log,logic,415,"// Skips the primary input file, which is the input file that the compilation; // proccess will be executed upon (e.g. the host bitcode file) and; // adds other secondary input (e.g. device bitcode files for embedding to the; // -fembed-offload-object argument or the host IR file for proccessing; // during device compilation to the fopenmp-host-ir-file-path argument via; // OpenMPDeviceInput). This is condensed logic from the ConstructJob; // function inside of the Clang driver for pushing on further input arguments; // needed for offloading during various phases of compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:19,Availability,error,error,19,// Warn instead of error because users might have makefiles written for; // gfortran (which accepts -ffp-contract=on),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:105,Integrability,contract,contract,105,// Warn instead of error because users might have makefiles written for; // gfortran (which accepts -ffp-contract=on),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:155,Integrability,contract,contract,155,"// -fno-fast-math should undo -ffast-math so I return FPContract to the; // default. It is important to check it is ""fast"" (the default) so that; // --ffp-contract=off -fno-fast-math --> -ffp-contract=off",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:192,Integrability,contract,contract,192,"// -fno-fast-math should undo -ffast-math so I return FPContract to the; // default. It is important to check it is ""fast"" (the default) so that; // --ffp-contract=off -fno-fast-math --> -ffp-contract=off",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:25,Usability,undo,undo,25,"// -fno-fast-math should undo -ffast-math so I return FPContract to the; // default. It is important to check it is ""fast"" (the default) so that; // --ffp-contract=off -fno-fast-math --> -ffp-contract=off",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:160,Safety,avoid,avoid,160,// Color diagnostics are parsed by the driver directly from argv and later; // re-parsed to construct this job; claim any possible color diagnostic here; // to avoid warn_drv_unused_argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:47,Performance,optimiz,optimization-record,47,// Remarks can be enabled with any of the `-f.*optimization-record.*` flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:3,Performance,Optimiz,Optimization,3,// Optimization level for CodeGen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/FreeBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:107,Integrability,depend,dependencies,107,// Note that Fuchsia never needs to link in sanitizer runtime deps. Any; // sanitizer runtimes with system dependencies use the `.deplibs` feature; // instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:44,Security,sanitiz,sanitizer,44,// Note that Fuchsia never needs to link in sanitizer runtime deps. Any; // sanitizer runtimes with system dependencies use the `.deplibs` feature; // instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:76,Security,sanitiz,sanitizer,76,// Note that Fuchsia never needs to link in sanitizer runtime deps. Any; // sanitizer runtimes with system dependencies use the `.deplibs` feature; // instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:52,Safety,avoid,avoid,52,// Use the noexcept variant with -fno-exceptions to avoid the extra overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:388,Safety,safe,safely,388,"// Only pass -x if gcc will understand it; otherwise hope gcc; // understands the suffix correctly. The main use case this would go; // wrong in is for linker inputs if they happened to have an odd; // suffix; really the only way to get this to happen is a command; // like '-x foobar a.c' which will treat a.c like a linker input.; //; // FIXME: For the linker case specifically, can we safely convert; // inputs into '-Wl,' options?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:27,Deployability,integrat,integrated,27,"// We assume we've got an ""integrated"" assembler in that gcc will produce an; // object file itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:27,Integrability,integrat,integrated,27,"// We assume we've got an ""integrated"" assembler in that gcc will produce an; // object file itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:24,Availability,avail,available,24,// Add crtfastmath.o if available and fast math is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:34,Security,access,access,34,// The profile runtime also needs access to system libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:7,Deployability,integrat,integrated,7,"// The integrated assembler doesn't implement e_flags setting behavior for; // -meabi=gnu (gcc -mabi={apcs-gnu,atpcs} passes -meabi=gnu to gas). For; // compatibility we accept but warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:7,Integrability,integrat,integrated,7,"// The integrated assembler doesn't implement e_flags setting behavior for; // -meabi=gnu (gcc -mabi={apcs-gnu,atpcs} passes -meabi=gnu to gas). For; // compatibility we accept but warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:62,Testability,log,logic,62,"// FIXME: when clang starts to support msp430x ISA additional logic; // to select between multilib must be implemented; // MultilibBuilder MSP430xMultilib = MultilibBuilder(""/large"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:4,Modifiability,Extend,Extend,4,"/// Extend the multi-lib re-use selection mechanism for RISC-V.; /// This function will try to re-use multi-lib if they are compatible.; /// Definition of compatible:; /// - ABI must be the same.; /// - multi-lib is a subset of current arch, e.g. multi-lib=march=rv32im; /// is a subset of march=rv32imc.; /// - march that contains atomic extension can't reuse multi-lib that; /// doesn't have atomic, vice versa. e.g. multi-lib=march=rv32im and; /// march=rv32ima are not compatible, because software and hardware; /// atomic operation can't work together correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:14,Availability,error,error,14,"// Ignore any error here, we assume it will be handled in another place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:9,Availability,down,down,9,// Break down -march into individual extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:14,Availability,error,error,14,"// Ignore any error here, we assume it will handled in another place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:26,Availability,error,error,26,"// We might get a parsing error if rv32e in the list, we could just skip; // that and process the rest of multi-lib configs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:116,Modifiability,config,configs,116,"// We might get a parsing error if rv32e in the list, we could just skip; // that and process the rest of multi-lib configs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:173,Testability,log,logic,173,"// Some versions of SUSE and Fedora on ppc64 put 32-bit libs; // in what would normally be GCCInstallPath and put the 64-bit; // libs in a subdirectory named 64. The simple logic we follow is that; // *if* there is a subdirectory of the right name with crtbegin.o in it,; // we use that. If not, and if not a biarch triple alias, we look for; // crtbegin.o without the subdirectory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:166,Usability,simpl,simple,166,"// Some versions of SUSE and Fedora on ppc64 put 32-bit libs; // in what would normally be GCCInstallPath and put the 64-bit; // libs in a subdirectory named 64. The simple logic we follow is that; // *if* there is a subdirectory of the right name with crtbegin.o in it,; // we use that. If not, and if not a biarch triple alias, we look for; // crtbegin.o without the subdirectory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:58,Performance,perform,perform,58,"/// Generic_GCC - A tool chain using the 'gcc' command to perform; /// all subcommands; this relies on gcc translating the majority of; /// command line options.; /// Less-than for GCCVersion, implementing a Strict Weak Ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:42,Deployability,patch,patch,42,// Note that versions without a specified patch sort higher than those with; // a patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:82,Deployability,patch,patch,82,// Note that versions without a specified patch sort higher than those with; // a patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:30,Deployability,patch,patch,30,// Otherwise just sort on the patch itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:63,Deployability,patch,patched,63,"// Parse version number strings such as:; // 5; // 4.4; // 4.4-patched; // 4.4.0; // 4.4.x; // 4.4.2-rc4; // 4.4.x-patched; // 10-win32; // Split on '.', handle 1, 2 or 3 such segments. Each segment must contain; // purely a number, except for the last one, where a non-number suffix; // is stored in PatchSuffix. The third segment is allowed to not contain; // a number at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:115,Deployability,patch,patched,115,"// Parse version number strings such as:; // 5; // 4.4; // 4.4-patched; // 4.4.0; // 4.4.x; // 4.4.2-rc4; // 4.4.x-patched; // 10-win32; // Split on '.', handle 1, 2 or 3 such segments. Each segment must contain; // purely a number, except for the last one, where a non-number suffix; // is stored in PatchSuffix. The third segment is allowed to not contain; // a number at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:301,Deployability,Patch,PatchSuffix,301,"// Parse version number strings such as:; // 5; // 4.4; // 4.4-patched; // 4.4.0; // 4.4.x; // 4.4.2-rc4; // 4.4.x-patched; // 10-win32; // Split on '.', handle 1, 2 or 3 such segments. Each segment must contain; // purely a number, except for the last one, where a non-number suffix; // is stored in PatchSuffix. The third segment is allowed to not contain; // a number at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:99,Deployability,Patch,PatchSuffix,99,"// Look for a number prefix and parse that, and split out any trailing; // string into GoodVersion.PatchSuffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:9,Deployability,patch,patch,9,"// If no patch string, minor is the last segment",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:25,Availability,toler,tolerate,25,"// For the last segment, tolerate a missing number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:93,Deployability,install,installation,93,"// If we have a SysRoot, ignore GCC_INSTALL_PREFIX.; // GCC_INSTALL_PREFIX specifies the gcc installation for the default; // sysroot and is likely not valid with a different sysroot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:73,Performance,perform,performs,73,"/// Initialize a GCCInstallationDetector from the driver.; ///; /// This performs all of the autodetection and sets up the various paths.; /// Once constructed, a GCCInstallationDetector is essentially immutable.; ///; /// FIXME: We shouldn't need an explicit TargetTriple parameter here, and; /// should instead pull the target out of the driver. This is currently; /// necessary because the driver doesn't store the final version of the target; /// triple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:49,Deployability,install,installations,49,// The library directories which may contain GCC installations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:12,Deployability,install,install-dir,12,"// If --gcc-install-dir= is specified, skip filesystem detection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:55,Safety,detect,detection,55,"// If --gcc-install-dir= is specified, skip filesystem detection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:71,Safety,detect,detect,71,// If --gcc-triple is specified use this instead of trying to; // auto-detect a triple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:21,Deployability,install,installed,21,// Then look for gcc installed alongside clang.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:78,Deployability,install,installations,78,"// Next, look for prefix(es) that correspond to distribution-supplied gcc; // installations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:22,Modifiability,config,config,22,// Try to respect gcc-config on Gentoo if --gcc-toolchain is not provided.; // This avoids accidentally enforcing the system GCC version when using a; // custom toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:84,Safety,avoid,avoids,84,// Try to respect gcc-config on Gentoo if --gcc-toolchain is not provided.; // This avoids accidentally enforcing the system GCC version when using a; // custom toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:106,Deployability,install,install,106,"// Try to match an exact triple as target triple first.; // e.g. crossdev -S x86_64-gentoo-linux-gnu will install gcc libs for; // x86_64-gentoo-linux-gnu. But ""clang -target x86_64-gentoo-linux-gnu""; // may pick the libraries for x86_64-pc-linux-gnu even when exact matching; // triple x86_64-gentoo-linux-gnu is present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:89,Availability,avail,available,89,// Loop over the various components which exist and select the best GCC; // installation available. GCC installs are ranked by version number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:76,Deployability,install,installation,76,// Loop over the various components which exist and select the best GCC; // installation available. GCC installs are ranked by version number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:104,Deployability,install,installs,104,// Loop over the various components which exist and select the best GCC; // installation available. GCC installs are ranked by version number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:34,Deployability,install,installation,34,// Skip other prefixes once a GCC installation is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:42,Deployability,install,installation,42,// Solaris is a special case.; // The GCC installation is under; // /usr/gcc/<major>.<minor>/lib/gcc/<triple>/<major>.<minor>.<patch>/; // so we need to find those /usr/gcc/*/lib/gcc libdirs and go with; // /usr/gcc/<version> as a prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:127,Deployability,patch,patch,127,// Solaris is a special case.; // The GCC installation is under; // /usr/gcc/<major>.<minor>/lib/gcc/<triple>/<major>.<minor>.<patch>/; // so we need to find those /usr/gcc/*/lib/gcc libdirs and go with; // /usr/gcc/<version> as a prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:87,Modifiability,config,config,87,"// TODO: We may want to remove this, since the functionality; // can be achieved using config files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:216,Modifiability,variab,variables,216,"// Declare a bunch of static data sets that we'll select between below. These; // are specifically designed to always refer to string literals to avoid any; // lifetime or initialization issues.; //; // The *Triples variables hard code some triples so that, for example,; // --target=aarch64 (incomplete triple) can detect lib/aarch64-linux-gnu.; // They are not needed when the user has correct LLVM_DEFAULT_TARGET_TRIPLE; // and always uses the full --target (e.g. --target=aarch64-linux-gnu). The; // lists should shrink over time. Please don't add more elements to *Triples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:146,Safety,avoid,avoid,146,"// Declare a bunch of static data sets that we'll select between below. These; // are specifically designed to always refer to string literals to avoid any; // lifetime or initialization issues.; //; // The *Triples variables hard code some triples so that, for example,; // --target=aarch64 (incomplete triple) can detect lib/aarch64-linux-gnu.; // They are not needed when the user has correct LLVM_DEFAULT_TARGET_TRIPLE; // and always uses the full --target (e.g. --target=aarch64-linux-gnu). The; // lists should shrink over time. Please don't add more elements to *Triples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:316,Safety,detect,detect,316,"// Declare a bunch of static data sets that we'll select between below. These; // are specifically designed to always refer to string literals to avoid any; // lifetime or initialization issues.; //; // The *Triples variables hard code some triples so that, for example,; // --target=aarch64 (incomplete triple) can detect lib/aarch64-linux-gnu.; // They are not needed when the user has correct LLVM_DEFAULT_TARGET_TRIPLE; // and always uses the full --target (e.g. --target=aarch64-linux-gnu). The; // lists should shrink over time. Please don't add more elements to *Triples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:13,Energy Efficiency,Power,PowerPC,13,"// On 32-bit PowerPC systems running SUSE Linux, gcc is configured as a; // 64-bit compiler which defaults to ""-m32"", hence ""powerpc64-suse-linux"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:56,Modifiability,config,configured,56,"// On 32-bit PowerPC systems running SUSE Linux, gcc is configured as a; // 64-bit compiler which defaults to ""-m32"", hence ""powerpc64-suse-linux"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:46,Usability,simpl,simplified,46,// It should also work without multilibs in a simplified toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:239,Deployability,install,installation,239,"// The Freescale PPC SDK has the gcc libraries in; // <sysroot>/usr/lib/<triple>/x.y.z so have a look there as well. Only do; // this on Freescale triples, though, since some systems put a *lot* of; // files in that location, not just GCC installation data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:15,Modifiability,config,config,15,// Process the config file pointed to by CURRENT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:32,Deployability,install,installed,32,"// Scan the Config file to find installed GCC libraries path.; // Typical content of the GCC config file:; // LDPATH=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x:/usr/lib/gcc/; // (continued from previous line) x86_64-pc-linux-gnu/4.9.x/32""; // MANPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/man""; // INFOPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/info""; // STDCXX_INCDIR=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x/include/g++-v4""; // We are looking for the paths listed in LDPATH=... .",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:12,Modifiability,Config,Config,12,"// Scan the Config file to find installed GCC libraries path.; // Typical content of the GCC config file:; // LDPATH=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x:/usr/lib/gcc/; // (continued from previous line) x86_64-pc-linux-gnu/4.9.x/32""; // MANPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/man""; // INFOPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/info""; // STDCXX_INCDIR=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x/include/g++-v4""; // We are looking for the paths listed in LDPATH=... .",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:93,Modifiability,config,config,93,"// Scan the Config file to find installed GCC libraries path.; // Typical content of the GCC config file:; // LDPATH=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x:/usr/lib/gcc/; // (continued from previous line) x86_64-pc-linux-gnu/4.9.x/32""; // MANPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/man""; // INFOPATH=""/usr/share/gcc-data/x86_64-pc-linux-gnu/4.9.x/info""; // STDCXX_INCDIR=""/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.x/include/g++-v4""; // We are looking for the paths listed in LDPATH=... .",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:56,Modifiability,config,config,56,// Test the path based on the version in /etc/env.d/gcc/config-{tuple}.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:3,Testability,Test,Test,3,// Test the path based on the version in /etc/env.d/gcc/config-{tuple}.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:55,Deployability,install,installation,55,// Print the information about how we detected the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:38,Safety,detect,detected,38,// Print the information about how we detected the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:36,Deployability,install,installations,36,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:168,Deployability,install,installation,168,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:321,Deployability,install,installation,321,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:365,Deployability,install,installation,365,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:424,Deployability,install,installation,424,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:308,Safety,detect,detected,308,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:50,Availability,avail,available,50,// Add the multilib suffixed paths where they are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:100,Deployability,install,installation,100,// Sourcery CodeBench MIPS toolchain holds some libraries under; // a biarch-like suffix of the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:39,Deployability,install,install,39,"// GCC cross compiling toolchains will install target libraries which ship; // as part of the toolchain under <prefix>/<triple>/<libdir> rather than as; // any part of the GCC installation in; // <prefix>/<libdir>/gcc/<triple>/<version>. This decision is somewhat; // debatable, but is the reality today. We need to search this tree even; // when we have a sysroot somewhere else. It is the responsibility of; // whomever is doing the cross build targeting a sysroot using a GCC; // installation that is *not* within the system root to ensure two things:; //; // 1) Any DSOs that are linked in from this tree or from the install path; // above must be present on the system root and found via an; // appropriate rpath.; // 2) There must not be libraries installed into; // <prefix>/<triple>/<libdir> unless they should be preferred over; // those within the system root.; //; // Note that this matches the GCC behavior. See the below comment for where; // Clang diverges from GCC's behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:176,Deployability,install,installation,176,"// GCC cross compiling toolchains will install target libraries which ship; // as part of the toolchain under <prefix>/<triple>/<libdir> rather than as; // any part of the GCC installation in; // <prefix>/<libdir>/gcc/<triple>/<version>. This decision is somewhat; // debatable, but is the reality today. We need to search this tree even; // when we have a sysroot somewhere else. It is the responsibility of; // whomever is doing the cross build targeting a sysroot using a GCC; // installation that is *not* within the system root to ensure two things:; //; // 1) Any DSOs that are linked in from this tree or from the install path; // above must be present on the system root and found via an; // appropriate rpath.; // 2) There must not be libraries installed into; // <prefix>/<triple>/<libdir> unless they should be preferred over; // those within the system root.; //; // Note that this matches the GCC behavior. See the below comment for where; // Clang diverges from GCC's behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:483,Deployability,install,installation,483,"// GCC cross compiling toolchains will install target libraries which ship; // as part of the toolchain under <prefix>/<triple>/<libdir> rather than as; // any part of the GCC installation in; // <prefix>/<libdir>/gcc/<triple>/<version>. This decision is somewhat; // debatable, but is the reality today. We need to search this tree even; // when we have a sysroot somewhere else. It is the responsibility of; // whomever is doing the cross build targeting a sysroot using a GCC; // installation that is *not* within the system root to ensure two things:; //; // 1) Any DSOs that are linked in from this tree or from the install path; // above must be present on the system root and found via an; // appropriate rpath.; // 2) There must not be libraries installed into; // <prefix>/<triple>/<libdir> unless they should be preferred over; // those within the system root.; //; // Note that this matches the GCC behavior. See the below comment for where; // Clang diverges from GCC's behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:621,Deployability,install,install,621,"// GCC cross compiling toolchains will install target libraries which ship; // as part of the toolchain under <prefix>/<triple>/<libdir> rather than as; // any part of the GCC installation in; // <prefix>/<libdir>/gcc/<triple>/<version>. This decision is somewhat; // debatable, but is the reality today. We need to search this tree even; // when we have a sysroot somewhere else. It is the responsibility of; // whomever is doing the cross build targeting a sysroot using a GCC; // installation that is *not* within the system root to ensure two things:; //; // 1) Any DSOs that are linked in from this tree or from the install path; // above must be present on the system root and found via an; // appropriate rpath.; // 2) There must not be libraries installed into; // <prefix>/<triple>/<libdir> unless they should be preferred over; // those within the system root.; //; // Note that this matches the GCC behavior. See the below comment for where; // Clang diverges from GCC's behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:754,Deployability,install,installed,754,"// GCC cross compiling toolchains will install target libraries which ship; // as part of the toolchain under <prefix>/<triple>/<libdir> rather than as; // any part of the GCC installation in; // <prefix>/<libdir>/gcc/<triple>/<version>. This decision is somewhat; // debatable, but is the reality today. We need to search this tree even; // when we have a sysroot somewhere else. It is the responsibility of; // whomever is doing the cross build targeting a sysroot using a GCC; // installation that is *not* within the system root to ensure two things:; //; // 1) Any DSOs that are linked in from this tree or from the install path; // above must be present on the system root and found via an; // appropriate rpath.; // 2) There must not be libraries installed into; // <prefix>/<triple>/<libdir> unless they should be preferred over; // those within the system root.; //; // Note that this matches the GCC behavior. See the below comment for where; // Clang diverges from GCC's behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:414,Availability,avail,available,414,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:14,Deployability,install,installation,14,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:94,Deployability,install,installed,94,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:136,Deployability,install,installation,136,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:208,Deployability,install,installation,208,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:526,Deployability,configurat,configurations,526,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:526,Modifiability,config,configurations,526,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:591,Usability,simpl,simply,591,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:40,Deployability,install,installed,40,"// Android only uses the libc++ headers installed alongside the toolchain if; // they contain an Android-specific target include path, otherwise they're; // incompatible with the NDK libraries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:33,Deployability,install,installed,33,"// If this is a development, non-installed, clang, libcxx will; // not be found at ../include/c++ but it likely to be found at; // one of the following two locations:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:68,Integrability,depend,dependent,68,"// GPLUSPLUS_TOOL_INCLUDE_DIR. If Triple is not empty, add a target-dependent; // include directory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:109,Deployability,install,installation,109,"// By default, look for the C++ headers in an include directory adjacent to; // the lib directory of the GCC installation. Note that this is expect to be; // equivalent to '/usr/include/c++/X.Y' in almost all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:3,Safety,Detect,Detect,3,// Detect Debian g++-multiarch-incdir.diff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:88,Usability,simpl,simplicity,88,"// Otherwise, fall back on a bunch of options which don't use multiarch; // layouts for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:57,Deployability,install,install,57,"// Gentoo is weird and places its headers inside the GCC install,; // so if the first attempt to find the headers fails, try these patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:247,Performance,load,load,247,// If this tool chain is used for an OpenMP offloading device we have to make; // sure we always generate a shared library regardless of the commands the; // user passed to the host. This is required because the runtime library; // is required to load the device image dynamically at run time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:43,Deployability,install,installation,43,/// The set of multilibs that the detected installation supports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:34,Safety,detect,detected,34,/// The set of multilibs that the detected installation supports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:22,Deployability,integrat,integrated,22,"// A gcc tool has an ""integrated"" assembler that it will call to produce an; // object. Let it use that assembler so that we don't have to deal with; // assembly syntax incompatibilities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:22,Integrability,integrat,integrated,22,"// A gcc tool has an ""integrated"" assembler that it will call to produce an; // object. Let it use that assembler so that we don't have to deal with; // assembly syntax incompatibilities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:58,Performance,perform,perform,58,/// Generic_GCC - A tool chain using the 'gcc' command to perform; /// all subcommands; this relies on gcc translating the majority of; /// command line options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:338,Availability,toler,tolerate,338,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:347,Deployability,release,release,347,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:563,Deployability,patch,patch,563,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:603,Deployability,patch,patch,603,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:692,Deployability,patch,patches,692,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:317,Modifiability,flexible,flexible,317,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:662,Testability,log,logic,662,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:33,Deployability,patch,patch,33,"/// The parsed major, minor, and patch numbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:30,Deployability,patch,patch,30,/// Any textual suffix on the patch number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:41,Deployability,install,installation,41,"/// This is a class to find a viable GCC installation for Clang to; /// use.; ///; /// This class tries to find a GCC installation on the system, and report; /// information about it. It starts from the host information provided to the; /// Driver, and has logic for fuzzing that where appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:118,Deployability,install,installation,118,"/// This is a class to find a viable GCC installation for Clang to; /// use.; ///; /// This class tries to find a GCC installation on the system, and report; /// information about it. It starts from the host information provided to the; /// Driver, and has logic for fuzzing that where appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:257,Testability,log,logic,257,"/// This is a class to find a viable GCC installation for Clang to; /// use.; ///; /// This class tries to find a GCC installation on the system, and report; /// information about it. It starts from the host information provided to the; /// Driver, and has logic for fuzzing that where appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:25,Deployability,install,install,25,// We retain the list of install paths that were considered and rejected in; // order to print out detailed information in verbose mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:43,Deployability,install,installation,43,/// The set of multilibs that the detected installation supports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:34,Safety,detect,detected,34,/// The set of multilibs that the detected installation supports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:29,Deployability,configurat,configurations,29,// Gentoo-specific toolchain configurations are stored here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:29,Modifiability,config,configurations,29,// Gentoo-specific toolchain configurations are stored here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:42,Deployability,install,install,42,/// Check whether we detected a valid GCC install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:21,Safety,detect,detected,21,/// Check whether we detected a valid GCC install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:40,Deployability,install,install,40,/// Get the GCC triple for the detected install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:31,Safety,detect,detected,31,/// Get the GCC triple for the detected install.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:25,Deployability,install,installation,25,/// Get the detected GCC installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,Safety,detect,detected,12,/// Get the detected GCC installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,Safety,detect,detected,12,/// Get the detected GCC parent lib path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,Safety,detect,detected,12,/// Get the detected Multilib,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,Safety,detect,detected,12,/// Get the detected GCC version string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:45,Deployability,install,installation,45,/// Print information about the detected GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:32,Safety,detect,detected,32,/// Print information about the detected GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:54,Safety,avoid,avoid,54,// -rdynamic is a no-op with Haiku. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:58,Safety,avoid,avoid,58,// No need to do anything for pthreads. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:27,Modifiability,config,configure,27,// Add dirs specified via 'configure --with-c-include-dirs'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:34,Availability,error,error,34,// getAsInteger returns 'true' on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:83,Availability,failure,failure,83,"// Return an std::optional<StringRef>:; // - std::nullopt indicates a verification failure, or that the flag was not; // present in Args.; // - Otherwise the returned value is that name of the feature to add; // to Features.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:91,Integrability,depend,dependency,91,"// 't' in Cpu denotes tiny-core micro-architecture. For now, the co-processors; // have no dependency on micro-architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:388,Safety,safe,safely,388,"// Only pass -x if gcc will understand it; otherwise hope gcc; // understands the suffix correctly. The main use case this would go; // wrong in is for linker inputs if they happened to have an odd; // suffix; really the only way to get this to happen is a command; // like '-x foobar a.c' which will treat a.c like a linker input.; //; // FIXME: For the linker case specifically, can we safely convert; // inputs into '-Wl,' options?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:39,Deployability,Install,InstalledDir,39,// Note: Generic_GCC::Generic_GCC adds InstalledDir and getDriver().Dir to; // program paths,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.h:103,Usability,simpl,simply,103,"// For Hexagon, we do not need to instantiate tools for PreProcess, PreCompile; // and Compile.; // We simply use ""clang -cc1"" for those actions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, we only allow -fsanitize=address",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:214,Integrability,depend,dependencies,214,"// Given that host and device linking happen in separate processes, the device; // linker doesn't always have the visibility as to which device symbols are; // needed by a program, especially for the device symbol dependencies that are; // introduced through the host symbol resolution.; // For example: host_A() (A.obj) --> host_B(B.obj) --> device_kernel_B(); // (B.obj) In this case, the device linker doesn't know that A.obj actually; // depends on the kernel functions in B.obj. When linking to static device; // library, the device linker may drop some of the device global symbols if; // they aren't referenced. As a workaround, we are adding to the; // --whole-archive flag such that all global symbols would be linked in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:442,Integrability,depend,depends,442,"// Given that host and device linking happen in separate processes, the device; // linker doesn't always have the visibility as to which device symbols are; // needed by a program, especially for the device symbol dependencies that are; // introduced through the host symbol resolution.; // For example: host_A() (A.obj) --> host_B(B.obj) --> device_kernel_B(); // (B.obj) In this case, the device linker doesn't know that A.obj actually; // depends on the kernel functions in B.obj. When linking to static device; // library, the device linker may drop some of the device global symbols if; // they aren't referenced. As a workaround, we are adding to the; // --whole-archive flag such that all global symbols would be linked in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:24,Security,sanitiz,sanitizer,24,// Diagnose unsupported sanitizer options only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:522,Availability,toler,tolerate,522,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:37,Security,sanitiz,sanitizers,37,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:80,Security,sanitiz,sanitizer,80,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:270,Security,sanitiz,sanitizers,270,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:305,Security,sanitiz,sanitization,305,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:20,Modifiability,plugin,plugin,20,// Locates HIP pass plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:522,Availability,toler,tolerate,522,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:37,Security,sanitiz,sanitizers,37,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:80,Security,sanitiz,sanitizer,80,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:270,Security,sanitiz,sanitizers,270,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:305,Security,sanitiz,sanitization,305,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:83,Safety,abort,aborts,83,// Debug info generation is disabled for SPIRV-LLVM-Translator; // which currently aborts on the presence of DW_OP_LLVM_convert.; // TODO: Enable debug info when the SPIR-V backend arrives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp:194,Performance,cache,cache,194,"// Add MC directives to embed target binaries. We ensure that each; // section and image is 16-byte aligned. This is not mandatory, but; // increases the likelihood of data to be aligned with a cache block; // in several main host machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp:114,Testability,test,testing,114,// Dump the contents of the temp object file gen if the user requested that.; // We support this option to enable testing of behavior with -###.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPUtility.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp:15,Security,validat,validator,15,// Add default validator version if not set.; // TODO: remove this once read validator version from validator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp:77,Security,validat,validator,77,// Add default validator version if not set.; // TODO: remove this once read validator version from validator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp:100,Security,validat,validator,100,// Add default validator version if not set.; // TODO: remove this once read validator version from validator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp:14,Security,validat,validation,14,// FIXME: add validation for enable_16bit_types should be after HLSL 2018 and; // shader model 6.2.; // See: https://github.com/llvm/llvm-project/issues/57876,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:197,Deployability,install,install,197,// We use the existence of '/lib/<triple>' as a directory to detect some; // common hurd triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:61,Safety,detect,detect,61,// We use the existence of '/lib/<triple>' as a directory to detect some; // common hurd triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:553,Modifiability,refactor,refactoring,553,"// It happens that only x86 and PPC use the 'lib32' variant of oslibdir, and; // using that variant while targeting other architectures causes problems; // because the libraries are laid out in shared system roots that can't cope; // with a 'lib32' library search path being considered. So we only enable; // them when we know we may need it.; //; // FIXME: This is a bit of a hack. We should really unify this code for; // reasoning about oslibdir spellings with the lib dir spellings in the; // GCCInstallationDetector, but that is a more significant refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:223,Deployability,install,installed,223,"// Similar to the logic for GCC above, if we currently running Clang inside; // of the requested system root, add its parent library paths to; // those searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:18,Testability,log,logic,18,"// Similar to the logic for GCC above, if we currently running Clang inside; // of the requested system root, add its parent library paths to; // those searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:182,Usability,clear,clear,182,"// Similar to the logic for GCC above, if we currently running Clang inside; // of the requested system root, add its parent library paths to; // those searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:226,Deployability,install,installed,226,"// Similar to the logic for GCC above, if we are currently running Clang; // inside of the requested system root, add its parent library path to those; // searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:18,Testability,log,logic,18,"// Similar to the logic for GCC above, if we are currently running Clang; // inside of the requested system root, add its parent library path to those; // searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:185,Usability,clear,clear,185,"// Similar to the logic for GCC above, if we are currently running Clang; // inside of the requested system root, add its parent library path to those; // searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:25,Safety,detect,detect,25,"// Lacking those, try to detect the correct set of system includes for the; // target triple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:26,Deployability,install,installation,26,// We need a detected GCC installation on Linux to provide libstdc++'s; // headers in odd Linuxish places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:13,Safety,detect,detected,13,// We need a detected GCC installation on Linux to provide libstdc++'s; // headers in odd Linuxish places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp:9,Integrability,Interface,InterfaceStubs,9,"//===--- InterfaceStubs.cpp - Base InterfaceStubs Implementations C++ ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp:35,Integrability,Interface,InterfaceStubs,35,"//===--- InterfaceStubs.cpp - Base InterfaceStubs Implementations C++ ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp:101,Integrability,interface,interface-stubs,101,"// Normally we want to write to a side-car file ending in "".ifso"" so for; // example if `clang -emit-interface-stubs -shared -o libhello.so` were; // invoked then we would like to get libhello.so and libhello.ifso. If the; // stdout stream is given as the output file (ie `-o -`), that is the one; // exception where we will just append to the same filestream as the normal; // output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp:111,Testability,stub,stubs,111,"// Normally we want to write to a side-car file ending in "".ifso"" so for; // example if `clang -emit-interface-stubs -shared -o libhello.so` were; // invoked then we would like to get libhello.so and libhello.ifso. If the; // stdout stream is given as the output file (ie `-o -`), that is the one; // exception where we will just append to the same filestream as the normal; // output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h:9,Integrability,Interface,InterfaceStubs,9,"//===--- InterfaceStubs.cpp - Base InterfaceStubs Implementations C++ ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h:35,Integrability,Interface,InterfaceStubs,35,"//===--- InterfaceStubs.cpp - Base InterfaceStubs Implementations C++ ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:41,Safety,Detect,Detection,41,"//===--- LazyDetector.h - Lazy ToolChain Detection --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:11,Integrability,wrap,wrapper,11,/// Simple wrapper for toolchain detector with costly initialization. This; /// delays the creation of the actual detector until its first usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:33,Safety,detect,detector,33,/// Simple wrapper for toolchain detector with costly initialization. This; /// delays the creation of the actual detector until its first usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:114,Safety,detect,detector,114,/// Simple wrapper for toolchain detector with costly initialization. This; /// delays the creation of the actual detector until its first usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:4,Usability,Simpl,Simple,4,/// Simple wrapper for toolchain detector with costly initialization. This; /// delays the creation of the actual detector until its first usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:198,Deployability,install,install,198,// We use the existence of '/lib/<triple>' as a directory to detect some; // common linux triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:61,Safety,detect,detect,61,// We use the existence of '/lib/<triple>' as a directory to detect some; // common linux triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:560,Modifiability,refactor,refactoring,560,"// It happens that only x86, PPC and SPARC use the 'lib32' variant of; // oslibdir, and using that variant while targeting other architectures causes; // problems because the libraries are laid out in shared system roots that; // can't cope with a 'lib32' library search path being considered. So we only; // enable them when we know we may need it.; //; // FIXME: This is a bit of a hack. We should really unify this code for; // reasoning about oslibdir spellings with the lib dir spellings in the; // GCCInstallationDetector, but that is a more significant refactoring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:49,Energy Efficiency,reduce,reduce,49,"// Android ARM/AArch64 use max-page-size=4096 to reduce VMA usage. Note, lld; // from 11 onwards default max-page-size to 65536 for both ARM and AArch64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:100,Deployability,install,install,100,"// With devtoolset on RHEL, we want to add a bin directory that is relative; // to the detected gcc install, because if we are using devtoolset gcc then; // we want to use other tools from devtoolset (e.g. ld) instead of the; // standard system tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:87,Safety,detect,detected,87,"// With devtoolset on RHEL, we want to add a bin directory that is relative; // to the detected gcc install, because if we are using devtoolset gcc then; // we want to use other tools from devtoolset (e.g. ld) instead of the; // standard system tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:284,Performance,load,loader,284,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:351,Performance,load,loader,351,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:20,Security,hash,hash,20,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:61,Security,hash,hash,61,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:144,Security,hash,hash,144,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:180,Security,hash,hash,180,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:313,Security,hash,hash,313,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:380,Security,hash,hash,380,// Do not use 'gnu' hash style for Mips targets because .gnu.hash; // and the MIPS ABI require .dynsym to be sorted in different ways.; // .gnu.hash needs symbols to be grouped by hash code whereas the MIPS; // ABI requires a mapping between the GOT and the symbol table.; // Android loader does not support .gnu.hash until API 23.; // Hexagon linker/loader does not support .gnu.hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:148,Availability,avail,available,148,"// On Android 14 and newer, there is a special linker_hwasan64 that; // allows to run HWASan binaries on non-HWASan system images. This; // is also available on HWASan system images, so we can just always; // use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:26,Deployability,install,installation,26,// We need a detected GCC installation on Linux to provide libstdc++'s; // headers in odd Linuxish places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:13,Safety,detect,detected,13,// We need a detected GCC installation on Linux to provide libstdc++'s; // headers in odd Linuxish places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:3,Safety,Detect,Detect,3,// Detect Debian g++-multiarch-incdir.diff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:19,Safety,detect,detection,19,// Try generic GCC detection first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:14,Deployability,install,installation,14,"// Cray's gcc installation puts headers under ""g++"" without a; // version suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:97,Security,sanitiz,sanitizer,97,"// Add the compiler-rt library directories if they exist to help; // the linker find the various sanitizer, builtin, and profiling runtimes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:24,Availability,avail,available,24,// Add crtfastmath.o if available and fast math is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:3,Usability,Simpl,Simplified,3,// Simplified from Generic_GCC::GCCInstallationDetector::ScanLibDirForGCCTriple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:20,Safety,detect,detecting,20,// The sequence for detecting a sysroot here should be kept in sync with; // the testTriple function below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:81,Testability,test,testTriple,81,// The sequence for detecting a sysroot here should be kept in sync with; // the testTriple function below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:10,Deployability,install,install,10,"// If the install base of Clang seems to have mingw sysroot files directly; // in the toplevel include and lib directories, use this as base instead of; // looking for a triple prefixed GCC in the path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:80,Safety,detect,detect,80,"// If an explicit sysroot is set, that will be used and we shouldn't try to; // detect anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:10,Deployability,install,install,10,"// If the install base itself looks like a mingw sysroot, we'll use that; // - don't use any potentially unrelated gcc to influence what triple to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:9,Testability,test,test,9,// First test if the original triple can find a sysroot with the triple; // name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:11,Testability,test,test,11,"// If not, test a couple other possible arch names that might be what was; // intended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:86,Deployability,install,installed,86,"// Try to find Exe from a Visual Studio distribution. This first tries to find; // an installed copy of Visual Studio and, failing that, looks in the PATH,; // making sure that whatever executable that's found is not a same-named exe; // from clang itself to prevent clang from falling back to itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:37,Modifiability,config,configured,37,"// If the VC environment hasn't been configured (perhaps because the user; // did not run vcvarsall), try to build a consistent link environment. If; // the environment variable is set however, assume the user knows what; // they're doing. If the user passes /vctoolsdir or /winsdkdir, trust that; // over env vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:169,Modifiability,variab,variable,169,"// If the VC environment hasn't been configured (perhaps because the user; // did not run vcvarsall), try to build a consistent link environment. If; // the environment variable is set however, assume the user knows what; // they're doing. If the user passes /vctoolsdir or /winsdkdir, trust that; // over env vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:108,Security,sanitiz,sanitizer,108,"// Add the compiler-rt library directories to libpath if they exist to help; // the linker find the various sanitizer, builtin, and profiling runtimes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:46,Performance,optimiz,optimized,46,// Make sure the dynamic runtime thunk is not optimized out at link time; // to ensure proper SEH handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:146,Integrability,interface,interface,146,// Make sure the linker consider all object files from the static lib.; // This is necessary because instrumented dlls need access to all the; // interface exported by the static lib in the main executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:124,Security,access,access,124,// Make sure the linker consider all object files from the static lib.; // This is necessary because instrumented dlls need access to all the; // interface exported by the static lib in the main executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:140,Deployability,install,install,140,"// If we're using the MSVC linker, it's not sufficient to just use link; // from the program PATH, because other environments like GnuWin32 install; // their own link.exe which may come first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:108,Modifiability,variab,variable,108,"// Now loop over each string in the block and copy them into the; // environment vector, adjusting the PATH variable as needed when we; // find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:19,Security,access,access,19,"// When built with access to the proper Windows APIs, try to actually find; // the correct include paths first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:33,Deployability,install,install,33,"// As a fallback, select default install paths.; // FIXME: Don't guess drives and paths like this on Windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:35,Testability,log,logic,35,// FIXME: There should probably be logic here to find libc++ on Windows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:104,Deployability,update,update,104,"// -fms-compatibility-version=19.33 is default, aka 2022, 17.3; // NOTE: when changing this value, also update; // clang/docs/CommandGuide/clang.rst and clang/docs/UsersManual.rst; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:151,Performance,optimiz,optimization,151,"// Don't warn about /Oy- in x86-64 builds (where; // SupportsForcingFramePointer is false). The flag having no effect; // there is a compiler-internal optimization, and people shouldn't have; // to special-case their build files for x86-64 clang-cl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:360,Testability,log,logic,360,"// The -O[12xd] flag actually expands to several flags. We must desugar the; // flags so that options embedded can be negated. For example, the '-O2' flag; // enables '-Oy'. Expanding '-O2' into its constituent flags allows us to; // correctly handle '-O2 -Oy-' where the trailing '-Oy-' disables a single; // aspect of '-O2'.; //; // Note that this expansion logic only applies to the *last* of '[12xd]'.; // First step is to search for the character we'd like to expand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:131,Availability,mask,masking,131,// NaCl ARM assembly (inline or standalone) can be written with a set of macros; // for the various SFI requirements like register masking. The assembly tool; // inserts the file containing the macros as an input into all the assembly; // jobs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:126,Security,sanitiz,sanitizers,126,"// This is quite similar to gnutools::Linker::ConstructJob with changes that; // we use static by default, do not yet support sanitizers or LTO, and a few; // others. Eventually we can support more of that and hopefully migrate back; // to gnutools::Linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:119,Availability,error,error,119,"// Check for -stdlib= flags. We only support libc++ but this consumes the arg; // if the value is libc++, and emits an error for other values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:13,Integrability,depend,depends,13,"// libgcc_eh depends on libc, so resolve as much as possible,; // pull in any new requirements from libc and then get the rest; // of libgcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:192,Testability,test,test,192,"// When targeting a 32-bit platform, try the special directory used on; // 64-bit hosts, and only fall back to the main library directory if that; // doesn't work.; // FIXME: It'd be nicer to test if this directory exists, but I'm not sure; // what all logic is needed to emulate the '=' prefix here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:253,Testability,log,logic,253,"// When targeting a 32-bit platform, try the special directory used on; // 64-bit hosts, and only fall back to the main library directory if that; // doesn't work.; // FIXME: It'd be nicer to test if this directory exists, but I'm not sure; // what all logic is needed to emulate the '=' prefix here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:10,Deployability,install,install,10,// system install with full upstream path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp:10,Deployability,install,install,10,// system install from src,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NetBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:198,Deployability,install,install,198,// We use the existence of '/lib/<triple>' as a directory to detect some; // common linux triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:61,Safety,detect,detect,61,// We use the existence of '/lib/<triple>' as a directory to detect some; // common linux triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:8,Security,hash,hash,8,// .gnu.hash section is not compatible with the MIPS target,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:74,Availability,mask,mask,74,// TODO: kASAN for liteos ??; // TODO: Support TSAN and HWASAN and update mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:67,Deployability,update,update,67,// TODO: kASAN for liteos ??; // TODO: Support TSAN and HWASAN and update mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below (i.e.; // AddRunTimeLibs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OpenBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.cpp:25,Energy Efficiency,Power,PowerPC,25,"//===-- PPCFreeBSD.cpp - PowerPC ToolChain Implementations ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.h:24,Energy Efficiency,Power,PowerPC,24,"//===--- PPCFreeBSD.h - PowerPC ToolChain Implementations -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCFreeBSD.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp:23,Energy Efficiency,Power,PowerPC,23,"//===-- PPCLinux.cpp - PowerPC ToolChain Implementations --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp:25,Deployability,install,installed,25,"// Since glibc 2.34, the installed .so file is not symlink anymore. But we can; // still safely assume it's newer than 2.32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp:89,Safety,safe,safely,89,"// Since glibc 2.34, the installed .so file is not symlink anymore. But we can; // still safely assume it's newer than 2.32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.h:22,Energy Efficiency,Power,PowerPC,22,"//===--- PPCLinux.h - PowerPC ToolChain Implementations ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp:21,Performance,perform,perform,21,// This tells LTO to perform JustMyCode instrumentation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp:185,Deployability,install,installation,185,"// Determine where to find the PS4/PS5 libraries.; // If -isysroot was passed, use that as the SDK base path.; // If not, we use the EnvVar if it exists; otherwise use the driver's; // installation path, which should be <SDK_DIR>/host_tools/bin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PS4CPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp:37,Deployability,install,installation,37,// This function tests whether a gcc installation is present either; // through gcc-toolchain argument or in the same prefix where clang; // is installed. This helps decide whether to instantiate this toolchain; // or Baremetal toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp:144,Deployability,install,installed,144,// This function tests whether a gcc installation is present either; // through gcc-toolchain argument or in the same prefix where clang; // is installed. This helps decide whether to instantiate this toolchain; // or Baremetal toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp:17,Testability,test,tests,17,// This function tests whether a gcc installation is present either; // through gcc-toolchain argument or in the same prefix where clang; // is installed. This helps decide whether to instantiate this toolchain; // or Baremetal toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp:31,Deployability,install,installations,31,// Multilib cross-compiler GCC installations put ld in a triple-prefixed; // directory off of the parent of the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp:116,Deployability,install,installation,116,// Multilib cross-compiler GCC installations put ld in a triple-prefixed; // directory off of the parent of the GCC installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:23,Deployability,install,installation,23,"//===--- ROCm.h - ROCm installation detector --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:36,Safety,detect,detector,36,"//===--- ROCm.h - ROCm installation detector --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:34,Deployability,install,installation,34,/// A class to find a viable ROCM installation; /// TODO: Generalize to handle libclc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:3,Deployability,Install,Installation,3,// Installation path candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:3,Deployability,Release,Release,3,// Release string for ROCm packages built with SPACK if not empty. The; // installation directories of ROCm packages built with SPACK follow the; // convention <package_name>-<rocm_release_string>-<hash>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:75,Deployability,install,installation,75,// Release string for ROCm packages built with SPACK if not empty. The; // installation directories of ROCm packages built with SPACK follow the; // convention <package_name>-<rocm_release_string>-<hash>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:198,Security,hash,hash,198,// Release string for ROCm packages built with SPACK if not empty. The; // installation directories of ROCm packages built with SPACK follow the; // convention <package_name>-<rocm_release_string>-<hash>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:26,Safety,detect,detected,26,// Default version if not detected or specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:37,Deployability,Patch,Patch,37,// The version string in Major.Minor.Patch format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:22,Deployability,patch,patch,22,// Version containing patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:36,Integrability,depend,depending,36,// Libraries that are always linked depending on the language,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:14,Deployability,install,installation,14,// Cache ROCm installation search paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:3,Performance,Cache,Cache,3,// Cache ROCm installation search paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:62,Deployability,install,installation,62,/// Find the path to a SPACK package under the ROCm candidate installation; /// directory if the candidate is a SPACK ROCm candidate. \returns empty; /// string if the candidate is not SPACK ROCm candidate or the requested; /// package is not found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,Safety,detect,detected,21,/// Check whether we detected a valid HIP runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,Safety,detect,detected,21,/// Check whether we detected a valid ROCm device library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,Safety,detect,detected,21,/// Check whether we detected a valid HIP STDPAR Acceleration library.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:46,Deployability,install,installation,46,/// Print information about the detected ROCm installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:32,Safety,detect,detected,32,/// Print information about the detected ROCm installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:26,Deployability,install,install,26,/// Get the detected Rocm install's version.; // RocmVersion version() const { return Version; }; /// Get the detected Rocm installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:124,Deployability,install,installation,124,/// Get the detected Rocm install's version.; // RocmVersion version() const { return Version; }; /// Get the detected Rocm installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,Safety,detect,detected,12,/// Get the detected Rocm install's version.; // RocmVersion version() const { return Version; }; /// Get the detected Rocm installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:110,Safety,detect,detected,110,/// Get the detected Rocm install's version.; // RocmVersion version() const { return Version; }; /// Get the detected Rocm installation path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,Safety,detect,detected,12,/// Get the detected path to Rocm's bin directory.; // StringRef getBinPath() const { return BinPath; }; /// Get the detected Rocm Include path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:117,Safety,detect,detected,117,/// Get the detected path to Rocm's bin directory.; // StringRef getBinPath() const { return BinPath; }; /// Get the detected Rocm Include path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,Safety,detect,detected,12,/// Get the detected Rocm library path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,Safety,detect,detected,12,/// Get the detected Rocm device library path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:56,Availability,avail,available,56,/// Returns empty string of Asan runtime library is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:25,Availability,error,errors,25,// Demangle C++ names in errors. GNU ld already defaults to --demangle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:117,Safety,avoid,avoid,117,"// libpthread has been folded into libc since Solaris 10, no need to do; // anything for pthreads. Claim argument to avoid warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:59,Safety,avoid,avoid,59,// -rdynamic is a no-op with Solaris ld. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:24,Availability,avail,available,24,// Add crtfastmath.o if available and fast math is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:125,Integrability,depend,depends,125,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:161,Integrability,depend,dependencies,161,"// Additional linker set-up and flags for Fortran. This is required in order; // to generate executables. As Fortran runtime depends on the C runtime,; // these dependencies need to be listed before the C runtime below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:111,Availability,avail,available,111,"// Work around Solaris/amd64 ld bug when calling __tls_get_addr directly.; // However, ld -z relax=transtls is available since Solaris 11.2, but not; // in Illumos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:3,Safety,Avoid,Avoid,3,"// Avoid AsanInitInternal cycle, Issue #64126.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:26,Deployability,install,installation,26,// We need a detected GCC installation on Solaris (similar to Linux); // to provide libstdc++'s headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:13,Safety,detect,detected,13,// We need a detected GCC installation on Solaris (similar to Linux); // to provide libstdc++'s headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:109,Deployability,install,installation,109,"// By default, look for the C++ headers in an include directory adjacent to; // the lib directory of the GCC installation.; // On Solaris this usually looks like /usr/gcc/X.Y/include/c++/X.Y.Z",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp:64,Performance,perform,perform,64,/// TCEToolChain - A tool chain using the llvm bitcode tools to perform; /// all subcommands. See http://tce.cs.tut.fi for our peculiar target.; /// Currently does not support anything else but compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h:64,Performance,perform,perform,64,/// TCEToolChain - A tool chain using the llvm bitcode tools to perform; /// all subcommands. See http://tce.cs.tut.fi for our peculiar target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp:49,Modifiability,variab,variable,49,"// ProgramPaths are found via 'PATH' environment variable.; // Default library paths are following:; // ${RESOURCEDIR}/lib/ve-unknown-linux-gnu,; // These are OK.; // Default file paths are following:; // ${RESOURCEDIR}/lib/ve-unknown-linux-gnu, (== getArchSpecificLibPaths); // ${RESOURCEDIR}/lib/linux/ve, (== getArchSpecificLibPaths); // /lib/../lib64,; // /usr/lib/../lib64,; // ${BINPATH}/../lib,; // /lib,; // /usr/lib,; // These are OK for host, but no go for VE.; // Define file paths from scratch here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp:43,Deployability,install,installation,43,"// Add following paths for multiple target installation.; // ${INSTALLDIR}/include/ve-unknown-linux-gnu/c++/v1,; // ${INSTALLDIR}/include/c++/v1,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp:63,Deployability,INSTALL,INSTALLDIR,63,"// Add following paths for multiple target installation.; // ${INSTALLDIR}/include/ve-unknown-linux-gnu/c++/v1,; // ${INSTALLDIR}/include/c++/v1,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp:118,Deployability,INSTALL,INSTALLDIR,118,"// Add following paths for multiple target installation.; // ${INSTALLDIR}/include/ve-unknown-linux-gnu/c++/v1,; // ${INSTALLDIR}/include/c++/v1,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/VEToolchain.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:63,Integrability,wrap,wraps,63,// On `wasip2` the default linker is `wasm-component-ld` which wraps the; // execution of `wasm-ld`. Find `wasm-ld` and pass it as an argument of where; // to find it to avoid it needing to hunt and rediscover or search `PATH` for; // where it is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:170,Safety,avoid,avoid,170,// On `wasip2` the default linker is `wasm-component-ld` which wraps the; // execution of `wasm-ld`. Find `wasm-ld` and pass it as an argument of where; // to find it to avoid it needing to hunt and rediscover or search `PATH` for; // where it is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:35,Availability,avail,available,35,"// When optimizing, if wasm-opt is available, run it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing, if wasm-opt is available, run it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:64,Availability,avail,available,64,"// For LTO, enable use of lto-enabled sysroot libraries too, if available.; // Note that the directory is keyed to the LLVM revision, as LLVM's; // bitcode format is not stable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:77,Integrability,depend,depends,77,// -fPIC implies +mutable-globals because the PIC ABI used by the linker; // depends on importing and exporting mutable globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:13,Modifiability,config,configure-time,13,// Check for configure-time C include directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:101,Deployability,install,installation,101,"// We cannot use GCCInstallationDetector here as the sysroot usually does; // not contain a full GCC installation.; // Instead, we search the given sysroot for /usr/include/xx, similar; // to how we do it for libc++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:22,Safety,detect,detectLibcxxVersion,22,// This is similar to detectLibcxxVersion(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.cpp:49,Modifiability,variab,variable,49,// ProgramPaths are found via 'PATH' environment variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.h:101,Usability,simpl,simply,101,"// For XCore, we do not need to instantiate tools for PreProcess, PreCompile and; // Compile.; // We simply use ""clang -cc1"" for those actions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/XCore.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp:148,Deployability,install,installation,148,// z/OS tool chain depends on LE data sets and the CSSLIB data set.; // These data sets can have different high level qualifiers (HLQs); // as each installation can define them differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp:19,Integrability,depend,depends,19,// z/OS tool chain depends on LE data sets and the CSSLIB data set.; // These data sets can have different high level qualifiers (HLQs); // as each installation can define them differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp:4,Deployability,install,install,4,// <install>/bin/../include/c++/v1,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ZOS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp:157,Availability,error,error,157,"// Call getAArch64ArchFeaturesFromMarch only if ""-Wa,-march="" or; // ""-Xassembler -march"" is detected. Otherwise it may return false; // and causes Clang to error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp:93,Safety,detect,detected,93,"// Call getAArch64ArchFeaturesFromMarch only if ""-Wa,-march="" or; // ""-Xassembler -march"" is detected. Otherwise it may return false; // and causes Clang to error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:113,Availability,avail,available,113,// If -mfloat-abi=hard or -mhard-float are specified explicitly then check that; // floating point registers are available on the target CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:67,Availability,down,down,67,"// Here, we make sure that -Wa,-mfpu/cpu/arch/hwdiv will be passed down; // to the assembler correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:7,Deployability,integrat,integrated,7,"// The integrated assembler doesn't implement e_flags setting behavior for; // -meabi=gnu (gcc -mabi={apcs-gnu,atpcs} passes -meabi=gnu to gas). For; // compatibility we accept but warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:7,Integrability,integrat,integrated,7,"// The integrated assembler doesn't implement e_flags setting behavior for; // -meabi=gnu (gcc -mabi={apcs-gnu,atpcs} passes -meabi=gnu to gas). For; // compatibility we accept but warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:16,Integrability,depend,dependent,16,// Handle (arch-dependent) fp16fml/fullfp16 relationship.; // Must happen before any features are disabled due to soft-float.; // FIXME: this fp16fml option handling will be reimplemented after the; // TargetParser rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:215,Modifiability,rewrite,rewrite,215,// Handle (arch-dependent) fp16fml/fullfp16 relationship.; // Must happen before any features are disabled due to soft-float.; // FIXME: this fp16fml option handling will be reimplemented after the; // TargetParser rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:202,Integrability,depend,depends,202,"// -mfpu=none, -march=armvX+nofp or -mcpu=X+nofp is *very* similar to; // -mfloat-abi=soft, only that it should not disable MVE-I. They disable the; // FPU, but not the FPU registers, thus MVE-I, which depends only on the; // latter, is still supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:551,Modifiability,rewrite,rewrite,551,"// For Arch >= ARMv8.0 && A or R profile: crypto = sha2 + aes; // Rather than replace within the feature vector, determine whether each; // algorithm is enabled and append this to the end of the vector.; // The algorithms can be controlled by their specific feature or the crypto; // feature, so their status can be determined by the last occurance of; // either in the vector. This allows one to supercede the other.; // e.g. +crypto+noaes in -march/-mcpu should enable sha2, but not aes; // FIXME: this needs reimplementation after the TargetParser rewrite",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:13,Deployability,integrat,integrated-as,13,// With -fno-integrated-as -mfpu=crypto-neon-fp-armv8 some assemblers such; // as the GNU assembler will permit the use of crypto instructions as the; // fpu will override the architecture. We keep the crypto feature in this; // case to preserve compatibility. In all other cases we remove the crypto; // feature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:13,Integrability,integrat,integrated-as,13,// With -fno-integrated-as -mfpu=crypto-neon-fp-armv8 some assemblers such; // as the GNU assembler will permit the use of crypto instructions as the; // fpu will override the architecture. We keep the crypto feature in this; // case to preserve compatibility. In all other cases we remove the crypto; // feature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:62,Performance,perform,performed,62,// CMSE: Check for target 8M (for -mcmse to be applicable) is performed later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:41,Security,access,access,41,"// Generate execute-only output (no data access to code sections).; // This only makes sense for the compiler, not for the assembler.; // It's not needed for multilib selection and may hide an unused; // argument diagnostic if the code is always run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:41,Security,access,access,41,// No v6M core supports unaligned memory access (v6M ARM ARM A3.2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:77,Security,access,access,77,"// v8M Baseline follows on from v6M, so doesn't support unaligned memory; // access either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:372,Availability,fault,fault,372,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:112,Integrability,depend,depending,112,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:513,Safety,safe,safe,513,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:46,Security,access,accesses,46,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:103,Security,access,accesses,103,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:242,Security,access,accesses,242,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:391,Security,access,accesses,391,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:576,Security,access,accesses,576,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:135,Availability,redundant,redundant,135,"/// getLLVMArchSuffixForARM - Get the LLVM arch name to use for a particular; /// CPU (or Arch, if CPU is generic).; // FIXME: This is redundant with -mcpu, why does LLVM use this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:135,Safety,redund,redundant,135,"/// getLLVMArchSuffixForARM - Get the LLVM arch name to use for a particular; /// CPU (or Arch, if CPU is generic).; // FIXME: This is redundant with -mcpu, why does LLVM use this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:450,Usability,clear,clear,450,"// This was originally permitted (and indeed the canonical way) to; // represent the {ILP32,LP64}D ABIs, but in Feb 2023 Loongson decided to; // drop the explicit suffix in favor of unmarked `-gnu` for the; // ""general-purpose"" ABIs, among other non-technical reasons.; //; // The spec change did not mention whether existing usages of ""gnuf64""; // shall remain valid or not, so we are going to continue recognizing it; // for some time, until it is clear that everyone else has migrated away; // from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:59,Security,access,access,59,// Select the `ual` feature determined by -m[no-]unaligned-access; // or the alias -m[no-]strict-align.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:7,Integrability,depend,depends,7,// LSX depends on 64-bit FPU.; // -m*-float and -mfpu=none/0/32 conflict with -mlsx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:8,Integrability,depend,depends,8,// LASX depends on 64-bit FPU and LSX.; // -mno-lsx conflicts with -mlasx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp:16,Availability,error,error,16,// FIXME: Throw error when multiple sub-architecture flag exist,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/M68k.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:554,Performance,perform,perform,554,"// Historically, PIC code for MIPS was associated with -mabicalls, a.k.a; // SVR4 abicalls. Static code does not use SVR4 calling sequences. An ABI; // extension was developed by Richard Sandiford & Code Sourcery to support; // static code calling PIC code (CPIC). For O32 and N32 this means we have; // several combinations of PIC/static and abicalls. Pure static, static; // with the CPIC extension, and pure PIC code.; // At final link time, O32 and N32 with CPIC will have another section; // added to the binary which contains the stub functions to perform; // any fixups required for PIC code.; // For N64, the situation is more regular: code can either be static; // (non-abicalls) or PIC (abicalls). GCC has traditionally picked PIC code; // code for N64. Since Clang has already built the relocation model portion; // of the commandline, we pick add +noabicalls feature in the N64 static; // case.; // The is another case to be accounted for: -msym32, which enforces that all; // symbols have 32 bits in size. In this case, N64 can in theory use CPIC; // but it is unsupported.; // The combinations for N64 are:; // a) Static without abicalls and 64bit symbols.; // b) Static with abicalls and 32bit symbols.; // c) PIC with abicalls and 64bit symbols.; // For case (a) we need to add +noabicalls for N64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:536,Testability,stub,stub,536,"// Historically, PIC code for MIPS was associated with -mabicalls, a.k.a; // SVR4 abicalls. Static code does not use SVR4 calling sequences. An ABI; // extension was developed by Richard Sandiford & Code Sourcery to support; // static code calling PIC code (CPIC). For O32 and N32 this means we have; // several combinations of PIC/static and abicalls. Pure static, static; // with the CPIC extension, and pure PIC code.; // At final link time, O32 and N32 with CPIC will have another section; // added to the binary which contains the stub functions to perform; // any fixups required for PIC code.; // For N64, the situation is more regular: code can either be static; // (non-abicalls) or PIC (abicalls). GCC has traditionally picked PIC code; // code for N64. Since Clang has already built the relocation model portion; // of the commandline, we pick add +noabicalls feature in the N64 static; // case.; // The is another case to be accounted for: -msym32, which enforces that all; // symbols have 32 bits in size. In this case, N64 can in theory use CPIC; // but it is unsupported.; // The combinations for N64 are:; // a) Static without abicalls and 64bit symbols.; // b) Static with abicalls and 32bit symbols.; // c) PIC with abicalls and 64bit symbols.; // For case (a) we need to add +noabicalls for N64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:147,Deployability,Release,Release,147,"// Strictly speaking, mips32r2 and mips64r2 do not conform to the; // IEEE754-2008 standard. Support for this standard was first introduced; // in Release 3. However, other compilers have traditionally allowed it; // for Release 2 so we should do the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:221,Deployability,Release,Release,221,"// Strictly speaking, mips32r2 and mips64r2 do not conform to the; // IEEE754-2008 standard. Support for this standard was first introduced; // in Release 3. However, other compilers have traditionally allowed it; // for Release 2 so we should do the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:18,Safety,hazard,hazard,18,// Supporting the hazard barrier method of dealing with indirect; // jumps requires MIPSR2 support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp:31,Energy Efficiency,Power,PowerPC,31,/// Get the (LLVM) name of the PowerPC cpu we are tuning for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp:31,Energy Efficiency,Power,PowerPC,31,/// Get the (LLVM) name of the PowerPC cpu we are targeting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:23,Availability,error,error,23,// Returns false if an error is diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:18,Security,access,access,18,"// -mno-unaligned-access is default, unless -munaligned-access is specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:56,Security,access,access,56,"// -mno-unaligned-access is default, unless -munaligned-access is specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:80,Modifiability,config,configured,80,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:168,Modifiability,config,config,168,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:464,Modifiability,config,config,464,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:9,Testability,log,logic,9,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:121,Testability,log,logic,121,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:210,Testability,log,logic,210,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:242,Testability,log,logic,242,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:455,Testability,log,logic,455,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:677,Testability,log,logic,677,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:720,Testability,log,logic,720,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:688,Usability,clear,clear,688,"// GCC's logic around choosing a default `-mabi=` is complex. If GCC is not; // configured using `--with-abi=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-abi=`; // 2. A default based on `--with-arch=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // In order to make chosing logic more clear, Clang uses the following logic,; // in order:; // 1. Explicit choices using `-mabi=`; // 2. A default based on the architecture as determined by getRISCVArch; // 3. Choose a default based on the triple; // 1. If `-mabi=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:18,Availability,error,error,18,"// Ignore parsing error, just go 3rd step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:81,Modifiability,config,configured,81,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:170,Modifiability,config,config,170,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:651,Modifiability,config,config,651,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:9,Testability,log,logic,9,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:123,Testability,log,logic,123,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:212,Testability,log,logic,212,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:429,Testability,log,logic,429,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:642,Testability,log,logic,642,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:864,Testability,log,logic,864,"// GCC's logic around choosing a default `-march=` is complex. If GCC is not; // configured using `--with-arch=`, then the logic for the default choice is; // defined in config.gcc. This function is based on the logic in GCC 9.2.0. We; // deviate from GCC's default on additional `-mcpu` option (GCC does not; // support `-mcpu`) and baremetal targets (UnknownOS) where neither `-march`; // nor `-mabi` is specified.; //; // The logic used in GCC 9.2.0 is the following, in order:; // 1. Explicit choices using `--with-arch=`; // 2. A default based on `--with-abi=`, if provided; // 3. A default based on the target triple's arch; //; // The logic in config.gcc is a little circular but it is not inconsistent.; //; // Clang does not have `--with-arch=` or `--with-abi=`, so we use `-march=`; // and `-mabi=` respectively instead.; //; // Clang uses the following logic, in order:; // 1. Explicit choices using `-march=`; // 2. Based on `-mcpu` if the target CPU has a default ISA string; // 3. A default based on `-mabi`, if provided; // 4. A default based on the target triple's arch; //; // Clang does not yet support MULTILIB_REUSE, so we use `rv{XLEN}imafdc`; // instead of `rv{XLEN}gc` though they are (currently) equivalent.; // 1. If `-march=` is specified, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:48,Safety,detect,detection,48,// Select the default CPU if none was given (or detection failed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:8,Integrability,rout,routine,8,// This routine is only handling x86 targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:97,Safety,detect,detect,97,// Translate the high level `-mretpoline` flag to the specific target feature; // flags. We also detect if the user asked for retpoline external thunks but; // failed to ask for retpolines themselves (through any of the different; // flags). This is a bit hacky but keeps existing usages working. We should; // consider deprecating this and instead warn if the user requests external; // retpoline thunks and *doesn't* request some form of retpolines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:23,Performance,load,load,23,"// On x86, speculative load hardening relies on at least using retpolines; // for indirect calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:95,Availability,error,error,95,// FIXME: Add a warning about failing to specify `-mretpoline` and; // eventually switch to an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:3,Performance,load,load,3,// load hardening implies CFI protection,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/Commit.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/Commit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/Commit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/EditedSource.cpp:17,Modifiability,extend,extend,17,// Do not try to extend the removal if we're at the end of the buffer already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/EditedSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/EditedSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:9,Modifiability,Rewrite,RewriteObjCFoundationAPI,9,"//===--- RewriteObjCFoundationAPI.cpp - Foundation API Rewriter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrites legacy method calls to modern syntax.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:55,Modifiability,Rewrite,Rewriter,55,"//===--- RewriteObjCFoundationAPI.cpp - Foundation API Rewriter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrites legacy method calls to modern syntax.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:383,Modifiability,Rewrite,Rewrites,383,"//===--- RewriteObjCFoundationAPI.cpp - Foundation API Rewriter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrites legacy method calls to modern syntax.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:56,Integrability,message,messages,56,"// When in ARC mode we also convert ""[[.. alloc] init]"" messages to literals,; // since the change from +1 to +0 will be handled fine by ARC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteObjCRedundantCallWithLiteral,85,//===----------------------------------------------------------------------===//; // rewriteObjCRedundantCallWithLiteral.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:650,Integrability,interface,interface,650,"//===----------------------------------------------------------------------===//; // rewriteToObjCSubscriptSyntax.; //===----------------------------------------------------------------------===//; /// Check for classes that accept 'objectForKey:' (or the other selectors; /// that the migrator handles) but return their instances as 'id', resulting; /// in the compiler resolving 'objectForKey:' as the method from NSDictionary.; ///; /// When checking if we can convert to subscripting syntax, check whether; /// the receiver is a result of a class method from a hardcoded list of; /// such classes. In such a case return the specific class as the interface; /// of the receiver.; ///; /// FIXME: Remove this when these classes start using 'instancetype'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToObjCSubscriptSyntax,85,"//===----------------------------------------------------------------------===//; // rewriteToObjCSubscriptSyntax.; //===----------------------------------------------------------------------===//; /// Check for classes that accept 'objectForKey:' (or the other selectors; /// that the migrator handles) but return their instances as 'id', resulting; /// in the compiler resolving 'objectForKey:' as the method from NSDictionary.; ///; /// When checking if we can convert to subscripting syntax, check whether; /// the receiver is a result of a class method from a hardcoded list of; /// such classes. In such a case return the specific class as the interface; /// of the receiver.; ///; /// FIXME: Remove this when these classes start using 'instancetype'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:38,Integrability,message,message,38,// ...and it is the result of a class message...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:96,Integrability,interface,interface,96,"// ...and the receiving class is NSMapTable or NSLocale, return that; // class as the receiving interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToObjCLiteralSyntax,85,//===----------------------------------------------------------------------===//; // rewriteToObjCLiteralSyntax.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:34,Integrability,message,message,34,"/// Returns true if the immediate message arguments of \c Msg should not; /// be rewritten because it will interfere with the rewrite of the parent; /// message expression. e.g.; /// \code; /// [NSDictionary dictionaryWithObjects:; /// [NSArray arrayWithObjects:@""1"", @""2"", nil]; /// forKeys:[NSArray arrayWithObjects:@""A"", @""B"", nil]];; /// \endcode; /// It will return true for this because we are going to rewrite this directly; /// to a dictionary literal without any array literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:153,Integrability,message,message,153,"/// Returns true if the immediate message arguments of \c Msg should not; /// be rewritten because it will interfere with the rewrite of the parent; /// message expression. e.g.; /// \code; /// [NSDictionary dictionaryWithObjects:; /// [NSArray arrayWithObjects:@""1"", @""2"", nil]; /// forKeys:[NSArray arrayWithObjects:@""A"", @""B"", nil]];; /// \endcode; /// It will return true for this because we are going to rewrite this directly; /// to a dictionary literal without any array literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:126,Modifiability,rewrite,rewrite,126,"/// Returns true if the immediate message arguments of \c Msg should not; /// be rewritten because it will interfere with the rewrite of the parent; /// message expression. e.g.; /// \code; /// [NSDictionary dictionaryWithObjects:; /// [NSArray arrayWithObjects:@""1"", @""2"", nil]; /// forKeys:[NSArray arrayWithObjects:@""A"", @""B"", nil]];; /// \endcode; /// It will return true for this because we are going to rewrite this directly; /// to a dictionary literal without any array literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:409,Modifiability,rewrite,rewrite,409,"/// Returns true if the immediate message arguments of \c Msg should not; /// be rewritten because it will interfere with the rewrite of the parent; /// message expression. e.g.; /// \code; /// [NSDictionary dictionaryWithObjects:; /// [NSArray arrayWithObjects:@""1"", @""2"", nil]; /// forKeys:[NSArray arrayWithObjects:@""A"", @""B"", nil]];; /// \endcode; /// It will return true for this because we are going to rewrite this directly; /// to a dictionary literal without any array literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToArrayLiteral,85,//===----------------------------------------------------------------------===//; // rewriteToArrayLiteral.; //===----------------------------------------------------------------------===//; /// Adds an explicit cast to 'id' if the type is not objc object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:233,Integrability,message,message,233,"//===----------------------------------------------------------------------===//; // rewriteToDictionaryLiteral.; //===----------------------------------------------------------------------===//; /// If \c Msg is an NSArray creation message or literal, this gets the; /// objects that were used to create it.; /// \returns true if it is an NSArray and we got objects, or false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToDictionaryLiteral,85,"//===----------------------------------------------------------------------===//; // rewriteToDictionaryLiteral.; //===----------------------------------------------------------------------===//; /// If \c Msg is an NSArray creation message or literal, this gets the; /// objects that were used to create it.; /// \returns true if it is an NSArray and we got objects, or false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToNumberLiteral,85,//===----------------------------------------------------------------------===//; // rewriteToNumberLiteral.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:56,Modifiability,rewrite,rewrite,56,"// Only integer and floating literals, otherwise try to rewrite to boxed; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:89,Availability,avail,available,89,// FIXME: Make determination of operator precedence more general and; // make it broadly available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToNumericBoxedExpression,85,//===----------------------------------------------------------------------===//; // rewriteToNumericBoxedExpression.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp:85,Modifiability,rewrite,rewriteToStringBoxedExpression,85,//===----------------------------------------------------------------------===//; // rewriteToStringBoxedExpression.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Edit/RewriteObjCFoundationAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate memory and copy if the string has already been stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp:11,Availability,avail,availability,11,// Collect availability attributes from all redeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/AvailabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:3,Safety,avoid,avoid,3,// avoid extra trailing spaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:128,Integrability,wrap,wrapped,128,"// If the type is a typedefed type, get the underlying TypedefNameDecl for a; // direct reference to the typedef instead of the wrapped type.; // 'id' type is a typedef for an ObjCObjectPointerType; // we treat it as a typedef",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:6,Integrability,protocol,protocol,6,// id<protocol> is an qualified id type; // id<protocol>* is not an qualified id type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:47,Integrability,protocol,protocol,47,// id<protocol> is an qualified id type; // id<protocol>* is not an qualified id type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:43,Modifiability,variab,variable,43,// Declaration fragments of an array-typed variable have two parts:; // 1. the element type of the array that appears before the variable name;; // 2. array brackets `[(0-9)?]` that appear after the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:129,Modifiability,variab,variable,129,// Declaration fragments of an array-typed variable have two parts:; // 1. the element type of the array that appears before the variable name;; // 2. array brackets `[(0-9)?]` that appear after the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:199,Modifiability,variab,variable,199,// Declaration fragments of an array-typed variable have two parts:; // 1. the element type of the array that appears before the variable name;; // 2. array brackets `[(0-9)?]` that appear after the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:50,Energy Efficiency,reduce,reduce,50,"// Everything we care about has been handled now, reduce to the canonical; // unqualified base type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:41,Integrability,interface,interface,41,"// If the base type is a TagType (struct/interface/union/class/enum), let's; // get the underlying Decl for better names and USRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:65,Modifiability,variab,variable,65,// Capture potential fragments that needs to be placed after the variable name; // ```; // int nums[5];; // char (*ptr_to_array)[6];; // ```,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:49,Integrability,inject,injecting,49,// the templated records will be resposbible for injecting their templates,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:49,Security,inject,injecting,49,// the templated records will be resposbible for injecting their templates,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:37,Integrability,interface,interface,37,// Build the base of the Objective-C interface declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:13,Modifiability,inherit,inheritance,13,// Build the inheritance part of the declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:15,Integrability,protocol,protocol,15,// Build basic protocol declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:11,Integrability,protocol,protocol,11,"// If this protocol conforms to other protocols, build the conformance list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:38,Integrability,protocol,protocols,38,"// If this protocol conforms to other protocols, build the conformance list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:48,Integrability,protocol,protocol,48,// Add a leading comma if this is not the first protocol rendered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:10,Energy Efficiency,reduce,reduce,10,// Try to reduce the include name the same way we tried to include it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:41,Safety,avoid,avoid,41,// Record that the file was not found to avoid future reverse lookup for; // the same file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:108,Security,expose,exposed,108,// If a macro gets undefined at some point during preprocessing of the inputs; // it means that it isn't an exposed API and we should therefore not add a; // macro definition for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:146,Modifiability,config,configurable,146,// Setup a SymbolGraphSerializer to write out collected API information in; // the Symbol Graph format.; // FIXME: Make the kind of APISerializer configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:10,Integrability,wrap,wrapped,10,// Invoke wrapped action's method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Integrability,inject,inject,23,/// Helper function to inject a JSON object \p Obj into another object \p Paren; /// at position \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Security,inject,inject,23,/// Helper function to inject a JSON object \p Obj into another object \p Paren; /// at position \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Integrability,inject,inject,23,/// Helper function to inject a StringRef \p String into an object \p Paren at; /// position \p Key,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Security,inject,inject,23,/// Helper function to inject a StringRef \p String into an object \p Paren at; /// position \p Key,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Integrability,inject,inject,23,/// Helper function to inject a JSON array \p Array into object \p Paren at; /// position \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:23,Security,inject,inject,23,/// Helper function to inject a JSON array \p Array into object \p Paren at; /// position \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:205,Deployability,patch,patch,205,"/// Serialize a \c VersionTuple \p V with the Symbol Graph semantic version; /// format.; ///; /// A semantic version object contains three numeric fields, representing the; /// \c major, \c minor, and \c patch parts of the version tuple.; /// For example version tuple 1.0.3 is serialized as:; /// \code; /// {; /// ""major"" : 1,; /// ""minor"" : 0,; /// ""patch"" : 3; /// }; /// \endcode; ///; /// \returns \c std::nullopt if the version \p V is empty, or an \c Object; /// containing the semantic version representation of \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:354,Deployability,patch,patch,354,"/// Serialize a \c VersionTuple \p V with the Symbol Graph semantic version; /// format.; ///; /// A semantic version object contains three numeric fields, representing the; /// \c major, \c minor, and \c patch parts of the version tuple.; /// For example version tuple 1.0.3 is serialized as:; /// \code; /// {; /// ""major"" : 1,; /// ""minor"" : 0,; /// ""patch"" : 3; /// }; /// \endcode; ///; /// \returns \c std::nullopt if the version \p V is empty, or an \c Object; /// containing the semantic version representation of \p V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:18,Availability,avail,availability,18,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:65,Availability,Avail,Availability,65,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:212,Availability,Avail,Availability,212,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:473,Availability,avail,availability,473,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:558,Availability,avail,availability,558,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:37,Integrability,interface,interface,37,/// Get the language name string for interface language references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:188,Integrability,interface,interface,188,"/// Serialize the identifier object as specified by the Symbol Graph format.; ///; /// The identifier property of a symbol contains the USR for precise and unique; /// references, and the interface language name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:248,Usability,simpl,simple,248,"/// Serialize the \c names field of a symbol as specified by the Symbol Graph; /// format.; ///; /// The Symbol Graph names field contains multiple representations of a symbol; /// that can be used for different applications:; /// - \c title : The simple declared name of the symbol;; /// - \c subHeading : An array of declaration fragments that provides tags,; /// and potentially more tokens (for example the \c +/- symbol for; /// Objective-C methods). Can be used as sub-headings for documentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:120,Integrability,interface,interface,120,// If the parent is a category extended from internal module then we need to; // pretend this belongs to the associated interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:31,Modifiability,extend,extended,31,// If the parent is a category extended from internal module then we need to; // pretend this belongs to the associated interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:34,Integrability,Protocol,Protocol,34,// Record that Record conforms to Protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:31,Integrability,interface,interface,31,"// If Record is an Objective-C interface record and it has a super class,; // record that Record is inherited from SuperClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:100,Modifiability,inherit,inherited,100,"// If Record is an Objective-C interface record and it has a super class,; // record that Record is inherited from SuperClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:38,Integrability,interface,interface,38,// Members of categories extending an interface are serialized as members of; // the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:85,Integrability,interface,interface,85,// Members of categories extending an interface are serialized as members of; // the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:25,Modifiability,extend,extending,25,// Members of categories extending an interface are serialized as members of; // the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:15,Integrability,protocol,protocols,15,// Surface the protocols of the category to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:48,Integrability,interface,interface,48,// Surface the protocols of the category to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:15,Integrability,protocol,protocols,15,// Surface the protocols of the category to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:48,Integrability,interface,interface,48,// Surface the protocols of the category to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:168,Safety,avoid,avoid,168,"// In JavaScript, some @tags can be followed by {, and machinery that parses; // these comments will fail to understand the comment if followed by a line; // break. So avoid ever breaking before a {.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:163,Safety,Avoid,Avoid,163,"// If a line-comment ends with `\`, the next line continues the comment,; // whether or not it starts with `//`. This is confusing and triggers; // -Wcomment.; // Avoid introducing multiline comments by not allowing a break right; // after '\'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Safety,Avoid,Avoid,3,// Avoid ever breaking before a @tag or a { in JavaScript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Energy Efficiency,adapt,adaptStartOfLine,3,"// adaptStartOfLine will break after lines starting with /** if the comment; // is broken anywhere. Avoid emitting this break twice here.; // Example: in /** longtextcomesherethatbreaks */ (with ColumnLimit 20) will; // insert a break after /**, so this code must not insert the same break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Modifiability,adapt,adaptStartOfLine,3,"// adaptStartOfLine will break after lines starting with /** if the comment; // is broken anywhere. Avoid emitting this break twice here.; // Example: in /** longtextcomesherethatbreaks */ (with ColumnLimit 20) will; // insert a break after /**, so this code must not insert the same break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:100,Safety,Avoid,Avoid,100,"// adaptStartOfLine will break after lines starting with /** if the comment; // is broken anywhere. Avoid emitting this break twice here.; // Example: in /** longtextcomesherethatbreaks */ (with ColumnLimit 20) will; // insert a break after /**, so this code must not insert the same break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:10,Energy Efficiency,Reduce,Reduce,10,// FIXME: Reduce unit test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:22,Testability,test,test,22,// FIXME: Reduce unit test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:101,Energy Efficiency,allocate,allocated,101,// Find the replacement text for inserting braces and quotes and line breaks.; // We don't create an allocated string concatenated from parts here because it; // has to outlive the BreakableStringliteral object. The brace replacements; // include a quote so that WhitespaceManager can tell it apart from whitespace; // replacements between the string and surrounding tokens.; // The option is not implemented in JavaScript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:82,Integrability,wrap,wrapped,82,"// In Verilog, all strings are quoted by double quotes, joined by commas,; // and wrapped in braces. The comma is always before the newline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:43,Integrability,depend,depending,43,// The plus sign may need to be unindented depending on the style.; // FIXME: Add support for DontAlign.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:70,Safety,avoid,avoid,70,"// Numbered lists may also start with a number followed by '.'; // To avoid issues if a line starts with a number which is actually the end; // of a previous line, we only consider numbers with up to 2 digits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Usability,Simpl,Simple,3,// Simple heuristic for what to reflow: content should contain at least two; // characters and either the first or second character must be; // non-punctuation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:27,Safety,safe,safe,27,"// Note that this is UTF-8 safe, since if isPunctuation(Content[0]) is; // true, then the first code point must be 1 byte long.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:82,Availability,avail,available,82,"// Comments for which FirstInLine is false can start on arbitrary column,; // and available horizontal space can be too small to align consecutive; // lines with the first one.; // FIXME: We could, probably, align them to current indentation level, but; // now we just wrap them without stars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:269,Integrability,wrap,wrap,269,"// Comments for which FirstInLine is false can start on arbitrary column,; // and available horizontal space can be too small to align consecutive; // lines with the first one.; // FIXME: We could, probably, align them to current indentation level, but; // now we just wrap them without stars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Safety,Detect,Detect,3,// Detect a multiline jsdoc comment and set DelimitersOnNewline in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Safety,Detect,Detect,3,"// Detect a long single-line comment, like:; // /** long long long */; // Below, '2' is the width of '*/'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:54,Energy Efficiency,adapt,adapt,54,"// For other empty lines, if we do have a decoration, adapt it to not; // contain a trailing whitespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:54,Modifiability,adapt,adapt,54,"// For other empty lines, if we do have a decoration, adapt it to not; // contain a trailing whitespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:99,Energy Efficiency,adapt,adapt,99,"// If this is the first line of a token, we need to inform Whitespace Manager; // about it: either adapt the whitespace range preceding it, or mark it as an; // untouchable token.; // This happens for instance here:; // // line 1 \; // // line 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:99,Modifiability,adapt,adapt,99,"// If this is the first line of a token, we need to inform Whitespace Manager; // about it: either adapt the whitespace range preceding it, or mark it as an; // untouchable token.; // This happens for instance here:; // // line 1 \; // // line 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:251,Deployability,update,update,251,"// This is the first line for the current token, but no reflow with the; // previous token is necessary. However, we still may need to adjust the; // start column. Note that ContentColumn[LineIndex] is the expected; // content column after a possible update to the prefix, hence the prefix; // length change is included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:569,Testability,log,logic,569,"//===--- BreakableToken.h - Format C++ code ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares BreakableToken, BreakableStringLiteral, BreakableComment,; /// BreakableBlockComment and BreakableLineCommentSection classes, that contain; /// token type-specific logic to break long lines in tokens and reflow content; /// between tokens.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:836,Energy Efficiency,adapt,adapt,836,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:2328,Energy Efficiency,adapt,adaptStartOfLine,2328,"e concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaking occurs:; /// - getReflowSplit, for finding a split such that the content preceding it; /// needs to be specially reflown,; /// - reflow, for executing the split using a whitespace manager,; /// - introducesBreakBefore, for checking if reformatting the beginning; /// of the content introduces a line break before it,; /// - adaptStartOfLine, for executing the reflow using a whitespace; /// manager.; ///; /// For tokens that require the whitespace after the last line to be; /// reformatted, for example in multiline jsdoc comments that require the; /// trailing '*/' to be on a line of itself, there are analogous operations; /// that might be executed after the last line has been reformatted:; /// - getSplitAfterLastLine, for finding a split after the last line that needs; /// to be reflown,; /// - replaceWhitespaceAfterLastLine, for executing the reflow using a; /// whitespace manager.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:836,Modifiability,adapt,adapt,836,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:2328,Modifiability,adapt,adaptStartOfLine,2328,"e concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaking occurs:; /// - getReflowSplit, for finding a split such that the content preceding it; /// needs to be specially reflown,; /// - reflow, for executing the split using a whitespace manager,; /// - introducesBreakBefore, for checking if reformatting the beginning; /// of the content introduces a line break before it,; /// - adaptStartOfLine, for executing the reflow using a whitespace; /// manager.; ///; /// For tokens that require the whitespace after the last line to be; /// reformatted, for example in multiline jsdoc comments that require the; /// trailing '*/' to be on a line of itself, there are analogous operations; /// that might be executed after the last line has been reformatted:; /// - getSplitAfterLastLine, for finding a split after the last line that needs; /// to be reflown,; /// - replaceWhitespaceAfterLastLine, for executing the reflow using a; /// whitespace manager.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:110,Safety,avoid,avoid,110,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:227,Testability,log,logical,227,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:353,Testability,log,logical,353,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:449,Testability,log,logical,449,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:625,Testability,log,logical,625,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:736,Testability,log,logical,736,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:201,Energy Efficiency,reduce,reduced,201,"/// Returns the number of columns needed to format; /// \p RemainingTokenColumns, assuming that Split is within the range measured; /// by \p RemainingTokenColumns, and that the whitespace in Split is reduced; /// to a single space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:119,Performance,perform,performing,119,/// Replaces the whitespace from \p SplitAfterLastLine on the last line; /// after the last line has been formatted by performing a reformatting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:4,Deployability,Update,Updates,4,/// Updates the next token of \p State to the next token after this; /// one. This can be used when this token manages a set of underlying tokens; /// as a unit and is responsible for the formatting of the them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:77,Integrability,wrap,wrapping,77,/// Adds replacements that are needed when the token is broken. Such as; /// wrapping a JavaScript string in parentheses after it gets broken with plus; /// signs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:86,Deployability,Update,Updates,86,"// Rearranges the whitespace between Lines[LineIndex-1] and Lines[LineIndex].; //; // Updates Content[LineIndex-1] and Content[LineIndex] by stripping off; // leading and trailing whitespace.; //; // Sets ContentColumn to the intended column in which the text at; // Lines[LineIndex] starts (note that the decoration, if present, is not; // considered part of the text).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:61,Integrability,wrap,wrapped,61,"// Returns true if a TT_SelectorName should be indented when wrapped,; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:1516,Availability,down,downwards,1516,"initializers and text proto; // messages like `key: < ... >` are an exception: a break is possible; // before a closing brace R if a break was inserted after the corresponding; // opening brace. The information about whether or not a break is needed; // before a closing brace R is stored in the ParenState field; // S.BreakBeforeClosingBrace where S is the state that R closes.; //; // In order to decide whether there can be a break before encountered right; // braces, this implementation iterates over the sequence of tokens and over; // the paren stack in lockstep, keeping track of the stack level which visited; // right braces correspond to in MatchingStackIndex.; //; // For example, consider:; // L. <- line number; // 1. {; // 2. {1},; // 3. {2},; // 4. {{3}}}; // ^ where we call this method with this token.; // The paren stack at this point contains 3 brace levels:; // 0. { at line 1, BreakBeforeClosingBrace: true; // 1. first { at line 4, BreakBeforeClosingBrace: false; // 2. second { at line 4, BreakBeforeClosingBrace: false,; // where there might be fake parens levels in-between these levels.; // The algorithm will start at the first } on line 4, which is the matching; // brace of the initial left brace and at level 2 of the stack. Then,; // examining BreakBeforeClosingBrace: false at level 2, it will continue to; // the second } on line 4, and will traverse the stack downwards until it; // finds the matching { on level 1. Then, examining BreakBeforeClosingBrace:; // false at level 1, it will continue to the third } on line 4 and will; // traverse the stack downwards until it finds the matching { on level 0.; // Then, examining BreakBeforeClosingBrace: true at level 0, the algorithm; // will stop and will use the second } on line 4 to determine the length to; // return, as in this example the range will include the tokens: {3}}; //; // The algorithm will only traverse the stack if it encounters braces, array; // initializer squares or text proto angle brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:1709,Availability,down,downwards,1709,"initializers and text proto; // messages like `key: < ... >` are an exception: a break is possible; // before a closing brace R if a break was inserted after the corresponding; // opening brace. The information about whether or not a break is needed; // before a closing brace R is stored in the ParenState field; // S.BreakBeforeClosingBrace where S is the state that R closes.; //; // In order to decide whether there can be a break before encountered right; // braces, this implementation iterates over the sequence of tokens and over; // the paren stack in lockstep, keeping track of the stack level which visited; // right braces correspond to in MatchingStackIndex.; //; // For example, consider:; // L. <- line number; // 1. {; // 2. {1},; // 3. {2},; // 4. {{3}}}; // ^ where we call this method with this token.; // The paren stack at this point contains 3 brace levels:; // 0. { at line 1, BreakBeforeClosingBrace: true; // 1. first { at line 4, BreakBeforeClosingBrace: false; // 2. second { at line 4, BreakBeforeClosingBrace: false,; // where there might be fake parens levels in-between these levels.; // The algorithm will start at the first } on line 4, which is the matching; // brace of the initial left brace and at level 2 of the stack. Then,; // examining BreakBeforeClosingBrace: false at level 2, it will continue to; // the second } on line 4, and will traverse the stack downwards until it; // finds the matching { on level 1. Then, examining BreakBeforeClosingBrace:; // false at level 1, it will continue to the third } on line 4 and will; // traverse the stack downwards until it finds the matching { on level 0.; // Then, examining BreakBeforeClosingBrace: true at level 0, the algorithm; // will stop and will use the second } on line 4 to determine the length to; // return, as in this example the range will include the tokens: {3}}; //; // The algorithm will only traverse the stack if it encounters braces, array; // initializer squares or text proto angle brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:152,Integrability,message,messages,152,"// Normally whether or not a break before T is possible is calculated and; // stored in T.CanBreakBefore. Braces, array initializers and text proto; // messages like `key: < ... >` are an exception: a break is possible; // before a closing brace R if a break was inserted after the corresponding; // opening brace. The information about whether or not a break is needed; // before a closing brace R is stored in the ParenState field; // S.BreakBeforeClosingBrace where S is the state that R closes.; //; // In order to decide whether there can be a break before encountered right; // braces, this implementation iterates over the sequence of tokens and over; // the paren stack in lockstep, keeping track of the stack level which visited; // right braces correspond to in MatchingStackIndex.; //; // For example, consider:; // L. <- line number; // 1. {; // 2. {1},; // 3. {2},; // 4. {{3}}}; // ^ where we call this method with this token.; // The paren stack at this point contains 3 brace levels:; // 0. { at line 1, BreakBeforeClosingBrace: true; // 1. first { at line 4, BreakBeforeClosingBrace: false; // 2. second { at line 4, BreakBeforeClosingBrace: false,; // where there might be fake parens levels in-between these levels.; // The algorithm will start at the first } on line 4, which is the matching; // brace of the initial left brace and at level 2 of the stack. Then,; // examining BreakBeforeClosingBrace: false at level 2, it will continue to; // the second } on line 4, and will traverse the stack downwards until it; // finds the matching { on level 1. Then, examining BreakBeforeClosingBrace:; // false at level 1, it will continue to the third } on line 4 and will; // traverse the stack downwards until it finds the matching { on level 0.; // Then, examining BreakBeforeClosingBrace: true at level 0, the algorithm; // will stop and will use the second } on line 4 to determine the length to; // return, as in this example the range will include the tokens: {3}}; //; // The algo",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:23,Availability,down,downwards,23,"// Traverses the stack downwards, looking for the level to which LBrace; // corresponds. Returns either a pointer to the matching level or nullptr if; // LParen is not found in the initial portion of the stack up to; // MatchingStackIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:106,Security,hash,hash,106,"// With preprocessor directive indentation, the line starts on column 0; // since it's indented after the hash, but FirstIndent is set to the; // preprocessor indent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:2,Safety,Avoid,AvoidBinPacking,2,/*AvoidBinPacking=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:125,Integrability,wrap,wrapping,125,// Allow breaking opening brace of lambdas (when passed as function; // arguments) to a new line when BeforeLambdaBody brace wrapping is; // enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Safety,Avoid,Avoid,3,// Avoid producing inconsistent states by requiring breaks where they are not; // permitted for C# generic type constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:223,Integrability,wrap,wrapped,223,// FIXME: This is a temporary workaround for the case where clang-format; // sets BreakBeforeParameter to avoid bin packing and this creates a; // completely unnecessary line break after a template type that isn't; // line-wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:106,Safety,avoid,avoid,106,// FIXME: This is a temporary workaround for the case where clang-format; // sets BreakBeforeParameter to avoid bin packing and this creates a; // completely unnecessary line break after a template type that isn't; // line-wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:59,Integrability,wrap,wrap,59,"// If the template declaration spans multiple lines, force wrap before the; // function/class declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:101,Integrability,wrap,wrapping,101,// Using CanBreakBefore here and below takes care of the decision whether the; // current style uses wrapping before or after operators for the given; // operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:53,Integrability,depend,depend,53,"// The following could be precomputed as they do not depend on the state.; // However, as they should take effect only if the UnwrappedLine does not fit; // into the ColumnLimit, they are checked here in the ContinuationIndenter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:46,Modifiability,variab,variable,46,// Move over * and & if they are bound to the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:44,Security,hash,hash,44,// Indent preprocessor directives after the hash if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:172,Safety,avoid,avoid,172,"// For preprocessor indent with tabs, State.Column will be 1 because of the; // hash. This causes second-level indents onward to have an extra space; // after the tabs. We avoid this misalignment by subtracting 1 from the; // column value passed to replaceWhitespace().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:80,Security,hash,hash,80,"// For preprocessor indent with tabs, State.Column will be 1 because of the; // hash. This causes second-level indents onward to have an extra space; // after the tabs. We avoid this misalignment by subtracting 1 from the; // column value passed to replaceWhitespace().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:65,Modifiability,inherit,inheritance,65,"// If ""BreakBeforeInheritanceComma"" mode, don't break within the inheritance; // declaration unless there is multiple inheritance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:118,Modifiability,inherit,inheritance,118,"// If ""BreakBeforeInheritanceComma"" mode, don't break within the inheritance; // declaration unless there is multiple inheritance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:51,Integrability,wrap,wrapping,51,"// In ""AlwaysBreak"" or ""BlockIndent"" mode, enforce wrapping directly after the; // parenthesis by disallowing any further line breaks if there is no line; // break after the opening parenthesis. Don't break if it doesn't conserve; // columns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:21,Usability,simpl,simple,21,"// Don't do this for simple (no expressions) one-argument function calls; // as that feels like needlessly wasting whitespace, e.g.:; //; // caaaaaaaaaaaall(; // caaaaaaaaaaaall(; // caaaaaaaaaaaall(; // caaaaaaaaaaaaaaaaaaaaaaall(aaaaaaaaaaaaaa, aaaaaaaaa))));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:58,Modifiability,config,configured,58,"// Align following lines within parentheses / brackets if configured.; // Note: This doesn't apply to macro expansion lines, which are MACRO( , , ); // with args as children of the '(' and ',' tokens. It does not make sense to; // align the commas with the opening paren.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:65,Usability,simpl,simple,65,// Indent relative to the RHS of the expression unless this is a simple; // assignment without binary expression on the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:99,Safety,avoid,avoids,99,"// If a function has a trailing call, indent all parameters from the; // opening parenthesis. This avoids confusing indents like:; // OuterFunction(InnerFunctionCall( // break; // ParameterToInnerFunction)) // break; // .SecondInnerFunctionCall();",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:161,Safety,avoid,avoid,161,"// Breaking before the first ""<<"" is generally not desirable if the LHS is; // short. Also always add the penalty if the LHS is split over multiple lines; // to avoid unnecessary line breaks that just work around this penalty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:269,Integrability,wrap,wrapping,269,"// Indent nested blocks relative to this column, unless in a very specific; // JavaScript special case where:; //; // var loooooong_name =; // function() {; // // code; // }; //; // is common and should be formatted like a free-standing function. The same; // goes for wrapping before the lambda return type arrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:144,Testability,log,logic,144,"// lambdas and arrow functions are expressions, thus their r_brace is not; // on its own line, and thus not covered by UnwrappedLineFormatter's logic; // about removing empty lines on closing blocks. Special case them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:90,Safety,avoid,avoid,90,// Any break on this level means that the parent level has been broken; // and we need to avoid bin packing there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:167,Availability,down,down,167,"// If the first character on the new line is a lambda's closing brace, the; // stack still contains that lambda's parenthesis. As such, we need to; // recurse further down the stack than usual to find the parenthesis level; // containing the lambda, which is where we want to set; // BreakBeforeParameter.; //; // We specifically special case ""OuterScope""-formatted lambdas here; // because, when using that setting, breaking before the parameter; // directly following the lambda is particularly unsightly. However, when; // ""OuterScope"" is not set, the logic to find the parent parenthesis level; // still appears to be sometimes incorrect. It has not been fixed yet; // because it would lead to significant changes in existing behaviour.; //; // TODO: fix the non-""OuterScope"" case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:555,Testability,log,logic,555,"// If the first character on the new line is a lambda's closing brace, the; // stack still contains that lambda's parenthesis. As such, we need to; // recurse further down the stack than usual to find the parenthesis level; // containing the lambda, which is where we want to set; // BreakBeforeParameter.; //; // We specifically special case ""OuterScope""-formatted lambdas here; // because, when using that setting, breaking before the parameter; // directly following the lambda is particularly unsightly. However, when; // ""OuterScope"" is not set, the logic to find the parent parenthesis level; // still appears to be sometimes incorrect. It has not been fixed yet; // because it would lead to significant changes in existing behaviour.; //; // TODO: fix the non-""OuterScope"" case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:19,Safety,Avoid,AvoidBinPacking,19,// Don't propagate AvoidBinPacking into subexpressions of arg/param lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:13,Modifiability,inherit,inherit,13,"// Generally inherit NoLineBreak from the current scope to nested scope.; // However, don't do this for non-empty nested blocks, dict literals and; // array literals as these follow different indentation rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:27,Integrability,message,message,27,"// Reevaluate whether ObjC message arguments fit into one line.; // If a receiver spans multiple lines, e.g.:; // [[object block:^{; // return 42;; // }] a:42 b:42];; // BreakBeforeParameter is calculated based on an incorrect assumption; // (it is checked whether the whole expression fits into one line without; // considering a line break inside a message receiver).; // We check whether arguments fit after receiver scope closer (into the same; // line).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:351,Integrability,message,message,351,"// Reevaluate whether ObjC message arguments fit into one line.; // If a receiver spans multiple lines, e.g.:; // [[object block:^{; // return 42;; // }] a:42 b:42];; // BreakBeforeParameter is calculated based on an incorrect assumption; // (it is checked whether the whole expression fits into one line without; // considering a line break inside a message receiver).; // We check whether arguments fit after receiver scope closer (into the same; // line).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:2,Safety,Avoid,AvoidBinPacking,2,/*AvoidBinPacking=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:9,Deployability,update,update,9,"// Don't update to the canonical delimiter 'deli' if ')deli""' occurs in the; // raw string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:102,Deployability,update,update,102,"// Don't break multi-line tokens other than block comments and raw string; // literals. Instead, just update the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:202,Safety,avoid,avoid,202,"// Don't break string literals inside preprocessor directives (except for; // #define directives, as their contents are stored in separate lines and; // are not affected by this check).; // This way we avoid breaking code with line directives and unknown; // preprocessor directives that contain long string literals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:57,Integrability,interface,interface,57,"// The ""DPI""/""DPI-C"" in SystemVerilog direct programming interface; // imports/exports cannot be split, e.g.; // `import ""DPI"" function foo();`; // FIXME: make this use same infra as C++ import checks",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:141,Energy Efficiency,reduce,reduce,141,"// FIXME: Handle whitespace between '_T', '(', '""...""', and ')'.; // FIXME: Store Prefix and Suffix (or PrefixLength and SuffixLength to; // reduce the overhead) for each FormatToken, which is a string, so that we; // don't run multiple checks here on the hot path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:77,Testability,log,logical,77,// Store whether we inserted a new line break at the end of the previous; // logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:91,Testability,log,logical,91,// Keep track of where we are in the token:; // Where we are in the content of the current logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:45,Testability,log,logical,45,// The number of columns left in the current logical line after TailOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Energy Efficiency,Adapt,Adapt,3,"// Adapt the start of the token, for example indent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Modifiability,Adapt,Adapt,3,"// Adapt the start of the token, for example indent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:26,Deployability,update,update,26,// No break opportunity - update the penalty and continue with the next; // logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:76,Testability,log,logical,76,// No break opportunity - update the penalty and continue with the next; // logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Deployability,Update,Update,3,"// Update the ContentIndent only if the current line was not reflown with; // the previous line, since in that case the previous line should still; // determine the ContentIndent. Also never intent the last line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:113,Energy Efficiency,Adapt,Adapt,113,"// As we did not continue breaking the line, RemainingTokenColumns is; // known to fit after ContentStartColumn. Adapt ContentStartColumn to; // the position at which we want to format the next line if we do; // actually reflow.; // When we reflow, we need to add a space between the end of the current; // line and the next line's start column.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:113,Modifiability,Adapt,Adapt,113,"// As we did not continue breaking the line, RemainingTokenColumns is; // known to fit after ContentStartColumn. Adapt ContentStartColumn to; // the position at which we want to format the next line if we do; // actually reflow.; // When we reflow, we need to add a space between the end of the current; // line and the next line's start column.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:45,Testability,log,logical,45,// Get the split that we need to reflow next logical line into the end; // of the current one; the split will include any leading whitespace of; // the next logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:157,Testability,log,logical,157,// Get the split that we need to reflow next logical line into the end; // of the current one; the split will include any leading whitespace of; // the next logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:94,Safety,safe,safely,94,"// If the rest of the next line fits into the current line below the; // column limit, we can safely reflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:170,Testability,log,logic,170,// Check whether the first split point gets us below the column; // limit. Note that we will execute this split below as part of; // the normal token breaking and reflow logic within the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:86,Testability,log,logical,86,"// If we didn't reflow into the next line, the only space to consider is; // the next logical line. Reset our state to match the start of the next; // line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Energy Efficiency,Adapt,Adapt,3,"// Adapt the start of the token, for example indent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Modifiability,Adapt,Adapt,3,"// Adapt the start of the token, for example indent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:150,Testability,log,logical,150,"// If we found a reflow split and have added a new break before the next; // line, we are going to remove the line break at the start of the next; // logical line. For example, here we'll add a new line break after; // 'text', and subsequently delete the line break between 'that' and; // 'reflows'.; // // some text that; // // reflows; // ->; // // some text; // // that reflows; // When adding the line break, we also added the penalty for it, so we; // need to subtract that penalty again when we remove the line break due; // to reflowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:142,Usability,clear,clearly,142,"// If we break the token inside a parameter list, we need to break before; // the next parameter on all levels, so that the next parameter is clearly; // visible. Line comments already introduce a break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:43,Deployability,update,updates,43,"/// Appends the next token to \p State and updates information; /// necessary for indentation.; ///; /// Puts the token on the current line if \p Newline is \c false and adds a; /// line break and necessary indentation otherwise.; ///; /// If \p DryRun is \c false, also creates and stores the required; /// \c Replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:91,Energy Efficiency,reduce,reduced,91,"/// Get the column limit for this line. This is the style's column; /// limit, potentially reduced for preprocessor definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Deployability,Update,Update,4,/// Update 'State' according to the next token's fake left parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Deployability,Update,Update,4,/// Update 'State' according to the next token's fake r_parens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Deployability,Update,Update,4,"/// Update 'State' according to the next token being one of ""(<{["".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Deployability,Update,Update,4,"/// Update 'State' according to the next token being one of "")>}]"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Deployability,Update,Update,4,/// Update 'State' with the next token opening a nested block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:42,Modifiability,config,configured,42,"/// If \p Current is a raw string that is configured to be reformatted,; /// return the style to be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:43,Deployability,update,updates,43,"/// Appends the next token to \p State and updates information; /// necessary for indentation.; ///; /// Puts the token on the current line.; ///; /// If \p DryRun is \c false, also creates and stores the required; /// \c Replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:43,Deployability,update,updates,43,"/// Appends the next token to \p State and updates information; /// necessary for indentation.; ///; /// Adds a line break and necessary indentation.; ///; /// If \p DryRun is \c false, also creates and stores the required; /// \c Replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:40,Integrability,wrap,wrap,40,/// Calculate the new column for a line wrap before the next token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:55,Integrability,wrap,wrapped,55,"/// If a block relative to this parenthesis level gets wrapped, indent; /// it this much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:28,Modifiability,variab,variable,28,/// The column of the first variable name in a variable declaration.; ///; /// Used to align further variables if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:47,Modifiability,variab,variable,47,/// The column of the first variable name in a variable declaration.; ///; /// Used to align further variables if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:101,Modifiability,variab,variables,101,/// The column of the first variable name in a variable declaration.; ///; /// Used to align further variables if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Safety,Avoid,Avoid,4,"/// Avoid bin packing, i.e. multiple parameters/elements on multiple; /// lines, in this context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:77,Safety,Avoid,AvoidBinPacking,77,/// Break after the next comma (or all the commas in this context if; /// \c AvoidBinPacking is \c true).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:55,Integrability,wrap,wrapped,55,/// True if the last binary operator on this level was wrapped to the; /// next line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:104,Integrability,wrap,wrapped,104,"/// The start of a nested block (e.g. lambda introducer in C++ or; /// ""function"" in JavaScript) is not wrapped to a new line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:42,Integrability,wrap,wrapped,42,/// \brief true if there conditionnal was wrapped on the first operator (the; /// question mark),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:42,Energy Efficiency,reduce,reduced,42,/// \brief Indicates the indent should be reduced by the length of the; /// operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:639,Safety,avoid,avoided,639,"/// Ignore the stack of \c ParenStates for state comparison.; ///; /// In long and deeply nested unwrapped lines, the current algorithm can; /// be insufficient for finding the best formatting with a reasonable amount; /// of time and memory. Setting this flag will effectively lead to the; /// algorithm not analyzing some combinations. However, these combinations; /// rarely contain the optimal solution: In short, accepting a higher; /// penalty early would need to lead to different values in the \c; /// ParenState stack (in an otherwise identical state) and these different; /// values would need to lead to a significant amount of avoided penalty; /// later.; ///; /// FIXME: Come up with a better algorithm instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicated replacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp:21,Deployability,continuous,continuously,21,// No empty line for continuously closing scopes. The token will be; // handled in another case if the line following is opening a; // definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp:29,Availability,Error,Error,29,"// The add method returns an Error instance which simulates program exit; // code through overloading boolean operator, thus false here indicates; // success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Encoding.h:4,Safety,Detect,Detects,4,"/// Detects encoding of the Text. If the Text can be decoded using UTF-8,; /// it is considered UTF8, otherwise we treat it as some 8-bit encoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Encoding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Encoding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:19,Modifiability,variab,variables,19,"// Initialize some variables used in the parsing. The using logic is at the; // end.; // For backward compatibility:; // The default value of ConstructorInitializerAllOnOneLineOrOnePerLine was; // false unless BasedOnStyle was Google or Chromium whereas that of; // AllowAllConstructorInitializersOnNextLine was always true, so the; // equivalent default value of PackConstructorInitializers is PCIS_NextLine; // for Google/Chromium or PCIS_BinPack otherwise. If the deprecated options; // had a non-default value while PackConstructorInitializers has a default; // value, set the latter to an equivalent non-default value if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:60,Testability,log,logic,60,"// Initialize some variables used in the parsing. The using logic is at the; // end.; // For backward compatibility:; // The default value of ConstructorInitializerAllOnOneLineOrOnePerLine was; // false unless BasedOnStyle was Google or Chromium whereas that of; // AllowAllConstructorInitializersOnNextLine was always true, so the; // equivalent default value of PackConstructorInitializers is PCIS_NextLine; // for Google/Chromium or PCIS_BinPack otherwise. If the deprecated options; // had a non-default value while PackConstructorInitializers has a default; // value, set the latter to an equivalent non-default value if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:16,Integrability,protocol,protocol,16,// This affects protocol buffer options specifications and text protos.; // Text protos are currently mostly formatted inside C++ raw string literals; // and often the current breaking behavior of string literals is not; // beneficial there. Investigate turning this on once proper string reflow; // has been implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:90,Safety,detect,detect,90,"// Disable include reordering across blocks in Chromium code.; // - clang-format tries to detect that foo.h is the ""main"" header for; // foo.cc and foo_unittest.cc via IncludeIsMainRegex. However, Chromium; // uses many other suffices (_win.cc, _mac.mm, _posix.cc, _browsertest.cc,; // _private.cc, _impl.cc etc) in different permutations; // (_win_browsertest.cc) so disable this until IncludeIsMainRegex has a; // better default for Chromium code.; // - The default for .cc and .mm files is different (r357695) for Google style; // for the same reason. The plan is to unify this again once the main; // header detection works for Google's ObjC code, but this hasn't happened; // yet. Since Chromium has some ObjC code, switching Chromium is blocked; // on that.; // - Finally, ""If include reordering is harmful, put things in different; // blocks to prevent it"" has been a recommendation for a long time that; // people are used to. We'll need a dev education push to change this to; // ""If include reordering is harmful, put things in a different block and; // _prepend that with a comment_ to prevent it"" before changing behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:612,Safety,detect,detection,612,"// Disable include reordering across blocks in Chromium code.; // - clang-format tries to detect that foo.h is the ""main"" header for; // foo.cc and foo_unittest.cc via IncludeIsMainRegex. However, Chromium; // uses many other suffices (_win.cc, _mac.mm, _posix.cc, _browsertest.cc,; // _private.cc, _impl.cc etc) in different permutations; // (_win_browsertest.cc) so disable this until IncludeIsMainRegex has a; // better default for Chromium code.; // - The default for .cc and .mm files is different (r357695) for Google style; // for the same reason. The plan is to unify this again once the main; // header detection works for Google's ObjC code, but this hasn't happened; // yet. Since Chromium has some ObjC code, switching Chromium is blocked; // on that.; // - Finally, ""If include reordering is harmful, put things in different; // blocks to prevent it"" has been a recommendation for a long time that; // people are used to. We'll need a dev education push to change this to; // ""If include reordering is harmful, put things in a different block and; // _prepend that with a comment_ to prevent it"" before changing behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:138,Deployability,configurat,configuration,138,"// DocumentListTraits<vector<FormatStyle>> uses the context to get default; // values for the fields, keys for which are missing from the configuration.; // Mapping also uses the context to get the language to find the correct; // base style.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:138,Modifiability,config,configuration,138,"// DocumentListTraits<vector<FormatStyle>> uses the context to get default; // values for the fields, keys for which are missing from the configuration.; // Mapping also uses the context to get the language to find the correct; // base style.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:31,Deployability,configurat,configuration,31,// Ensures that only the first configuration can skip the Language option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:31,Modifiability,config,configuration,31,// Ensures that only the first configuration can skip the Language option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:32,Modifiability,config,configured,32,// Ensure that each language is configured at most once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:23,Deployability,configurat,configuration,23,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:83,Deployability,configurat,configuration,83,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,Deployability,configurat,configuration,150,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:23,Modifiability,config,configuration,23,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:83,Modifiability,config,configuration,83,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,Modifiability,config,configuration,150,"// Look for a suitable configuration starting from the end, so we can; // find the configuration for the specific language first, and the default; // configuration (which can only be at slot 0) after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:55,Safety,avoid,avoid,55,// NB: testing for not starting with a double quote to avoid; // breaking `template strings`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:7,Testability,test,testing,7,// NB: testing for not starting with a double quote to avoid; // breaking `template strings`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,Availability,error,error,17,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:39,Availability,error,error,39,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:86,Deployability,release,release,86,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:45,Integrability,message,message,45,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:172,Safety,avoid,avoid,172,"/// TrailingCommaInserter inserts trailing commas into container literals.; /// E.g.:; /// const x = [; /// 1,; /// ];; /// TrailingCommaInserter runs after formatting. To avoid causing a required; /// reformatting (and thus reflow), it never inserts a comma that'd exceed the; /// ColumnLimit.; ///; /// Because trailing commas disable binpacking of arrays, TrailingCommaInserter; /// is conceptually incompatible with bin packing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:62,Integrability,wrap,wrap,62,/// Inserts trailing commas in [] and {} initializers if they wrap over; /// multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:20,Availability,reliab,reliably,20,"// getEndLoc is not reliably set during re-lexing, use text length; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:37,Availability,redundant,redundant,37,// This class clean up the erroneous/redundant code around the given ranges in; // file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:37,Safety,redund,redundant,37,// This class clean up the erroneous/redundant code around the given ranges in; // file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,Availability,redundant,redundant,150,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:311,Availability,redundant,redundant,311,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,Safety,redund,redundant,150,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:274,Safety,redund,redundancy,274,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:311,Safety,redund,redundant,311,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:131,Availability,error,error,131,"// If the left brace is in a new line, we should consume it first so that; // it does not make the namespace non-empty.; // FIXME: error handling if there is no left brace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:18,Deployability,continuous,continuous,18,// Merge multiple continuous token deletions into one big deletion so that; // the number of replacements can be reduced. This makes computing affected; // ranges more efficient when we run reformat on the changed code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:113,Energy Efficiency,reduce,reduced,113,// Merge multiple continuous token deletions into one big deletion so that; // the number of replacements can be reduced. This makes computing affected; // ranges more efficient when we run reformat on the changed code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:168,Energy Efficiency,efficient,efficient,168,// Merge multiple continuous token deletions into one big deletion so that; // the number of replacements can be reduced. This makes computing affected; // ranges more efficient when we run reformat on the changed code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,Availability,error,error,17,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:52,Availability,error,error,52,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:87,Deployability,release,release,87,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,Integrability,message,message,58,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,Availability,Redundant,RedundantTokens,58,// Class for less-than inequality comparason for the set `RedundantTokens`.; // We store tokens in the order they appear in the translation unit so that; // we do not need to sort them in `generateFixes()`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,Safety,Redund,RedundantTokens,58,// Class for less-than inequality comparason for the set `RedundantTokens`.; // We store tokens in the order they appear in the translation unit so that; // we do not need to sort them in `generateFixes()`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:347,Deployability,update,updated,347,"// If the #includes are out of order, we generate a single replacement fixing; // the entire block. Otherwise, no replacement is generated.; // In case Style.IncldueStyle.IncludeBlocks != IBS_Preserve, this check is not; // enough as additional newlines might be added or removed across #include; // blocks. This we handle below by generating the updated #include blocks and; // comparing it to the original.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just skip the replacement for the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:80,Deployability,release,release,80,"// FIXME: better error handling. For now, just skip the replacement for the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:175,Integrability,depend,dependencies,175,"// In compiled files, consider the first #include to be the main #include of; // the file if it is not a system #include. This ensures that the header; // doesn't have hidden dependencies; // (http://llvm.org/docs/CodingStandards.html#include-style).; //; // FIXME: Do some validation, e.g. edit distance of the base name, to fix; // cases where the first #include is unlikely to be the main header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:274,Security,validat,validation,274,"// In compiled files, consider the first #include to be the main #include of; // the file if it is not a system #include. This ensures that the header; // doesn't have hidden dependencies; // (http://llvm.org/docs/CodingStandards.html#include-style).; //; // FIXME: Do some validation, e.g. edit distance of the base name, to fix; // cases where the first #include is unlikely to be the main header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:163,Usability,simpl,simplified,163,"// #include with a start of a block comment, but without the end.; // Need to keep all the lines until the end of the comment together.; // FIXME: This is somehow simplified check that probably does not work; // correctly if there are multiple comments on a line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:347,Performance,perform,performed,347,"// Sorts and deduplicates a block of includes given by 'Imports' based on; // JavaImportGroups, then adding the necessary replacement to 'Replaces'.; // Import declarations with the same text will be deduplicated. Between each; // import group, a newline is inserted, and within each import group, a; // lexicographic sort based on ASCII value is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just skip the replacement for the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:80,Deployability,release,release,80,"// FIXME: better error handling. For now, just skip the replacement for the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:170,Safety,detect,detect,170,"// MPEG transport streams use the "".ts"" file extension. clang-format should; // not attempt to format those. MPEG TS' frame format starts with 0x47 every; // 189 bytes - detect that and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:97,Availability,error,error,97,"// Replacements from \p Replaces must be conflict-free already, so we can; // simply consume the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:78,Usability,simpl,simply,78,"// Replacements from \p Replaces must be conflict-free already, so we can; // simply consume the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:3,Performance,Perform,Perform,3,// Perform the actual formatting pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:52,Availability,error,error-prone,52,"// Turning on digraphs in standards before C++0x is error-prone, because e.g.; // the sequence ""<::"" will be unconditionally treated as ""[:"".; // Cf. Lexer::LexTokenInternal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:3,Deployability,Update,Update,3,// Update StyleOptionHelpDescription above when changing this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:21,Modifiability,config,configs,21,// Search for parent configs starting from the parent directory of; // ConfigFile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:71,Modifiability,Config,ConfigFile,71,// Search for parent configs starting from the parent directory of; // ConfigFile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:36,Deployability,configurat,configuration,36,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:75,Deployability,configurat,configuration,75,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:16,Modifiability,inherit,inherits,16,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:36,Modifiability,config,configuration,36,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:75,Modifiability,config,configuration,75,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:105,Modifiability,inherit,inherit,105,"// If the style inherits the parent configuration it is a command line; // configuration, which wants to inherit, so we have to skip the check of the; // StyleName.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:18,Modifiability,inherit,inheritance,18,// Reset possible inheritance,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:9,Modifiability,inherit,inheritance,9,// Reset inheritance of style,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:202,Deployability,configurat,configuration,202,"// Breaking out of the inner loop, since we don't want to parse; // .clang-format AND _clang-format, if both exist. Then we continue the; // outer loop (parent directories) in search for the parent; // configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:202,Modifiability,config,configuration,202,"// Breaking out of the inner loop, since we don't want to parse; // .clang-format AND _clang-format, if both exist. Then we continue the; // outer loop (parent directories) in search for the parent; // configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Format.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatInternal.h:1209,Modifiability,extend,extended,1209,"/// Reformats the given \p Ranges in the code fragment \p Code.; ///; /// A fragment of code could conceptually be surrounded by other code that might; /// constrain how that fragment is laid out.; /// For example, consider the fragment of code between 'R""(' and ')""',; /// exclusive, in the following code:; ///; /// void outer(int x) {; /// string inner = R""(name: data; /// ^ FirstStartColumn; /// value: {; /// x: 1; /// ^ NextStartColumn; /// }; /// )"";; /// ^ LastStartColumn; /// }; ///; /// The outer code can influence the inner fragment as follows:; /// * \p FirstStartColumn specifies the column at which \p Code starts.; /// * \p NextStartColumn specifies the additional indent dictated by the; /// surrounding code. It is applied to the rest of the lines of \p Code.; /// * \p LastStartColumn specifies the column at which the last line of; /// \p Code should end, in case the last line is an empty line.; ///; /// In the case where the last line of the fragment contains content,; /// the fragment ends at the end of that content and \p LastStartColumn is; /// not taken into account, for example in:; ///; /// void block() {; /// string inner = R""(name: value)"";; /// }; ///; /// Each range is extended on either end to its next bigger logic unit, i.e.; /// everything that might influence its formatting or might be influenced by its; /// formatting.; ///; /// Returns a pair P, where:; /// * P.first are the ``Replacements`` necessary to make all \p Ranges comply; /// with \p Style.; /// * P.second is the penalty induced by formatting the fragment \p Code.; /// If the formatting of the fragment doesn't have a notion of penalty,; /// returns 0.; ///; /// If ``Status`` is non-null, its value will be populated with the status of; /// this formatting attempt. See \c FormattingAttemptStatus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatInternal.h:1251,Testability,log,logic,1251,"/// Reformats the given \p Ranges in the code fragment \p Code.; ///; /// A fragment of code could conceptually be surrounded by other code that might; /// constrain how that fragment is laid out.; /// For example, consider the fragment of code between 'R""(' and ')""',; /// exclusive, in the following code:; ///; /// void outer(int x) {; /// string inner = R""(name: data; /// ^ FirstStartColumn; /// value: {; /// x: 1; /// ^ NextStartColumn; /// }; /// )"";; /// ^ LastStartColumn; /// }; ///; /// The outer code can influence the inner fragment as follows:; /// * \p FirstStartColumn specifies the column at which \p Code starts.; /// * \p NextStartColumn specifies the additional indent dictated by the; /// surrounding code. It is applied to the rest of the lines of \p Code.; /// * \p LastStartColumn specifies the column at which the last line of; /// \p Code should end, in case the last line is an empty line.; ///; /// In the case where the last line of the fragment contains content,; /// the fragment ends at the end of that content and \p LastStartColumn is; /// not taken into account, for example in:; ///; /// void block() {; /// string inner = R""(name: value)"";; /// }; ///; /// Each range is extended on either end to its next bigger logic unit, i.e.; /// everything that might influence its formatting or might be influenced by its; /// formatting.; ///; /// Returns a pair P, where:; /// * P.first are the ``Replacements`` necessary to make all \p Ranges comply; /// with \p Style.; /// * P.second is the penalty induced by formatting the fragment \p Code.; /// If the formatting of the fragment doesn't have a notion of penalty,; /// returns 0.; ///; /// If ``Status`` is non-null, its value will be populated with the status of; /// this formatting attempt. See \c FormattingAttemptStatus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:37,Safety,avoid,avoid,37,// Handled by formatFromToken (1) or avoid severe penalty (0).; // Ensure that we start on the opening brace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:115,Safety,avoid,avoid,115,"// Formatting with 1 Column isn't really a column layout, so we don't need the; // special logic here. We can just avoid bin packing any of the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:91,Testability,log,logic,91,"// Formatting with 1 Column isn't really a column layout, so we don't need the; // special logic here. We can just avoid bin packing any of the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:48,Integrability,wrap,wrapped,48,"// In other braced lists styles, the ""}"" can be wrapped to the new line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:124,Safety,avoid,avoid,124,"// Don't use this Format, if the difference between the longest and shortest; // element in a column exceeds a threshold to avoid excessive spaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:453,Integrability,wrap,wrapper,453,"//===--- FormatToken.h - Format C++ code ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the FormatToken, a wrapper; /// around Token with additional information related to formatting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:72,Testability,log,logic,72,"/* The square bracket for the dimension part of the type name. \; * In 'logic [1:0] x[1:0]', only the first '['. This way we can have space \; * before the first bracket but not the second. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:32,Modifiability,config,configured,32,/// Roles a token can take in a configured macro expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:6,Integrability,wrap,wrapper,6,/// A wrapper around a \c Token storing information about the; /// whitespace characters preceding it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:58,Modifiability,variab,variables,58,/// Is this token part of a \c DeclStmt defining multiple variables?; ///; /// Only set if \c Type == \c TT_StartOfName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:103,Safety,avoid,avoid,103,/// The number of newlines immediately before the \c Token after formatting.; ///; /// This is used to avoid overlapping whitespace replacements when \c Newlines; /// is recomputed for a finalized preprocessor branching directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:81,Modifiability,config,configured,81,"/// The original 0-based column of this token, including expanded tabs.; /// The configured TabWidth is used as tab width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:73,Modifiability,config,configured,73,// Contains all attributes related to how this token takes part; // in a configured macro expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:333,Modifiability,refactor,refactorings,333,"/// When macro expansion introduces nodes with children, those are marked as; /// \c MacroParent.; /// FIXME: The formatting code currently hard-codes the assumption that; /// child nodes are introduced by blocks following an opening brace.; /// This is deeply baked into the code and disentangling this will require; /// signficant refactorings. \c MacroParent allows us to special-case the; /// cases in which we treat parents as block-openers for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:37,Usability,simpl,simple-type-specifier,37,/// Determine whether the token is a simple-type-specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:45,Security,access,accessing,45,"/// Returns \c true if this is a ""."" or ""->"" accessing a member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:3,Safety,Detect,Detect,3,"// Detect ""(inline|export)? namespace"" in the beginning of a line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:167,Testability,log,logic,167,// Some keywords are not included here because they don't need special; // treatment like `showcancelled` or they should be treated as identifiers; // like `int` and `logic`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:18,Security,hash,hashes,18,// Workaround for hashes and backticks in Verilog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:54,Safety,avoid,avoid,54,"// Other keywords are handled in the switch below, to avoid problems due; // to duplicate case labels when using the #include trick.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:28,Security,access,access,28,"// Treat like a regular ""."" access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:94,Usability,guid,guide,94,// Valid C# attribute targets:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:222,Deployability,update,updates,222,"// Tries to parse a JavaScript Regex literal starting at the current token,; // if that begins with a slash and is in a location where JavaScript allows; // regex literals. Changes the current token to a regex literal and updates; // its text if successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:111,Availability,error,errors,111,"// JavaScript and Java do not allow to escape the end of the line with a; // backslash. Backslashes are syntax errors in plain source, but can occur in; // comments. When a single line comment ends with a \, it'll cause the next; // line of code to be lexed as a comment, breaking formatting. The code below; // finds comments that contain a backslash followed by a line break, truncates; // the comment token at the backslash, and resets the lexer to restart behind; // the backslash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:44,Security,hash,hash,44,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:93,Security,hash,hash,93,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:167,Security,hash,hash,167,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:222,Security,hash,hash,222,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:275,Security,hash,hash,275,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:322,Security,hash,hash,322,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:31,Integrability,depend,depends,31,"// FIXME: ColumnWidth actually depends on the start column, we need to; // take this into account when the token is moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:31,Integrability,depend,depends,31,"// FIXME: ColumnWidth actually depends on the start column, we need to; // take this into account when the token is moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:456,Testability,assert,assertions,456,"// In Verilog the quote is not a character literal.; //; // Make the backtick and double backtick identifiers to match against them; // more easily.; //; // In Verilog an escaped identifier starts with backslash and ends with; // whitespace. Unless that whitespace is an escaped newline. A backslash can; // also begin an escaped newline outside of an escaped identifier. We check; // for that outside of the Regex since we can't use negative lookhead; // assertions. Simply changing the '*' to '+' breaks stuff as the escaped; // identifier may have a length of 0 according to Section A.9.3.; // FIXME: If there is an escaped newline in the middle of an escaped; // identifier, allow for pasting the two lines together, But escaped; // identifiers usually occur only in generated code anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:468,Usability,Simpl,Simply,468,"// In Verilog the quote is not a character literal.; //; // Make the backtick and double backtick identifiers to match against them; // more easily.; //; // In Verilog an escaped identifier starts with backslash and ends with; // whitespace. Unless that whitespace is an escaped newline. A backslash can; // also begin an escaped newline outside of an escaped identifier. We check; // for that outside of the Regex since we can't use negative lookhead; // assertions. Simply changing the '*' to '+' breaks stuff as the escaped; // identifier may have a length of 0 according to Section A.9.3.; // FIXME: If there is an escaped newline in the middle of an escaped; // identifier, allow for pasting the two lines together, But escaped; // identifiers usually occur only in generated code anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.h:222,Deployability,update,updates,222,"// Tries to parse a JavaScript Regex literal starting at the current token,; // if that begins with a slash and is in a location where JavaScript allows; // regex literals. Changes the current token to a regex literal and updates; // its text if successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenSource.h:439,Integrability,interface,interface,439,"//===--- FormatTokenSource.h - Format C++ code ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the \c FormatTokenSource interface, which provides a token; /// stream as well as the ability to manipulate the token stream.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/FormatTokenSource.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenSource.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp:325,Testability,assert,assert,325,"// In addition to the following cases, we can also run into this; // when a macro call had more arguments than expected; in that case,; // the comma and the remaining tokens in the macro call will; // potentially end up in the line when we finish the expansion.; // FIXME: Add the information which arguments are unused, and assert; // one of the cases below plus reconstructed macro argument tokens.; // assert(ClosingParen || TrailingComment || PreviousLevel);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp:405,Testability,assert,assert,405,"// In addition to the following cases, we can also run into this; // when a macro call had more arguments than expected; in that case,; // the comma and the remaining tokens in the macro call will; // potentially end up in the line when we finish the expansion.; // FIXME: Add the information which arguments are unused, and assert; // one of the cases below plus reconstructed macro argument tokens.; // assert(ClosingParen || TrailingComment || PreviousLevel);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp:573,Testability,assert,assert,573,"// Handle the remaining open tokens:; // - expand the closing parenthesis, if it exists, including an optional; // trailing comment; // - handle tokens that were already reconstructed at an inner expansion; // level; // - handle tokens when a macro call had more than the expected number of; // arguments, i.e. when #define M(x) is called as M(a, b, c) we'll end; // up with the sequence "", b, c)"" being open at the end of the; // reconstruction; we want to gracefully handle that case; //; // FIXME: See the above debug-check for what we will need to do to be; // able to assert this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp:287,Availability,error,erroring,287,"// Note that any tokens that are tagged with MR_None have been passed as; // arguments to the macro that have not been expanded, for example:; // Given: #define ID(X) x; // When calling: ID(a, b); // 'b' will be part of the reconstructed token stream, but tagged MR_None.; // Given that erroring out in this case would be disruptive, we continue; // pushing the (unformatted) token.; // FIXME: This can lead to unfortunate formatting decisions - give the user; // a hint that their macro definition is broken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:477,Deployability,configurat,configuration,477,"//===--- MacroExpander.cpp - Format C++ code --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the implementation of MacroExpander, which handles macro; /// configuration and expansion while formatting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:477,Modifiability,config,configuration,477,"//===--- MacroExpander.cpp - Format C++ code --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the implementation of MacroExpander, which handles macro; /// configuration and expansion while formatting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:133,Availability,error,error,133,// Parse the token stream and return the corresponding Definition object.; // Returns an empty definition object with a null-Name on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:123,Safety,abort,abort,123,"// If there are fewer arguments than referenced parameters, treat the; // parameter as empty.; // FIXME: Potentially fully abort the expansion instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:679,Deployability,configurat,configuration,679,"//===--- Macros.h - Format C++ code -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the main building blocks of macro support in; /// clang-format.; ///; /// In order to not violate the requirement that clang-format can format files; /// in isolation, clang-format's macro support uses expansions users provide; /// as part of clang-format's style configuration.; ///; /// Macro definitions are of the form ""MACRO(p1, p2)=p1 + p2"", but only support; /// one level of expansion (\see MacroExpander for a full description of what; /// is supported).; ///; /// As part of parsing, clang-format uses the MacroExpander to expand the; /// spelled token streams into expanded token streams when it encounters a; /// macro call. The UnwrappedLineParser continues to parse UnwrappedLines; /// from the expanded token stream.; /// After the expanded unwrapped lines are parsed, the MacroCallReconstructor; /// matches the spelled token stream into unwrapped lines that best resemble the; /// structure of the expanded unwrapped lines. These reconstructed unwrapped; /// lines are aliasing the tokens in the expanded token stream, so that token; /// annotations will be reused when formatting the spelled macro calls.; ///; /// When formatting, clang-format annotates and formats the expanded unwrapped; /// lines first, determining the token types. Next, it formats the spelled; /// unwrapped lines, keeping the token types fixed, while allowing other; /// formatting decisions to change.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:679,Modifiability,config,configuration,679,"//===--- Macros.h - Format C++ code -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the main building blocks of macro support in; /// clang-format.; ///; /// In order to not violate the requirement that clang-format can format files; /// in isolation, clang-format's macro support uses expansions users provide; /// as part of clang-format's style configuration.; ///; /// Macro definitions are of the form ""MACRO(p1, p2)=p1 + p2"", but only support; /// one level of expansion (\see MacroExpander for a full description of what; /// is supported).; ///; /// As part of parsing, clang-format uses the MacroExpander to expand the; /// spelled token streams into expanded token streams when it encounters a; /// macro call. The UnwrappedLineParser continues to parse UnwrappedLines; /// from the expanded token stream.; /// After the expanded unwrapped lines are parsed, the MacroCallReconstructor; /// matches the spelled token stream into unwrapped lines that best resemble the; /// structure of the expanded unwrapped lines. These reconstructed unwrapped; /// lines are aliasing the tokens in the expanded token stream, so that token; /// annotations will be reused when formatting the spelled macro calls.; ///; /// When formatting, clang-format annotates and formats the expanded unwrapped; /// lines first, determining the token types. Next, it formats the spelled; /// unwrapped lines, keeping the token types fixed, while allowing other; /// formatting decisions to change.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:177,Usability,simpl,simple,177,"/// Construct a macro expander from a set of macro definitions.; /// Macro definitions must be encoded as UTF-8.; ///; /// Each entry in \p Macros must conform to the following simple; /// macro-definition language:; /// <definition> ::= <id> <expansion> | <id> ""("" <params> "")"" <expansion>; /// <params> ::= <id-list> | """"; /// <id-list> ::= <id> | <id> "","" <params>; /// <expansion> ::= ""="" <tail> | <eof>; /// <tail> ::= <tok> <tail> | <eof>; ///; /// Macros that cannot be parsed will be silently discarded.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:271,Usability,simpl,simplest,271,"/// Converts a sequence of UnwrappedLines containing expanded macros into a; /// single UnwrappedLine containing the macro calls. This UnwrappedLine may be; /// broken into child lines, in a way that best conveys the structure of the; /// expanded code.; ///; /// In the simplest case, a spelled UnwrappedLine contains one macro, and after; /// expanding it we have one expanded UnwrappedLine. In general, macro; /// expansions can span UnwrappedLines, and multiple macros can contribute; /// tokens to the same line. We keep consuming expanded lines until:; /// * all expansions that started have finished (we're not chopping any macros; /// in half); /// * *and* we've reached the end of a *spelled* unwrapped line.; ///; /// A single UnwrappedLine represents this chunk of code.; ///; /// After this point, the state of the spelled/expanded stream is ""in sync""; /// (both at the start of an UnwrappedLine, with no macros open), so the; /// Reconstructor can be thrown away and parsing can continue.; ///; /// Given a mapping from the macro name identifier token in the macro call; /// to the tokens of the macro call, for example:; /// CLASSA -> CLASSA({public: void x();}); ///; /// When getting the formatted lines of the expansion via the \c addLine method; /// (each '->' specifies a call to \c addLine ):; /// -> class A {; /// -> public:; /// -> void x();; /// -> };; ///; /// Creates the tree of unwrapped lines containing the macro call tokens so that; /// the macro call tokens fit the semantic structure of the expanded formatted; /// lines:; /// -> CLASSA({; /// -> public:; /// -> void x();; /// -> })",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:151,Deployability,rolling,rolling,151,// Line in which we build up the resulting unwrapped line.; // FIXME: Investigate changing UnwrappedLine to a pointer type and using it; // instead of rolling our own type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:75,Energy Efficiency,reduce,reduce,75,"// The line in which we collect the resulting reconstructed output.; // To reduce special cases in the algorithm, the first level of the line; // contains a single null token that has the reconstructed incoming; // lines as children.; // In the end, we stich the lines together so that each subsequent line; // is a child of the last token of the previous line. This is necessary; // in order to format the overall expression as a single logical line -; // if we created separate lines, we'd format them with their own top-level; // indent depending on the semantic structure, which is not desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:540,Integrability,depend,depending,540,"// The line in which we collect the resulting reconstructed output.; // To reduce special cases in the algorithm, the first level of the line; // contains a single null token that has the reconstructed incoming; // lines as children.; // In the end, we stich the lines together so that each subsequent line; // is a child of the last token of the previous line. This is necessary; // in order to format the overall expression as a single logical line -; // if we created separate lines, we'd format them with their own top-level; // indent depending on the semantic structure, which is not desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:438,Testability,log,logical,438,"// The line in which we collect the resulting reconstructed output.; // To reduce special cases in the algorithm, the first level of the line; // contains a single null token that has the reconstructed incoming; // lines as children.; // In the end, we stich the lines together so that each subsequent line; // is a child of the last token of the previous line. This is necessary; // in order to format the overall expression as a single logical line -; // if we created separate lines, we'd format them with their own top-level; // indent depending on the semantic structure, which is not desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/Macros.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.cpp:553,Integrability,depend,depending,553,"//===--- ObjCPropertyAttributeOrderFixer.cpp -------------------*- C++--*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements ObjCPropertyAttributeOrderFixer, a TokenAnalyzer that; /// adjusts the order of attributes in an ObjC `@property(...)` declaration,; /// depending on the style.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.h:563,Integrability,depend,depending,563,"//===--- ObjCPropertyAttributeOrderFixer.h ------------------------------*- C++; //-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares ObjCPropertyAttributeOrderFixer, a TokenAnalyzer that; /// adjusts the order of attributes in an ObjC `@property(...)` declaration,; /// depending on the style.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ObjCPropertyAttributeOrderFixer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:504,Integrability,depend,depending,504,"//===--- QualifierAlignmentFixer.cpp ----------------------------*- C++--*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements QualifierAlignmentFixer, a TokenAnalyzer that; /// enforces either left or right const depending on the style.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:8,Safety,safe,safe,8,"// Stay safe and don't move past macros, also don't bother with sorting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:91,Performance,perform,perform,91,"// For left qualifiers preceeded by nothing, a template declaration, or *,&,&&; // we only perform sorting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:25,Modifiability,config,configured,25,// Don't sort past a non-configured qualifier token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:8,Safety,safe,safe,8,"// Stay safe and don't move past macros, also don't bother with sorting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:3,Integrability,Depend,Depending,3,"// Depending on the position of type in the order you need; // To iterate forward or backward through the order list as qualifier; // can push through each other.; // The Order list must define the position of ""type"" to signify",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h:501,Integrability,depend,depending,501,"//===--- QualifierAlignmentFixer.h -------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares QualifierAlignmentFixer, a TokenAnalyzer that; /// enforces either east or west const depending on the style.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h:18,Usability,simpl,simple,18,// Is the Token a simple or qualifier type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:104,Deployability,release,release,104,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:25,Deployability,toggle,toggle,25,// clang-format comments toggle formatting on/off.; // This is tracked in FormattingOff here and on JsModuleReference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:500,Modifiability,extend,extended,500,"//===--- TokenAnalyzer.cpp - Analyze Token Streams --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an abstract TokenAnalyzer and associated helper; /// classes. TokenAnalyzer can be extended to generate replacements based on; /// an annotated and pre-processed token stream.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:100,Availability,error,errors,100,// FIXME: Instead of printing the diagnostic we should store it and have a; // better way to return errors through the format APIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:60,Availability,error,error,60,// Validate that we can get the buffer data without a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:3,Security,Validat,Validate,3,// Validate that we can get the buffer data without a fatal error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:17,Availability,error,error,17,"// FIXME: better error handling here. For now, simply return an empty; // Replacements to indicate failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:99,Availability,failure,failure,99,"// FIXME: better error handling here. For now, simply return an empty; // Replacements to indicate failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:47,Usability,simpl,simply,47,"// FIXME: better error handling here. For now, simply return an empty; // Replacements to indicate failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.h:499,Modifiability,extend,extended,499,"//===--- TokenAnalyzer.h - Analyze Token Streams ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares an abstract TokenAnalyzer, and associated helper; /// classes. TokenAnalyzer can be extended to generate replacements based on; /// an annotated and pre-processed token stream.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:85,Modifiability,variab,variable,85,"// C++17 '[[using ns: foo, bar(baz, blech)]]'; // We assume nobody will name an ObjC variable 'using'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:8,Integrability,message,message,8,"// ObjC message send. We assume nobody will use : in a C++11 attribute; // specifier parameter, although this is technically valid:; // [[foo(:)]].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:88,Safety,detect,detect,88,"// If this angle is in the context of an expression, we need to be more; // hesitant to detect it as opening template parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:79,Safety,detect,detected,79,// Infer the role of the l_paren based on the previous token if we haven't; // detected one yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:3,Safety,Detect,Detect,3,"// Detect the case where macros are used to generate lambdas or; // function bodies, e.g.:; // auto my_lambda = MACRO((Type *type, int i) { .. body .. });",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:26,Security,access,access,26,// Limit this to being an access modifier that follows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:43,Integrability,message,message,43,"// Square braces in LK_Proto can either be message field attributes:; //; // optional Aaa aaa = 1 [; // (aaa) = aaa; // ];; //; // extensions 123 [; // (aaa) = aaa; // ];; //; // or text proto extensions (in options):; //; // option (Aaa.options) = {; // [type.type/type] {; // key: value; // }; // }; //; // or repeated fields (in options):; //; // option (Aaa.options) = {; // keys: [ 1, 2, 3 ]; // }; //; // In the first and the third case we want to spread the contents inside; // the square braces; in the second we want to keep them inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:88,Availability,error,error,88,// We still want to format the whitespace left of the first token of the; // warning or error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:3,Security,Hash,Hashes,3,// Hashes in the middle of a line can lead to any strange token; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:58,Integrability,protocol,protocol,58,"// Directly allow to 'import <string-literal>' to support protocol buffer; // definitions (github.com/google/protobuf) or missing ""#"" (either way we; // should not break the line).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:97,Deployability,a/b,a/b,97,"// If this line starts and ends in '<' and '>', respectively, it is likely; // part of ""#define <a/b.h>"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:126,Integrability,wrap,wrapped,126,"// In .proto files, top-level options and package statements are very; // similar to import statements and should not be line-wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:192,Integrability,wrap,wraps,192,"// export {...} from '...';; // An export followed by ""from 'some string';"" is a re-export from; // another module identified by a URI and is treated as a; // LT_ImportStatement (i.e. prevent wraps on it for long URIs).; // Just ""export {...};"" or ""export class ..."" should not be treated as; // an import in this sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:77,Modifiability,config,configurable,77,// FIXME: Closure-library specific stuff should not be hard-coded but be; // configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:70,Availability,recover,recovered,70,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:88,Availability,error,error,88,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:100,Availability,failure,failure,100,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:70,Safety,recover,recovered,70,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:12,Modifiability,inherit,inheritance,12,// Like the inheritance list in a class declaration.; // class Input : public IO,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:34,Modifiability,variab,variable,34,// `template` keyword can start a variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:24,Usability,guid,guide,24,// Look for a deduction guide template<T> A(...) -> A<...>;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:162,Modifiability,variab,variable,162,// Reset FirstStartOfName after finding a semicolon so that a for loop; // with multiple increment statements is not confused with a for loop; // having multiple variable declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:13,Usability,guid,guides,13,"// Deduction guides trailing arrow "" A(...) -> A<T>;"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:19,Integrability,interface,interface,19,"// In JavaScript, `interface X { foo?(): bar; }` is an optional method; // on the interface, not a ternary expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:82,Integrability,interface,interface,82,"// In JavaScript, `interface X { foo?(): bar; }` is an optional method; // on the interface, not a ternary expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:71,Modifiability,variab,variable,71,/// Take a guess at whether \p Tok starts a name of a function or; /// variable declaration.; ///; /// This is a heuristic based on whether \p Tok is an identifier following; /// something that is likely a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:163,Testability,log,logic,163,"// At this point, we heuristically assume that there are no casts at the; // start of the line. We assume that we have found most cases where there; // are by the logic above, e.g. ""(void)x;"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:31,Security,access,access,31,// Tokens that indicate member access or chained operator& use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:9,Modifiability,variab,variables,9,// Group variables of the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:124,Modifiability,variab,variable,124,// Add fake parenthesis around declarations of the same type for example in a; // module prototype. Return the first port / variable of the current type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:100,Modifiability,variab,variable,100,"// Skip any type qualifiers to find the first identifier. It may be either a; // new type name or a variable name. There can be several type qualifiers; // preceding a variable name, and we can not tell them apart by looking at; // the word alone since a macro can be defined as either a type qualifier or; // a variable name. Thus we use the last word before the dimensions instead; // of the first word as the candidate for the variable or type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:168,Modifiability,variab,variable,168,"// Skip any type qualifiers to find the first identifier. It may be either a; // new type name or a variable name. There can be several type qualifiers; // preceding a variable name, and we can not tell them apart by looking at; // the word alone since a macro can be defined as either a type qualifier or; // a variable name. Thus we use the last word before the dimensions instead; // of the first word as the candidate for the variable or type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:312,Modifiability,variab,variable,312,"// Skip any type qualifiers to find the first identifier. It may be either a; // new type name or a variable name. There can be several type qualifiers; // preceding a variable name, and we can not tell them apart by looking at; // the word alone since a macro can be defined as either a type qualifier or; // a variable name. Thus we use the last word before the dimensions instead; // of the first word as the candidate for the variable or type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:430,Modifiability,variab,variable,430,"// Skip any type qualifiers to find the first identifier. It may be either a; // new type name or a variable name. There can be several type qualifiers; // preceding a variable name, and we can not tell them apart by looking at; // the word alone since a macro can be defined as either a type qualifier or; // a variable name. Thus we use the last word before the dimensions instead; // of the first word as the candidate for the variable or type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:9,Modifiability,variab,variables,9,// Group variables of the previous type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:163,Safety,avoid,avoid,163,"// If we find a trailing comment, iterate backwards to determine whether; // it seems to relate to a specific parameter. If so, break before that; // parameter to avoid changing the comment's meaning. E.g. don't move 'b'; // to the previous line in:; // SomeFunction(a,; // b, // comment; // c);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:159,Energy Efficiency,Reduce,Reduce,159,// FIXME: Only calculate this if CanBreakBefore is true once static; // initializers etc. are sorted out.; // FIXME: Move magic numbers to a better place.; // Reduce penalty for aligning ObjC method arguments using the colon; // alignment as this is the canonical way (still prefer fitting everything; // into one line if possible). Trying to fit a whole expression into one; // line should not force other line breaks (e.g. when ObjC method; // expression is a part of other expression).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:703,Integrability,wrap,wrapping,703,"// Breaking before the ""./->"" of a chained call/member access is reasonably; // cheap, as formatting those with one call per line is generally; // desirable. In particular, it should be cheaper to break before the call; // than it is to break inside a call's parameters, which could lead to weird; // ""hanging"" indents. The exception is the very last ""./->"" to support this; // frequent pattern:; //; // aaaaaaaa.aaaaaaaa.bbbbbbb().ccccccccccccccccccccc(; // dddddddd);; //; // which might otherwise be blown up onto many lines. Here, clang-format; // won't produce ""hanging"" indents anyway as there is no other trailing; // call.; //; // Also apply higher penalty is not a call as that might lead to a wrapping; // like:; //; // aaaaaaa; // .aaaaaaaaa.bbbbbbbb(cccccccc);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:55,Security,access,access,55,"// Breaking before the ""./->"" of a chained call/member access is reasonably; // cheap, as formatting those with one call per line is generally; // desirable. In particular, it should be cheaper to break before the call; // than it is to break inside a call's parameters, which could lead to weird; // ""hanging"" indents. The exception is the very last ""./->"" to support this; // frequent pattern:; //; // aaaaaaaa.aaaaaaaa.bbbbbbb().ccccccccccccccccccccc(; // dddddddd);; //; // which might otherwise be blown up onto many lines. Here, clang-format; // won't produce ""hanging"" indents anyway as there is no other trailing; // call.; //; // Also apply higher penalty is not a call as that might lead to a wrapping; // like:; //; // aaaaaaa; // .aaaaaaaaa.bbbbbbbb(cccccccc);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:121,Integrability,protocol,protocol,121,"// In Objective-C type declarations, avoid breaking after the category's; // open paren (we'll prefer breaking after the protocol list's opening; // angle bracket, if present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:37,Safety,avoid,avoid,37,"// In Objective-C type declarations, avoid breaking after the category's; // open paren (we'll prefer breaking after the protocol list's opening; // angle bracket, if present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:52,Testability,log,log-like,52,// Slightly prefer to break before the first one in log-like statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:64,Availability,error,error-prone,64,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:160,Modifiability,variab,variable,160,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:211,Modifiability,variab,variable,211,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:261,Safety,avoid,avoid,261,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:317,Integrability,depend,dependent,317,// Space between the type and the * in:; // operator void*(); // operator char*(); // operator void const*(); // operator void volatile*(); // operator /*comment*/ const char*(); // operator volatile /*comment*/ char*(); // operator Foo*(); // operator C<T>*(); // operator std::Foo*(); // operator C<T>::D<U>*(); // dependent on PointerAlignment style.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:24,Modifiability,variab,variable,24,"// No space between the variable name and the initializer list.; // A a1{1};; // Verilog doesn't have such syntax, but it has word operators that are C++; // identifiers like `a inside {b, c}`. So the rule is not applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:37,Safety,avoid,avoid,37,// Leave a space between * and /* to avoid C4138 `comment end` found outside; // of comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:25,Integrability,protocol,protocol,25,// Slashes occur in text protocol extension syntax: [type/type] { ... }.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:26,Modifiability,variab,variable,26,"// space between type and variable e.g. Dictionary<string,string> foo;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:8,Testability,assert,assertions,8,// Type assertions ('<type>expr') are not followed by whitespace. Other; // locations that should have whitespace following are identified by the; // above set of follower tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:55,Testability,log,logic,55,// Add space between the type name and dimension like `logic [1:0]`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:131,Safety,Detect,Detect,131,"// If the next token is a binary operator or a selector name, we have; // incorrectly classified the parenthesis as a cast. FIXME: Detect correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:34,Modifiability,inherit,inheritance,34,// Break only if we have multiple inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:62,Integrability,protocol,protocol,62,// Don't put enums or option definitions onto single lines in protocol; // buffers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:36,Integrability,interface,interface,36,// Ensure BraceWrapping for `public interface A {`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:10,Integrability,wrap,wrapping,10,// Ensure wrapping after __attribute__((XX)) and @interface etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:50,Integrability,interface,interface,50,// Ensure wrapping after __attribute__((XX)) and @interface etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:369,Safety,detect,detecting,369,"// If Left.ParameterCount is 0, then this submessage entry is not the; // first in its parent submessage, and we want to break before this entry.; // If Left.ParameterCount is greater than 0, then its parent submessage; // might contain 1 or more entries and we want to break before this entry; // if it contains at least 2 entries. We deal with this case later by; // detecting and breaking before the next entry in the parent submessage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:162,Safety,detect,detecting,162,"// However, if this submessage is the first entry in its parent; // submessage, Left.ParameterCount might be 1 in some cases.; // We deal with this case later by detecting an entry; // following a closing paren of this submessage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:9,Integrability,wrap,wrap,9,"// Don't wrap between "":"" and ""!"" of a strict prop init (""field!: type;"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:115,Deployability,release,release-notes,115,"// extends and infer can appear as keywords in conditional types:; // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#conditional-types; // do not break before them, as the expressions are subject to ASI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:3,Modifiability,extend,extends,3,"// extends and infer can appear as keywords in conditional types:; // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#conditional-types; // do not break before them, as the expressions are subject to ASI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:7,Integrability,interface,interface,7,"// An @interface, @implementation, or @protocol line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:39,Integrability,protocol,protocol,39,"// An @interface, @implementation, or @protocol line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:98,Testability,Assert,Asserts,98,/// \c true if this line looks like a function definition instead of a; /// function declaration. Asserts MightBeFunctionDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:4,Energy Efficiency,Adapt,Adapts,4,/// Adapts the indent levels of comment lines to the indent of the; /// subsequent line.; // FIXME: Can/should this be done in the UnwrappedLineParser?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:4,Modifiability,Adapt,Adapts,4,/// Adapts the indent levels of comment lines to the indent of the; /// subsequent line.; // FIXME: Can/should this be done in the UnwrappedLineParser?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:4,Deployability,Update,Update,4,/// Update the indent state given that \p Line is going to be formatted; /// next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Deployability,Update,Update,3,// Update the indent level cache size so that we can rely on it; // having the right size in adjustToUnmodifiedline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:27,Performance,cache,cache,27,// Update the indent level cache size so that we can rely on it; // having the right size in adjustToUnmodifiedline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:4,Deployability,Update,Update,4,"/// Update the level indent to adapt to the given \p Line.; ///; /// When a line is not formatted, we move the subsequent lines on the same; /// level to the same indent.; /// Note that \c nextLine must have been called before this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:31,Energy Efficiency,adapt,adapt,31,"/// Update the level indent to adapt to the given \p Line.; ///; /// When a line is not formatted, we move the subsequent lines on the same; /// level to the same indent.; /// Note that \c nextLine must have been called before this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:31,Modifiability,adapt,adapt,31,"/// Update the level indent to adapt to the given \p Line.; ///; /// When a line is not formatted, we move the subsequent lines on the same; /// level to the same indent.; /// Note that \c nextLine must have been called before this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:20,Security,access,access,20,// Handle malformed access specifier e.g. 'private' without trailing ':'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:7,Security,Access,AccessModifierOffset,7,"// The AccessModifierOffset may be overridden by IndentAccessModifiers,; // in which case we take a negative value of the IndentWidth to simulate; // the upper indent level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:63,Integrability,wrap,wrapped,63,// Handle empty record blocks where the brace has already been wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:30,Safety,avoid,avoid,30,// TODO: Use IndentTracker to avoid loop?; // Find the last line with lower level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce indent level for bodies of namespaces which were compacted,; // but only if their content was indented in the first place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:58,Integrability,wrap,wrapped,58,// Try to merge a control statement block with left brace wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:38,Integrability,wrap,wrapped,38,"// If possible, merge the next line's wrapped left brace with the; // current line. Otherwise, leave it on the next line, as this is a; // multi-line control statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:37,Integrability,wrap,wrapped,37,// Don't merge block with left brace wrapped after ObjC special blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:37,Integrability,wrap,wrapped,37,// Don't merge block with left brace wrapped after case labels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:108,Integrability,wrap,wrapping,108,"// NOTE: We use AfterClass (whereas AfterStruct exists) for both classes; // and structs, but it seems that wrapping is still handled correctly; // elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:49,Integrability,wrap,wrapped,49,// Try to merge a function block with left brace wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:15,Usability,simpl,simple,15,"// Only inline simple if's (no nested if or else), unless specified",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:52,Integrability,depend,depends,52,// Check that the current line allows merging. This depends on whether we; // are in a control flow statements as well as several style flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:126,Testability,test,tests,126,"// FIXME: Consider an option to allow short exception handling clauses on; // a single line.; // FIXME: This isn't covered by tests.; // FIXME: For catch, __except, __finally the first token on the line; // is '}', so this isn't correct here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:95,Integrability,depend,dependent,95,"// Reset whether spaces or a line break are required before this token, as; // that is context dependent, and that context may change when formatting; // the macro call. For example, given M(x) -> 2 * x, and the macro call; // M(var), the token 'var' will have SpacesRequiredBefore = 1 after being; // formatted as part of the expanded macro, but SpacesRequiredBefore = 0; // for its position within the macro call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:186,Energy Efficiency,adapt,adapts,186,"/// If the \p State's next token is an r_brace closing a nested block,; /// format the nested block before it.; ///; /// Returns \c true if all children could be placed successfully and adapts; /// \p Penalty as well as \p State. If \p DryRun is false, also directly; /// creates changes using \c Whitespaces.; ///; /// The crucial idea here is that children always get formatted upon; /// encountering the closing brace right after the nested block. Now, if we; /// are currently trying to keep the ""}"" on the same line (i.e. \p NewLine is; /// \c false), the entire block has to be kept on the same line (which is only; /// possible if it fits on the line, only contains a single statement, etc.; ///; /// If \p NewLine is true, we format the nested block on separate lines, i.e.; /// break after the ""{"", format all lines with correct indentation and the put; /// the closing ""}"" on yet another new line.; ///; /// This enables us to keep the simple structure of the; /// \c UnwrappedLineFormatter, where we only have two options for each token:; /// break or don't break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:186,Modifiability,adapt,adapts,186,"/// If the \p State's next token is an r_brace closing a nested block,; /// format the nested block before it.; ///; /// Returns \c true if all children could be placed successfully and adapts; /// \p Penalty as well as \p State. If \p DryRun is false, also directly; /// creates changes using \c Whitespaces.; ///; /// The crucial idea here is that children always get formatted upon; /// encountering the closing brace right after the nested block. Now, if we; /// are currently trying to keep the ""}"" on the same line (i.e. \p NewLine is; /// \c false), the entire block has to be kept on the same line (which is only; /// possible if it fits on the line, only contains a single statement, etc.; ///; /// If \p NewLine is true, we format the nested block on separate lines, i.e.; /// break after the ""{"", format all lines with correct indentation and the put; /// the closing ""}"" on yet another new line.; ///; /// This enables us to keep the simple structure of the; /// \c UnwrappedLineFormatter, where we only have two options for each token:; /// break or don't break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:946,Usability,simpl,simple,946,"/// If the \p State's next token is an r_brace closing a nested block,; /// format the nested block before it.; ///; /// Returns \c true if all children could be placed successfully and adapts; /// \p Penalty as well as \p State. If \p DryRun is false, also directly; /// creates changes using \c Whitespaces.; ///; /// The crucial idea here is that children always get formatted upon; /// encountering the closing brace right after the nested block. Now, if we; /// are currently trying to keep the ""}"" on the same line (i.e. \p NewLine is; /// \c false), the entire block has to be kept on the same line (which is only; /// possible if it fits on the line, only contains a single statement, etc.; ///; /// If \p NewLine is true, we format the nested block on separate lines, i.e.; /// break after the ""{"", format all lines with correct indentation and the put; /// the closing ""}"" on yet another new line.; ///; /// This enables us to keep the simple structure of the; /// \c UnwrappedLineFormatter, where we only have two options for each token:; /// break or don't break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:73,Testability,assert,assert,73,// The previous token does not open a block. Nothing to do. We don't; // assert so that we can simply call this function for all tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:95,Usability,simpl,simply,95,// The previous token does not open a block. Nothing to do. We don't; // assert so that we can simply call this function for all tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:22,Usability,simpl,simply,22,"/// Formats the line, simply keeping all of the input's line breaking; /// decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:96,Integrability,depend,dependent,96,"/// An edge in the solution space from \c Previous->State to \c State,; /// inserting a newline dependent on the \c NewLine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:42,Performance,queue,queue,42,/// An item in the prioritized BFS search queue. The \c StateNode's; /// \c State has the given \c OrderedPenalty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:12,Performance,queue,queue,12,/// The BFS queue type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:29,Performance,queue,queue,29,// Insert start element into queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:44,Performance,queue,queue,44,/// Add the following state to the analysis queue \c Queue.; ///; /// Assume the current state is \p PreviousNode and has been reached with a; /// penalty of \p Penalty. Insert a line break if \p NewLine is \c true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:53,Performance,Queue,Queue,53,/// Add the following state to the analysis queue \c Queue.; ///; /// Assume the current state is \p PreviousNode and has been reached with a; /// penalty of \p Penalty. Insert a line break if \p NewLine is \c true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:80,Availability,error,error,80,"// We cannot format this line; if the reason is that the line had a; // parsing error, remember that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Energy Efficiency,Adapt,Adapt,3,// Adapt following lines on the current indent level to the same level; // unless the current \c AnnotatedLine is not at the beginning of a line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Modifiability,Adapt,Adapt,3,// Adapt following lines on the current indent level to the same level; // unless the current \c AnnotatedLine is not at the beginning of a line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:38,Security,access,access,38,// Insert or remove empty line before access specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:18,Security,access,access,18,// Previous is an access modifier remove all new lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:37,Security,access,access,37,// Insert or remove empty line after access specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:63,Security,access,access,63,// EmptyLineBeforeAccessModifier is handling the case when two access; // modifiers follow each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:51,Security,hash,hash,51,// Preprocessor directives get indented before the hash only if specified. In; // Javascript import statements are indented like normal statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h:130,Availability,error,error,130,/// Add a new line and the required indent before the first Token; /// of the \c UnwrappedLine if there was no structural parsing error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h:3,Performance,Cache,Cache,3,// Cache to store the penalty of formatting a vector of AnnotatedLines; // starting from a specific additional offset. Improves performance if there; // are many nested blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h:128,Performance,perform,performance,128,// Cache to store the penalty of formatting a vector of AnnotatedLines; // starting from a specific additional offset. Improves performance if there; // are many nested blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:271,Usability,simpl,simple,271,"/// \brief Parses a level, that is ???.; /// \param OpeningBrace Opening brace (\p nullptr if absent) of that level.; /// \param IfKind The \p if statement kind in the level.; /// \param IfLeftBrace The left brace of the \p if block in the level.; /// \returns true if a simple block of if/else/for/while, or false otherwise.; /// (A simple block has a single statement.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:334,Usability,simpl,simple,334,"/// \brief Parses a level, that is ???.; /// \param OpeningBrace Opening brace (\p nullptr if absent) of that level.; /// \param IfKind The \p if statement kind in the level.; /// \param IfLeftBrace The left brace of the \p if block in the level.; /// \returns true if a simple block of if/else/for/while, or false otherwise.; /// (A simple block has a single statement.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:59,Deployability,update,update,59,// Keep a stack of positions of lbrace tokens. We will; // update information about whether an lbrace starts a; // braced init list or a different block during the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:10,Safety,detect,detect,10,"// Try to detect a braced list. Note that regardless how we mark inner; // braces here, we will overwrite the BlockKind later if we parse a; // braced list (where all blocks inside are by default braced lists),; // or when we explicitly detect blocks (for example while parsing; // lambdas).; // If we already marked the opening brace as braced list, the closing; // must also be part of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:237,Safety,detect,detect,237,"// Try to detect a braced list. Note that regardless how we mark inner; // braces here, we will overwrite the BlockKind later if we parse a; // braced list (where all blocks inside are by default braced lists),; // or when we explicitly detect blocks (for example while parsing; // lambdas).; // If we already marked the opening brace as braced list, the closing; // must also be part of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:38,Usability,simpl,simple,38,"// A statement can end with only `;` (simple statement), a block; // closing brace (compound statement), or `:` (label statement).; // If PrevTok is a block opening brace, Tok ends an empty block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:131,Integrability,depend,depending,131,"// Whitesmiths is weird here. The brace needs to be indented for the namespace; // block, but the block itself may not be indented depending on the style; // settings. This allows the format to back up one level in those cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:22,Integrability,wrap,wrapped,22,// The line above the wrapped l_brace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Deployability,Update,Update,3,// Update the opening line to add the forward reference as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:77,Modifiability,config,configurable,77,// FIXME: Closure-library specific stuff should not be hard-coded but be; // configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Availability,Error,Errors,3,"// Errors during a preprocessor directive can only affect the layout of the; // preprocessor directive, and thus we ignore them. An alternative approach; // would be to use the same approach we use on the file level (no; // re-indentation if there was a structural error) within the macro; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:265,Availability,error,error,265,"// Errors during a preprocessor directive can only affect the layout of the; // preprocessor directive, and thus we ignore them. An alternative approach; // would be to use the same approach we use on the file level (no; // re-indentation if there was a structural error) within the macro; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:40,Integrability,interface,interface,40,"// e.g. ""default void f() {}"" in a Java interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:8,Integrability,synchroniz,synchronization,8,// Skip synchronization object,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:30,Integrability,interface,interface,30,"// In JavaScript/TypeScript, ""interface"" can be used as a standalone; // identifier, e.g. in `var interface = 1;`. If ""interface"" is; // followed by another identifier, it is very like to be an actual; // interface declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:98,Integrability,interface,interface,98,"// In JavaScript/TypeScript, ""interface"" can be used as a standalone; // identifier, e.g. in `var interface = 1;`. If ""interface"" is; // followed by another identifier, it is very like to be an actual; // interface declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:119,Integrability,interface,interface,119,"// In JavaScript/TypeScript, ""interface"" can be used as a standalone; // identifier, e.g. in `var interface = 1;`. If ""interface"" is; // followed by another identifier, it is very like to be an actual; // interface declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:205,Integrability,interface,interface,205,"// In JavaScript/TypeScript, ""interface"" can be used as a standalone; // identifier, e.g. in `var interface = 1;`. If ""interface"" is; // followed by another identifier, it is very like to be an actual; // interface declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:26,Security,access,accessor,26,// See if it's a property accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:35,Security,access,accessor,35,// See if we are inside a property accessor.; //; // Record the current tokenPosition so that we can advance and; // reset the current token. `Next` is not set yet so we need; // another way to advance along the token stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:22,Security,access,accessor,22,// A trivial property accessor is of the form:; // { [ACCESS_SPECIFIER] [get]; [ACCESS_SPECIFIER] [set|init] }; // Track these as they do not require line breaks to be introduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:29,Security,access,accessor,29,// Try to parse the property accessor:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:102,Usability,guid,guide,102,// Try to parse the property accessor:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:86,Testability,log,logical,86,"// Specialization of a template with an integer parameter can contain; // arithmetic, logical, comparison and ternary operators.; //; // FIXME: This also accepts sequences of operators that are not in the scope; // of a template argument list.; //; // In a C++ lambda a template type can only occur after an arrow. We use; // this as an heuristic to distinguish between Objective-C expressions; // followed by an `a->b` expression, such as:; // ([obj func:arg] + a->b); // Otherwise the code below would parse as a lambda.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:94,Safety,Detect,Detect,94,"// JavaScript can just have free standing methods and getters/setters in; // object literals. Detect them by a ""{"" following "")"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:160,Availability,error,error,160,"// JavaScript (or more precisely TypeScript) can have semicolons in braced; // lists (in so-called TypeMemberLists). Thus, the semicolon cannot be; // used for error recovery if we have otherwise determined that this is; // a braced list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:166,Availability,recover,recovery,166,"// JavaScript (or more precisely TypeScript) can have semicolons in braced; // lists (in so-called TypeMemberLists). Thus, the semicolon cannot be; // used for error recovery if we have otherwise determined that this is; // a braced list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:166,Safety,recover,recovery,166,"// JavaScript (or more precisely TypeScript) can have semicolons in braced; // lists (in so-called TypeMemberLists). Thus, the semicolon cannot be; // used for error recovery if we have otherwise determined that this is; // a braced list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:34,Availability,error,error,34,"// A ""}"" inside parenthesis is an error if there wasn't a matching ""{"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:34,Availability,error,error,34,"// A ""}"" inside parenthesis is an error if there wasn't a matching ""{"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:11,Testability,assert,assert,11,// Handle `assert #0` and `assert final`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:27,Testability,assert,assert,27,// Handle `assert #0` and `assert final`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Usability,Simpl,Simply,3,// Simply skip until then. This range only contains a value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:42,Testability,assert,assert,42,// The then action is optional in Verilog assert statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:14,Availability,error,error,14,// FIXME: Add error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:2,Integrability,Wrap,WrapRightBrace,2,/*WrapRightBrace=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:14,Availability,error,error,14,// FIXME: Add error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:33,Modifiability,variab,variable,33,// Operators that can follow a C variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:9,Modifiability,variab,variable,9,// Not a variable name nor namespace name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:16,Security,access,access,16,// Consider the access specifier to be a C identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:290,Safety,detect,detects,290,"/// \brief Parses a requires clause.; /// \param RequiresToken The requires keyword token, which starts this clause.; /// \pre We need to be on the next token after the requires keyword.; /// \sa parseRequiresExpression; ///; /// Returns if it either has finished parsing the clause, or it detects, that; /// the clause is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:294,Safety,detect,detects,294,"/// \brief Parses a requires expression.; /// \param RequiresToken The requires keyword token, which starts this clause.; /// \pre We need to be on the next token after the requires keyword.; /// \sa parseRequiresClause; ///; /// Returns if it either has finished parsing the expression, or it detects,; /// that the expression is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:76,Modifiability,variab,variables,76,"// We need to differentiate identifiers for a template deduction guide,; // variables, or function return types (the constraint expression has; // ended before that), and basically all other cases. But it's easier to; // check the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:65,Usability,guid,guide,65,"// We need to differentiate identifiers for a template deduction guide,; // variables, or function return types (the constraint expression has; // ended before that), and basically all other cases. But it's easier to; // check the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:26,Modifiability,variab,variable,26,// Start of a function or variable for the,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:156,Availability,error,error,156,"// In TypeScript, ""enum"" can also be used as property name, e.g. in interface; // declarations. An ""enum"" keyword followed by a colon would be a syntax; // error and thus assume it is just an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:68,Integrability,interface,interface,68,"// In TypeScript, ""enum"" can also be used as property name, e.g. in interface; // declarations. An ""enum"" keyword followed by a colon would be a syntax; // error and thus assume it is just an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:64,Usability,simpl,simple,64,// Double check that the attribute is just something; // fairly simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:161,Integrability,contract,contracted,161,"// Determine whether the enum is simple, i.e. does not have a semicolon or; // constants with class bodies. Simple enums can be formatted like braced; // lists, contracted to a single line, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:33,Usability,simpl,simple,33,"// Determine whether the enum is simple, i.e. does not have a semicolon or; // constants with class bodies. Simple enums can be formatted like braced; // lists, contracted to a single line, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:108,Usability,Simpl,Simple,108,"// Determine whether the enum is simple, i.e. does not have a semicolon or; // constants with class bodies. Simple enums can be formatted like braced; // lists, contracted to a single line, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:95,Usability,simpl,simple,95,"// FIXME: This will also mark enums with braces in the arguments to enum; // constants as ""not simple"". This is probably fine in practice, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:61,Modifiability,extend,extends,61,// JavaScript/TypeScript supports inline object types in; // extends/implements positions:; // class Foo implements {bar: number} { },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:19,Integrability,interface,interface,19,// Useful for e.g. interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:11,Integrability,interface,interfaces,11,"// In ObjC interfaces, nothing should be following the ""}"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Integrability,interface,interface,3,"// interface name; // @interface can be followed by a lightweight generic; // specialization list, then either a base class or a category.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:23,Integrability,interface,interface,23,"// interface name; // @interface can be followed by a lightweight generic; // specialization list, then either a base class or a category.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:106,Integrability,interface,interface,106,"// With instance variables, this puts '}' on its own line. Without instance; // variables, this ends the @interface line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:17,Modifiability,variab,variables,17,"// With instance variables, this puts '}' on its own line. Without instance; // variables, this ends the @interface line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:80,Modifiability,variab,variables,80,"// With instance variables, this puts '}' on its own line. Without instance; // variables, this ends the @interface line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:10,Integrability,protocol,protocol,10,"// Unlike protocol lists, generic parameterizations support; // nested angles:; //; // @interface Foo<ValueType : id <NSCopying, NSSecureCoding>> :; // NSObject <NSCopying, NSSecureCoding>; //; // so we need to count how many open angles we have left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:88,Integrability,interface,interface,88,"// Unlike protocol lists, generic parameterizations support; // nested angles:; //; // @interface Foo<ValueType : id <NSCopying, NSSecureCoding>> :; // NSObject <NSCopying, NSSecureCoding>; //; // so we need to count how many open angles we have left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:34,Modifiability,parameteriz,parameterizations,34,"// Unlike protocol lists, generic parameterizations support; // nested angles:; //; // @interface Foo<ValueType : id <NSCopying, NSSecureCoding>> :; // NSObject <NSCopying, NSSecureCoding>; //; // so we need to count how many open angles we have left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:56,Integrability,protocol,protocol,56,"// Returns true for the declaration/definition form of @protocol,; // false for the expression form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:27,Integrability,protocol,protocol,27,"// The expression form of @protocol, e.g. ""Protocol* p = @protocol(foo);"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:43,Integrability,Protocol,Protocol,43,"// The expression form of @protocol, e.g. ""Protocol* p = @protocol(foo);"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:58,Integrability,protocol,protocol,58,"// The expression form of @protocol, e.g. ""Protocol* p = @protocol(foo);"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:41,Integrability,protocol,protocol,41,"// The definition/declaration form,; // @protocol Foo; // - (int)someMethod;; // @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Integrability,protocol,protocol,3,// protocol name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:13,Integrability,protocol,protocol,13,// Check for protocol declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:47,Integrability,wrap,wrapped,47,"// Common issue: Automatic Semicolon Insertion wrapped the line, so the; // import statement should terminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Modifiability,extend,extends,3,// extends and implements,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:354,Usability,simpl,simply,354,"// Blocks in Verilog can have `begin` and `end` instead of braces. For; // keywords like `begin`, we can't treat them the same as left braces; // because some contexts require one of them. For example structs use; // braces and if blocks use keywords, and a left brace can occur in an if; // statement, but it is not a block. For keywords like `end`, we simply; // treat them the same as right braces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:160,Integrability,interface,interface,160,"/// An unwrapped line is a sequence of \c Token, that we would like to; /// put on a single line if there was no column limit.; ///; /// This is used as a main interface between the \c UnwrappedLineParser and the; /// \c UnwrappedLineFormatter. The key property is that changing the formatting; /// within an unwrapped line does not affect any other unwrapped lines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:4,Integrability,Interface,Interface,4,"/// Interface for users of the UnwrappedLineParser to receive the parsed lines.; /// Parsing a single snippet of code can lead to multiple runs, where each; /// run is a coherent view of the file.; ///; /// For example, different runs are generated:; /// - for different combinations of #if blocks; /// - when macros are involved, for the expanded code and the as-written code; ///; /// Some tokens will only be visible in a subset of the runs.; /// For each run, \c UnwrappedLineParser will call \c consumeUnwrappedLine; /// for each parsed unwrapped line, and then \c finishRun to indicate; /// that the set of unwrapped lines before is one coherent view of the; /// code snippet to be formatted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:11,Security,hash,hash,11,"// Compute hash of the current preprocessor branch.; // This is used to identify the different branches, and thus track if block; // open and close in the same branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:59,Integrability,depend,depending,59,// We store for each line whether it must be a declaration depending on; // whether we are in a compound statement or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h:143,Deployability,update,update,143,// Contains the number of branches per nesting level we are currently; // in while parsing a preprocessor branch sequence.; // This is used to update PPLevelBranchCount at the end of a branch; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp:194,Safety,detect,detects,194,"/// Computes the label of a using declaration starting at tthe using token; /// \p UsingTok.; /// If \p UsingTok doesn't begin a using declaration, returns the empty string.; /// Note that this detects specifically using declarations, as in:; /// using A::B::C;; /// and not type aliases, as in:; /// using A = B::C;; /// Type aliases are in general not safe to permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp:354,Safety,safe,safe,354,"/// Computes the label of a using declaration starting at tthe using token; /// \p UsingTok.; /// If \p UsingTok doesn't begin a using declaration, returns the empty string.; /// Note that this detects specifically using declarations, as in:; /// using A::B::C;; /// and not type aliases, as in:; /// using A = B::C;; /// Type aliases are in general not safe to permute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:98,Testability,assert,assertion,98,// FIXME: This is a workaround that should be removed when we fix; // http://llvm.org/PR53699. An assertion later below verifies this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:243,Modifiability,extend,extend,243,"// Walk through a subset of the changes, starting at StartAt, and find; // sequences of matching tokens to align. To do so, keep track of the lines and; // whether or not a matching token was found on a line. If a matching token is; // found, extend the current sequence. If the current line cannot be part of a; // sequence, e.g. because there is an empty line before it or it contains only; // non-matching tokens, finalize the previous sequence.; // The value returned is the token on which we stopped, either because we; // exhausted all items inside Changes, or because we hit a scope level higher; // than our initial scope.; // This function is recursive. Each invocation processes only the scope level; // equal to the initial level, which is the level of Changes[StartAt].; // If we encounter a scope level greater than the initial level, then we call; // ourselves recursively, thereby avoiding the pollution of the current state; // with the alignment requirements of the nested sub-level. This recursive; // behavior is necessary for aligning function prototypes that have one or more; // arguments.; // If this function encounters a scope level less than the initial level,; // it returns the current position.; // There is a non-obvious subtlety in the recursive behavior: Even though we; // defer processing of nested levels to recursive invocations of this; // function, when it comes time to align a sequence of tokens, we run the; // alignment on the entire sequence, including the nested levels.; // When doing so, most of the nested tokens are skipped, because their; // alignment was already handled by the recursive invocations of this function.; // However, the special exception is that we do NOT skip function parameters; // that are split across multiple lines. See the test case in FormatTest.cpp; // that mentions ""split function parameter alignment"" for an example of this.; // When the parameter RightJustify is true, the operator will be; // right-justified. It is used ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:896,Safety,avoid,avoiding,896,"// Walk through a subset of the changes, starting at StartAt, and find; // sequences of matching tokens to align. To do so, keep track of the lines and; // whether or not a matching token was found on a line. If a matching token is; // found, extend the current sequence. If the current line cannot be part of a; // sequence, e.g. because there is an empty line before it or it contains only; // non-matching tokens, finalize the previous sequence.; // The value returned is the token on which we stopped, either because we; // exhausted all items inside Changes, or because we hit a scope level higher; // than our initial scope.; // This function is recursive. Each invocation processes only the scope level; // equal to the initial level, which is the level of Changes[StartAt].; // If we encounter a scope level greater than the initial level, then we call; // ourselves recursively, thereby avoiding the pollution of the current state; // with the alignment requirements of the nested sub-level. This recursive; // behavior is necessary for aligning function prototypes that have one or more; // arguments.; // If this function encounters a scope level less than the initial level,; // it returns the current position.; // There is a non-obvious subtlety in the recursive behavior: Even though we; // defer processing of nested levels to recursive invocations of this; // function, when it comes time to align a sequence of tokens, we run the; // alignment on the entire sequence, including the nested levels.; // When doing so, most of the nested tokens are skipped, because their; // alignment was already handled by the recursive invocations of this function.; // However, the special exception is that we do NOT skip function parameters; // that are split across multiple lines. See the test case in FormatTest.cpp; // that mentions ""split function parameter alignment"" for an example of this.; // When the parameter RightJustify is true, the operator will be; // right-justified. It is used ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:1796,Testability,test,test,1796,". If a matching token is; // found, extend the current sequence. If the current line cannot be part of a; // sequence, e.g. because there is an empty line before it or it contains only; // non-matching tokens, finalize the previous sequence.; // The value returned is the token on which we stopped, either because we; // exhausted all items inside Changes, or because we hit a scope level higher; // than our initial scope.; // This function is recursive. Each invocation processes only the scope level; // equal to the initial level, which is the level of Changes[StartAt].; // If we encounter a scope level greater than the initial level, then we call; // ourselves recursively, thereby avoiding the pollution of the current state; // with the alignment requirements of the nested sub-level. This recursive; // behavior is necessary for aligning function prototypes that have one or more; // arguments.; // If this function encounters a scope level less than the initial level,; // it returns the current position.; // There is a non-obvious subtlety in the recursive behavior: Even though we; // defer processing of nested levels to recursive invocations of this; // function, when it comes time to align a sequence of tokens, we run the; // alignment on the entire sequence, including the nested levels.; // When doing so, most of the nested tokens are skipped, because their; // alignment was already handled by the recursive invocations of this function.; // However, the special exception is that we do NOT skip function parameters; // that are split across multiple lines. See the test case in FormatTest.cpp; // that mentions ""split function parameter alignment"" for an example of this.; // When the parameter RightJustify is true, the operator will be; // right-justified. It is used to align compound assignments like `+=` and `=`.; // When RightJustify and ACS.PadOperators are true, operators in each block to; // be aligned will be padded on the left to the same length before aligning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:82,Safety,abort,abort,82,"// Measure the scope level (i.e. depth of (), [], {}) of the first token, and; // abort when we hit any token in a higher scope than the starting one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:130,Usability,simpl,simple,130,"// For a macro function, 0 spaces are required between the; // identifier and the lparen that opens the parameter list.; // For a simple macro, 1 space is required between the; // identifier and the first token of the defined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:227,Safety,detect,detecting,227,"// Ignore 'IsInsideToken' to allow matching trailing comments which; // need to be reflowed as that causes the token to appear in two; // different changes, which will cause incorrect alignment as we'll; // reflow early due to detecting multiple aligning tokens per line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:31,Integrability,wrap,wrapped,31,"// Ensure we keep alignment of wrapped operands with non-wrapped operands; // Since we actually align the operators, the wrapped operands need the; // extra offset to be properly aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:57,Integrability,wrap,wrapped,57,"// Ensure we keep alignment of wrapped operands with non-wrapped operands; // Since we actually align the operators, the wrapped operands need the; // extra offset to be properly aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:121,Integrability,wrap,wrapped,121,"// Ensure we keep alignment of wrapped operands with non-wrapped operands; // Since we actually align the operators, the wrapped operands need the; // extra offset to be properly aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:51,Integrability,wrap,wrapped,51,"// Align question operators if next operand is not wrapped, as; // well as wrapped operands after question operator or last; // colon in conditional sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:75,Integrability,wrap,wrapped,75,"// Align question operators if next operand is not wrapped, as; // well as wrapped operands after question operator or last; // colon in conditional sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:249,Testability,log,logic,249,"// Do not generate two replacements for the same location. As a special; // case, it is allowed if there is a replacement for the empty range; // between 2 tokens and another non-empty range at the start of the second; // token. We didn't implement logic to combine replacements for 2; // consecutive source ranges into a single replacement, because the; // program works fine without it.; //; // We can't eliminate empty original whitespace ranges. They appear when; // 2 tokens have no whitespace in between in the input. It does not; // matter whether whitespace is to be added. If no whitespace is to be; // added, the replacement will be empty, and it gets eliminated after this; // step in storeReplacement. For example, if the input is `foo();`,; // there will be a replacement for the range between every consecutive; // pair of tokens.; //; // A replacement at the start of a token can be added by; // BreakableStringLiteralUsingOperators::insertBreak when it adds braces; // around the string literal. Say Verilog code is being formatted and the; // first line is to become the next 2 lines.; // x(""long string"");; // x({""long "",; // ""string""});; // There will be a replacement for the empty range between the parenthesis; // and the string and another replacement for the quote character. The; // replacement for the empty range between the parenthesis and the quote; // comes from ContinuationIndenter::addTokenOnCurrentLine when it changes; // the original empty range between the parenthesis and the string to; // another empty one. The replacement for the quote character comes from; // BreakableStringLiteralUsingOperators::insertBreak when it adds the; // brace. In the example, the replacement for the empty range is the same; // as the original text. However, eliminating replacements that are same; // as the original does not help in general. For example, a newline can; // be inserted, causing the first line to become the next 3 lines.; // xxxxxxxxxxx(""long string"");; // xxxxxx",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:15,Testability,assert,assert,15,// FIXME: This assert should hold if we computed the column correctly.; // assert((int)C.StartOfTokenColumn >= C.Spaces);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:75,Testability,assert,assert,75,// FIXME: This assert should hold if we computed the column correctly.; // assert((int)C.StartOfTokenColumn >= C.Spaces);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:56,Availability,error,error,56,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:81,Deployability,release,release,81,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:62,Integrability,message,message,62,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h:92,Energy Efficiency,adapt,adapted,92,// The number of spaces in front of the token or broken part of the token.; // This will be adapted when aligning tokens.; // Can be negative to retain information about the initial relative offset; // of the lines in a block comment. This is used when aligning trailing; // comments. Uncompensated negative offset is truncated to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h:92,Modifiability,adapt,adapted,92,// The number of spaces in front of the token or broken part of the token.; // This will be adapted when aligning tokens.; // Can be negative to retain information about the initial relative offset; // of the lines in a block comment. This is used when aligning trailing; // comments. Uncompensated negative offset is truncated to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp:33,Safety,avoid,avoid,33,// Don't traverse child nodes to avoid output duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTMerge.cpp:125,Modifiability,variab,variables,125,"// FIXME: This is a hack. We need a better way to communicate the; // AST file, compiler instance, and file name than member variables; // of FrontendAction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:32,Performance,load,load,32,"// We found a remapping. Try to load the resulting, remapped source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:45,Performance,load,load,45,"// If the main source file was not remapped, load it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:63,Availability,error,errors,63,"/// After failing to build a precompiled preamble (due to; /// errors in the source that occurs in the preamble), the number of; /// reparses during which we'll skip even trying to precompile the; /// preamble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:9,Performance,load,loaded,9,"// If we loaded from an AST file, balance out the BeginSourceFile call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:75,Performance,perform,perform,75,// Free the buffers associated with remapped files. We are required to; // perform this operation here because we explicitly request that the; // compiler instance *not* free these buffers for each invocation of the; // parser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:90,Availability,avail,available,90,"// In Objective-C, message sends can send interfaces. In Objective-C++,; // all types are available due to functional casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:19,Integrability,message,message,19,"// In Objective-C, message sends can send interfaces. In Objective-C++,; // all types are available due to functional casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:42,Integrability,interface,interfaces,42,"// In Objective-C, message sends can send interfaces. In Objective-C++,; // all types are available due to functional casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:15,Integrability,interface,interfaces,15,// Objective-C interfaces can be used in a class property expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Usability,Clear,Clear,3,// Clear out the previous results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:42,Performance,cache,cached,42,// Translate global code completions into cached completions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:167,Security,hash,hash,167,"// Determine whether we have already seen this type. If so, we save; // ourselves the work of formatting the type string by using the; // temporary, CanQualType-based hash table to find the associated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:30,Security,hash,hash,30,// Save the current top-level hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:51,Deployability,update,update,51,"// Initialize the FileManager. We can't do this in update(), since that; // performs the initialization too late (once both target and language; // options are read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:76,Performance,perform,performs,76,"// Initialize the FileManager. We can't do this in update(), since that; // performs the initialization too late (once both target and language; // options are read).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:18,Security,access,access,18,"// We didn't have access to the comment options when the ASTContext was; // constructed, so register them now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:4,Modifiability,Config,Configure,4,/// Configure the diagnostics object for use with ASTUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:31,Security,hash,hash,31,/// Add the given macro to the hash of all top-level entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:37,Deployability,update,updates,37,/// Preprocessor callback class that updates a hash value with the names; /// of all macros that have been defined by the translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:47,Security,hash,hash,47,/// Preprocessor callback class that updates a hash value with the names; /// of all macros that have been defined by the translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:51,Security,hash,hash,51,// namespace; /// Add the given declaration to the hash of all top-level entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:55,Security,hash,hash,55,// For an unscoped enum include the enumerators in the hash since they; // enter the top-level namespace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:165,Integrability,interface,interface,165,"// FIXME: Currently ObjC method declarations are incorrectly being; // reported as top-level declarations, even though their DeclContext; // is the containing ObjC @interface/@implementation. This is a; // fundamental problem in the parser right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:165,Integrability,interface,interface,165,"// FIXME: Currently ObjC method declarations are incorrectly being; // reported as top-level declarations, even though their DeclContext; // is the containing ObjC @interface/@implementation. This is a; // fundamental problem in the parser right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:59,Deployability,update,update,59,"// The stored diagnostic has the old source manager in it; update; // the locations to refer into the new source manager. Since we've; // been careful to make sure that the source manager's state; // before and after are identical, so that we can reuse the source; // location itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:161,Availability,failure,failure,161,"/// Parse the source file into a translation unit using the given compiler; /// invocation, replacing the current translation unit.; ///; /// \returns True if a failure occurred that causes the ASTUnit not to; /// contain any translation-unit information, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:15,Availability,error,error,15,"// Clean up on error, disengage it if the function returns successfully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Modifiability,Config,Configure,3,// Configure the various subsystems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:59,Deployability,update,update,59,"// The stored diagnostic has the old source manager in it; update; // the locations to refer into the new source manager. Since we've; // been careful to make sure that the source manager's state; // before and after are identical, so that we can reuse the source; // location itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:321,Energy Efficiency,reduce,reduce,321,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:864,Energy Efficiency,allocate,allocated,864,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:109,Integrability,rout,routine,109,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:415,Integrability,rout,routine,415,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:579,Integrability,rout,routine,579,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:471,Safety,avoid,avoid,471,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:175,Availability,failure,failure,175,"// If the preamble rebuild counter > 1, it's because we previously; // failed to build a preamble and we're not yet ready to try; // again. Decrement the counter and return a failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:157,Performance,cache,cache,157,"// If the hash of top-level entities differs from the hash of the top-level; // entities the last time we rebuilt the preamble, clear out the completion; // cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:10,Security,hash,hash,10,"// If the hash of top-level entities differs from the hash of the top-level; // entities the last time we rebuilt the preamble, clear out the completion; // cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:54,Security,hash,hash,54,"// If the hash of top-level entities differs from the hash of the top-level; // entities the last time we rebuilt the preamble, clear out the completion; // cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:128,Usability,clear,clear,128,"// If the hash of top-level entities differs from the hash of the top-level; // entities the last time we rebuilt the preamble, clear out the completion; // cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Modifiability,Config,Configure,3,// Configure the various subsystems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:57,Performance,cache,cache,57,// Create a file manager object to provide access to and cache the filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:43,Security,access,access,43,// Create a file manager object to provide access to and cache the filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:45,Availability,recover,recovery,45,// Zero out now to ease cleanup during crash recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:45,Safety,recover,recovery,45,// Zero out now to ease cleanup during crash recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:8,Availability,error,error,8,"// Some error occurred, if caller wants to examine diagnostics, pass it the; // ASTUnit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Usability,Clear,Clear,3,// Clear out the diagnostics state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:131,Performance,cache,cache,131,"// If we're caching global code-completion results, and the top-level; // declarations have changed, clear out the code-completion cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:101,Usability,clear,clear,101,"// If we're caching global code-completion results, and the top-level; // declarations have changed, clear out the code-completion cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:18,Usability,clear,clear,18,// We now need to clear out the completion info related to this translation; // unit; it'll be recreated if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:47,Performance,cache,cached,47,"/// Code completion consumer that combines the cached code-completion; /// results from an ASTUnit with the code-completion results provided to it,; /// then passes the result on to",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:55,Performance,cache,cached,55,// Merge the results we were given with the results we cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:25,Performance,cache,cached,25,"// If we did not add any cached completion results, just forward the; // results we were given to the next consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:66,Performance,cache,cached,66,"// Use the code completion consumer we were given, but adding any cached; // code-completion results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:29,Deployability,update,update,29,// FIXME: there is no way to update VFS if it was changed by; // AddImplicitPreamble as FileMgr is accepted as a parameter by this method.; // We use on-disk preambles instead and rely on FileMgr's VFS to ensure the; // PCH files are always readable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:45,Performance,cache,cache,45,"// FIXME: Can we somehow regenerate the stat cache here, or do we need to; // unconditionally create a stat cache when we parse the file?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:108,Performance,cache,cache,108,"// FIXME: Can we somehow regenerate the stat cache here, or do we need to; // unconditionally create a stat cache when we parse the file?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:21,Performance,load,loaded,21,"/// If \arg Loc is a loaded location from the preamble, returns; /// the corresponding local location of the main file, otherwise it returns; /// \arg Loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:115,Performance,load,loaded,115,"/// If \arg Loc is a local location of the main file but inside the; /// preamble chunk, returns the corresponding loaded location from the; /// preamble, otherwise it returns \arg Loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:8,Integrability,depend,dependencies,8,// skip dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:11,Integrability,depend,dependencies,11,// look in dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:11,Integrability,depend,dependencies,11,// look in dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp:504,Testability,test,testing,504,"//===- ChainedIncludesSource.cpp - Chained PCHs in Memory -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ChainedIncludesSource class, which converts headers; // to chained PCHs in memory, mainly used for testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp:258,Availability,down,down,258,"//===--------------------------------------------------------------------===//; // ExternalASTSource interface.; //===--------------------------------------------------------------------===//; /// Return the amount of memory used by memory buffers, breaking down; /// by heap-backed versus mmap'ed memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp:101,Integrability,interface,interface,101,"//===--------------------------------------------------------------------===//; // ExternalASTSource interface.; //===--------------------------------------------------------------------===//; /// Return the amount of memory used by memory buffers, breaking down; /// by heap-backed versus mmap'ed memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ChainedIncludesSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:120,Security,validat,validating,120,"// Check whether this is an AST file. ASTReader::isAcceptableASTFile is not; // used here since we're not interested in validating the PCH at this time,; // but only to check whether this is a file containing an AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:2,Security,Validat,ValidateDiagnosticOptions,2,/*ValidateDiagnosticOptions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:45,Testability,log,log,45,// Chain in the diagnostic client which will log the diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:46,Availability,error,errors,46,// Create the diagnostic client for reporting errors or for; // implementing -verify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:24,Testability,log,log-file,24,"// Chain in -diagnostic-log-file dumper, if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Modifiability,Config,Configure,3,// Configure our handling of diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:24,Modifiability,config,configure,24,// Predefine macros and configure the preprocessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:21,Integrability,depend,dependencies,21,"// Handle generating dependencies, if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:62,Integrability,depend,dependencies,62,"// If we don't have a collector, but we are collecting module dependencies,; // then we're the top level compiler instance and need to create one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:41,Security,hash,hash,41,"// Set up the module path, including the hash for the module-creation options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:132,Performance,load,load,132,// Helper to recursively read the module names for all modules we're adding.; // We mark these as known and redirect any attempt to load that module to; // the files we were handed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:54,Safety,safe,safe,54,// Keep the module name as a string for now. It's not safe to create a new; // IdentifierInfo from an ASTReader callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:18,Availability,avail,available,18,// Mark module as available if the only reason it was unavailable; // was missing headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:17,Availability,failure,failure,17,// Unrecoverable failure: don't even try to process the input file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:50,Availability,error,error,50,// No suitable PCH file could be found. Return an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:23,Integrability,rout,routine,23,// Set up the creation routine for code-completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:50,Performance,load,load,50,"// If we're building a module and are supposed to load API notes,; // notify the API notes manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,Availability,error,errors,10,// Ignore errors that occur when trying to discard the temp file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:172,Availability,avail,available,172,// Mark this point as the bottom of the stack if we don't have somewhere; // better. We generally expect frontend actions to be invoked with (nearly); // DesiredStackSpace available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Modifiability,rewrite,rewriter,3,// rewriter project will change target built-in bool type from its default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Security,Validat,Validate,3,// Validate/process some options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:20,Availability,error,errors,20,// FIXME this drops errors on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:104,Availability,error,errors,104,// We can have multiple diagnostics sharing one diagnostic client.; // Get the total number of warnings/errors from the client.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:22,Modifiability,plugin,plugins,22,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Performance,Load,Load,3,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:30,Modifiability,plugin,plugins,30,// Check if any of the loaded plugins replaces the main AST action,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:23,Performance,load,loaded,23,// Check if any of the loaded plugins replaces the main AST action,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:166,Availability,error,errors,166,"/// Compile a module file for the given module, using the options; /// provided by the importing compiler instance. Returns true if the module; /// was built without errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:55,Energy Efficiency,allocate,allocated,55,"// Make sure that the failed-module structure has been allocated in; // the importing instance, and propagate the pointer to the newly-created; // instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:37,Security,hash,hash,37,// Force implicitly-built modules to hash the content of the module file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:126,Performance,cache,cache,126,"// Construct a compiler instance that will be used to actually create the; // module. Since we're sharing an in-memory module cache,; // CompilerInstance::CompilerInstance is responsible for finalizing the; // buffers to prevent use-after-frees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:79,Safety,detect,detect,79,"// Note that this module is part of the module build stack, so that we; // can detect cycles in the module graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:30,Integrability,depend,dependencies,30,"// If we're collecting module dependencies, we need to share a collector; // between all of the module CompilerInstances. Other than that, we don't; // want to produce any dependency output from the module build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:172,Integrability,depend,dependency,172,"// If we're collecting module dependencies, we need to share a collector; // between all of the module CompilerInstances. Other than that, we don't; // want to produce any dependency output from the module build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Usability,Clear,Clear,3,"// Clear the ASTConsumer if it hasn't been already, in case it owns streams; // that must be closed before clearing output files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:107,Usability,clear,clearing,107,"// Clear the ASTConsumer if it hasn't been already, in case it owns streams; // that must be closed before clearing output files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:68,Availability,error,errors,68,// If \p AllowPCMWithCompilerErrors is set return 'success' even if errors; // occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:198,Availability,error,errors,198,"/// Compile a module file for the given module in a separate compiler instance,; /// using the options provided by the importing compiler instance. Returns true; /// if the module was built without errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:170,Integrability,depend,depending,170,// Canonicalize compilation to start with the public module map. This is; // vital for submodules declarations in the private module maps to be; // correctly parsed when depending on a top level module in the public one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:59,Deployability,update,update,59,"// We've rebuilt a module. If we're allowed to generate or update the global; // module index, record that fact in the importing compiler instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:42,Availability,failure,failures,42,// The caller wants to handle out-of-date failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:37,Availability,error,error,37,"// The ASTReader didn't diagnose the error, so conservatively report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:122,Availability,error,errors,122,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:122,Availability,error,errors,122,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:284,Energy Efficiency,reduce,reduce,284,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:159,Safety,avoid,avoid,159,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:375,Safety,timeout,timeout,375,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:423,Safety,avoid,avoid,423,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:71,Safety,avoid,avoid,71,// FIXME: have LockFileManager return an error_code so that we can; // avoid the mkdir when the directory already exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:155,Availability,error,errors,155,// ModuleCache takes care of correctness and locks are only necessary for; // performance. Fallback to building the module in case of any lock; // related errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:78,Performance,perform,performance,78,// ModuleCache takes care of correctness and locks are only necessary for; // performance. Fallback to building the module in case of any lock; // related errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Usability,Clear,Clear,3,// Clear out any potential leftover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:160,Safety,timeout,timeout,160,"// Since ModuleCache takes care of correctness, we try waiting for; // another process to complete the build so clang does not do it done; // twice. If case of timeout, build it ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Usability,Clear,Clear,3,// Clear the lock file so that future invocations can make progress.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:100,Integrability,depend,depends,100,"// The module may be out of date in the presence of file system races,; // or if one of its imports depends on header search paths that are not; // consistent with this ImportingInstance. Try again...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:122,Availability,error,errors,122,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, potentially using a; /// lock manager to avoid building the same module in multiple compiler; /// instances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:171,Safety,avoid,avoid,171,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, potentially using a; /// lock manager to avoid building the same module in multiple compiler; /// instances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:74,Deployability,configurat,configuration,74,/// Diagnose differences between the current definition of the given; /// configuration macro and the definition provided on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:74,Modifiability,config,configuration,74,/// Diagnose differences between the current definition of the given; /// configuration macro and the definition provided on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:21,Performance,cache,cache,21,/// Prune the module cache of modules that haven't been accessed in; /// a long time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:56,Security,access,accessed,56,/// Prune the module cache of modules that haven't been accessed in; /// a long time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:91,Performance,race condition,race condition,91,"// Write a new timestamp file so that nobody else attempts to prune.; // There is a benign race condition here, if two Clang instances happen to; // notice at the same time that the timestamp is out-of-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:26,Performance,cache,cache,26,"// Walk the entire module cache, looking for unused module files and module; // indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:135,Performance,cache,cache,135,"// If we're implicitly building modules but not currently recursively; // building a module, check whether we need to prune the module cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:52,Availability,error,error,52,"// If -Wmodule-file-config-mismatch is mapped as an error or worse, allow the; // ASTReader to diagnose it, since it can produce better errors that we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:136,Availability,error,errors,136,"// If -Wmodule-file-config-mismatch is mapped as an error or worse, allow the; // ASTReader to diagnose it, since it can produce better errors that we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:20,Modifiability,config,config-mismatch,20,"// If -Wmodule-file-config-mismatch is mapped as an error or worse, allow the; // ASTReader to diagnose it, since it can produce better errors that we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,Performance,load,load,10,// Try to load the module file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:19,Performance,load,loaded,19,// We successfully loaded the module file; remember the set of provided; // modules so that we don't try to load implicit modules for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:108,Performance,load,load,108,// We successfully loaded the module file; remember the set of provided; // modules so that we don't try to load implicit modules for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:60,Performance,load,load,60,// All modules provided by any files we tried and failed to load are now; // unavailable; includes of those modules should now be handled textually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:42,Performance,load,loading,42,// end namespace; /// Select a source for loading the named module and compute the filename to; /// load it from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:100,Performance,load,load,100,// end namespace; /// Select a source for loading the named module and compute the filename to; /// load it from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,Performance,load,load,10,// Try to load the module from the prebuilt module path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,Performance,load,load,10,// Try to load the module from the module cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:42,Performance,cache,cache,42,// Try to load the module from the module cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:38,Performance,load,loading,38,// Select the source and filename for loading the named module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:27,Availability,error,error,27,"// We can't find a module, error out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:26,Performance,load,load,26,// We tried and failed to load a module file for this module. Fall; // back to textual inclusion for its headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:29,Performance,load,load,29,// Time how long it takes to load the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,Performance,load,load,10,"// Try to load the module file. If we are not trying to load from the; // module cache, we don't know how to rebuild modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:56,Performance,load,load,56,"// Try to load the module file. If we are not trying to load from the; // module cache, we don't know how to rebuild modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:81,Performance,cache,cache,81,"// Try to load the module file. If we are not trying to load from the; // module cache, we don't know how to rebuild modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:19,Availability,error,error,19,// Fall through to error out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:187,Availability,error,error,187,"// We don't know the desired configuration for this module and don't; // necessarily even have a module map. Since ReadAST already produces; // diagnostics for these two cases, we simply error out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:29,Deployability,configurat,configuration,29,"// We don't know the desired configuration for this module and don't; // necessarily even have a module map. Since ReadAST already produces; // diagnostics for these two cases, we simply error out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:29,Modifiability,config,configuration,29,"// We don't know the desired configuration for this module and don't; // necessarily even have a module map. Since ReadAST already produces; // diagnostics for these two cases, we simply error out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:180,Usability,simpl,simply,180,"// We don't know the desired configuration for this module and don't; // necessarily even have a module map. Since ReadAST already produces; // diagnostics for these two cases, we simply error out here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:31,Performance,load,loaded,31,"// Okay, we've rebuilt and now loaded the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:125,Availability,redundant,redundant,125,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:57,Performance,cache,cached,57,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:93,Performance,cache,cache,93,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:125,Safety,redund,redundant,125,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:56,Performance,load,load,56,"// If we don't already have information on this module, load the module now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:11,Performance,cache,cached,11,"// Use the cached result, which may be nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:54,Performance,load,load,54,"// If there is a modulemap module or prebuilt module, load it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:14,Performance,perform,perform,14,// Attempt to perform typo correction to find a module name that works.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:18,Usability,clear,clear,18,"// If there was a clear winner, user it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:174,Availability,recover,recover,174,// We have an umbrella header or directory that doesn't actually include; // all of the headers within the directory it covers. Complain about; // this missing submodule and recover by forgetting that we ever saw; // this submodule.; // FIXME: Should we detect this at module load time? It seems fairly; // expensive (and rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:276,Performance,load,load,276,// We have an umbrella header or directory that doesn't actually include; // all of the headers within the directory it covers. Complain about; // this missing submodule and recover by forgetting that we ever saw; // this submodule.; // FIXME: Should we detect this at module load time? It seems fairly; // expensive (and rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:174,Safety,recover,recover,174,// We have an umbrella header or directory that doesn't actually include; // all of the headers within the directory it covers. Complain about; // this missing submodule and recover by forgetting that we ever saw; // this submodule.; // FIXME: Should we detect this at module load time? It seems fairly; // expensive (and rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:254,Safety,detect,detect,254,// We have an umbrella header or directory that doesn't actually include; // all of the headers within the directory it covers. Complain about; // this missing submodule and recover by forgetting that we ever saw; // this submodule.; // FIXME: Should we detect this at module load time? It seems fairly; // expensive (and rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:32,Availability,avail,available,32,// Check whether this module is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:17,Deployability,configurat,configuration,17,// Check for any configuration macros that have changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:17,Modifiability,config,configuration,17,// Check for any configuration macros that have changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating filenames with special characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:21,Modifiability,inherit,inheriting,21,"// Build the module, inheriting any modules that we've built locally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:38,Performance,load,loads,38,// Get an existing global index. This loads it if not already; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:66,Performance,load,loaded,66,// Get an existing global index. This loads it if not already; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor. This code is only used for; // typo correction and drops more than just this one source of errors; // (such as the directory creation failure above). It should handle the; // error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:135,Availability,error,errors,135,// FIXME this drops the error on the floor. This code is only used for; // typo correction and drops more than just this one source of errors; // (such as the directory creation failure above). It should handle the; // error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:178,Availability,failure,failure,178,// FIXME this drops the error on the floor. This code is only used for; // typo correction and drops more than just this one source of errors; // (such as the directory creation failure above). It should handle the; // error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:219,Availability,error,error,219,// FIXME this drops the error on the floor. This code is only used for; // typo correction and drops more than just this one source of errors; // (such as the directory creation failure above). It should handle the; // error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:56,Integrability,message,messages,56,"// For finding modules needing to be imported for fixit messages,; // we need to make the global index cover all modules, so we do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Performance,Load,Load,3,// Load a module as hidden. This also adds it to the global index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:34,Availability,error,error,34,"// FIXME As above, this drops the error on the floor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:63,Availability,error,error,63,"// Look for the symbol in non-imported modules, but only if an error; // actually occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Performance,Load,Load,3,"// Load global module index, or retrieve a previously loaded one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:54,Performance,load,loaded,54,"// Load global module index, or retrieve a previously loaded one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:196,Availability,toler,tolerance,196,"//===----------------------------------------------------------------------===//; // Helpers.; //===----------------------------------------------------------------------===//; // Parse misexpect tolerance argument value.; // Valid option values are integers in the range [0, 100)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:128,Safety,Avoid,Avoid,128,"/// The tblgen-erated code passes in a fifth parameter of an arbitrary type, but; /// denormalizeSimpleFlags never looks at it. Avoid bloating compile-time with; /// unnecessary template instantiations and just ignore it with a variadic; /// argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:55,Safety,avoid,avoid,55,// Capture the extracted value as a lambda argument to avoid potential issues; // with lifetime extension of the reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:351,Availability,error,error,351,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:69,Performance,optimiz,optimizations,69,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:226,Safety,safe,safe,226,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:262,Usability,simpl,simplify,262,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:8,Performance,perform,perform,8,"/// May perform round-trip of command line arguments. By default, the round-trip; /// is enabled in assert builds. This can be overwritten at run-time via the; /// ""-round-trip-args"" and ""-no-round-trip-args"" command line flags, or via the; /// ForceRoundTrip parameter.; ///; /// During round-trip, the command line arguments are parsed into a dummy; /// CompilerInvocation, which is used to generate the command line arguments; /// again. The real CompilerInvocation is then created by parsing the generated; /// arguments, not the original ones. This (in combination with tests covering; /// argument behavior) ensures the generated command line is complete (doesn't; /// drop/mangle any arguments).; ///; /// Finally, we check the command line that was used to create the real; /// CompilerInvocation instance. By default, we compare it to the command line; /// the real CompilerInvocation generates. This checks whether the generator is; /// deterministic. If \p CheckAgainstOriginalInvocation is enabled, we instead; /// compare it to the original command line to verify the original command-line; /// was canonical and can round-trip exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:100,Testability,assert,assert,100,"/// May perform round-trip of command line arguments. By default, the round-trip; /// is enabled in assert builds. This can be overwritten at run-time via the; /// ""-round-trip-args"" and ""-no-round-trip-args"" command line flags, or via the; /// ForceRoundTrip parameter.; ///; /// During round-trip, the command line arguments are parsed into a dummy; /// CompilerInvocation, which is used to generate the command line arguments; /// again. The real CompilerInvocation is then created by parsing the generated; /// arguments, not the original ones. This (in combination with tests covering; /// argument behavior) ensures the generated command line is complete (doesn't; /// drop/mangle any arguments).; ///; /// Finally, we check the command line that was used to create the real; /// CompilerInvocation instance. By default, we compare it to the command line; /// the real CompilerInvocation generates. This checks whether the generator is; /// deterministic. If \p CheckAgainstOriginalInvocation is enabled, we instead; /// compare it to the original command line to verify the original command-line; /// was canonical and can round-trip exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:575,Testability,test,tests,575,"/// May perform round-trip of command line arguments. By default, the round-trip; /// is enabled in assert builds. This can be overwritten at run-time via the; /// ""-round-trip-args"" and ""-no-round-trip-args"" command line flags, or via the; /// ForceRoundTrip parameter.; ///; /// During round-trip, the command line arguments are parsed into a dummy; /// CompilerInvocation, which is used to generate the command line arguments; /// again. The real CompilerInvocation is then created by parsing the generated; /// arguments, not the original ones. This (in combination with tests covering; /// argument behavior) ensures the generated command line is complete (doesn't; /// drop/mangle any arguments).; ///; /// Finally, we check the command line that was used to create the real; /// CompilerInvocation instance. By default, we compare it to the command line; /// the real CompilerInvocation generates. This checks whether the generator is; /// deterministic. If \p CheckAgainstOriginalInvocation is enabled, we instead; /// compare it to the original command line to verify the original command-line; /// was canonical and can round-trip exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:36,Usability,simpl,simply,36,"// If round-trip was not requested, simply run the parser with the real; // invocation diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:230,Availability,down,down,230,"// Run the second parse, now on the generated arguments, and with the real; // invocation and diagnostics. The result is what we will end up using for the; // rest of compilation, so if Generate is not inverse of Parse, something down; // the line will break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:29,Deployability,configurat,configuration,29,"// Parse the Static Analyzer configuration. If \p Diags is set to nullptr,; // it won't verify the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:29,Modifiability,config,configuration,29,"// Parse the Static Analyzer configuration. If \p Diags is set to nullptr,; // it won't verify the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:26,Safety,avoid,avoid,26,// Sort options by key to avoid relying on StringMap iteration order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:80,Availability,redundant,redundant,80,// Don't generate anything that came from parseAnalyzerConfigs. It would be; // redundant and may not be valid on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:80,Safety,redund,redundant,80,// Don't generate anything that came from parseAnalyzerConfigs. It would be; // redundant and may not be valid on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:27,Deployability,configurat,configuration,27,// Go through the analyzer configuration options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:27,Modifiability,config,configuration,27,// Go through the analyzer configuration options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:41,Modifiability,config,config,41,"// We can have a list of comma separated config names, e.g:; // '-analyzer-config key1=val1,key2=val2'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:75,Modifiability,config,config,75,"// We can have a list of comma separated config names, e.g:; // '-analyzer-config key1=val1,key2=val2'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:95,Modifiability,config,configs,95,"// TODO: Check checker options too, possibly in CheckerRegistry.; // Leave unknown non-checker configs unclaimed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:45,Modifiability,config,configtable,45,"// TODO: There's no need to store the entire configtable, it'd be plenty; // enough to store checker options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:37,Modifiability,config,configured,37,"// At this point, AnalyzerOptions is configured. Let's validate some options.; // FIXME: Here we try to validate the silenced checkers or packages are valid.; // The current approach only validates the registered checkers which does not; // contain the runtime enabled checkers and optimally we would validate both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:55,Security,validat,validate,55,"// At this point, AnalyzerOptions is configured. Let's validate some options.; // FIXME: Here we try to validate the silenced checkers or packages are valid.; // The current approach only validates the registered checkers which does not; // contain the runtime enabled checkers and optimally we would validate both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:104,Security,validat,validate,104,"// At this point, AnalyzerOptions is configured. Let's validate some options.; // FIXME: Here we try to validate the silenced checkers or packages are valid.; // The current approach only validates the registered checkers which does not; // contain the runtime enabled checkers and optimally we would validate both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:188,Security,validat,validates,188,"// At this point, AnalyzerOptions is configured. Let's validate some options.; // FIXME: Here we try to validate the silenced checkers or packages are valid.; // The current approach only validates the registered checkers which does not; // contain the runtime enabled checkers and optimally we would validate both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:301,Security,validat,validate,301,"// At this point, AnalyzerOptions is configured. Let's validate some options.; // FIXME: Here we try to validate the silenced checkers or packages are valid.; // The current approach only validates the registered checkers which does not; // contain the runtime enabled checkers and optimally we would validate both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:172,Availability,avail,available,172,// Currently memprof profiles are only added at the IR level. Mark the profile; // type as IR in that case as well and the subsequent matching needs to detect; // which is available (might be one or both).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:152,Safety,detect,detect,152,// Currently memprof profiles are only added at the IR level. Mark the profile; // type as IR in that case as well and the subsequent matching needs to detect; // which is available (might be one or both).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Usability,Simpl,SimplifyLibCalls,3,// SimplifyLibCalls is set only in the absence of -fno-builtin and; // -ffreestanding. We'll consider that when generating them.; // NoBuiltinFuncs are generated by LangOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:10,Performance,optimiz,optimization,10,"// If the optimization level is not supported, fall back on the default; // optimization",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:76,Performance,optimiz,optimization,76,"// If the optimization level is not supported, fall back on the default; // optimization",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:116,Modifiability,variab,variable,116,"// The key paths of codegen options defined in Options.td start with; // ""CodeGenOpts."". Let's provide the expected variable name and type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:24,Integrability,depend,depend,24,// Some codegen options depend on language options. Let's provide the expected; // variable name and type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:83,Modifiability,variab,variable,83,// Some codegen options depend on language options. Let's provide the expected; // variable name and type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:72,Performance,optimiz,optimization,72,// Explicit inlining flags can disable some or all inlining even at; // optimization levels above zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:31,Security,access,access-external-data,31,// PIC defaults to -fno-direct-access-external-data while non-PIC defaults to; // -fdirect-access-external-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:91,Security,access,access-external-data,91,// PIC defaults to -fno-direct-access-external-data while non-PIC defaults to; // -fdirect-access-external-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:188,Modifiability,variab,variables,188,"// Since the storage mapping class is specified per csect,; // without using data sections, it is less effective to use read-only; // pointers. Using read-only pointers may cause other RO variables in the; // same csect to become RW when the linker acts upon `-bforceimprw`;; // therefore, we require that separate data sections; // are used when `-mxcoff-roptr` is in effect. We respect the setting of; // data-sections since we have not found reasons to do otherwise that; // overcome the user surprise of not respecting the setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:63,Availability,avail,available,63,"// If the user requested a flag that requires source locations available in; // the backend, make sure that the backend tracks source location information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:20,Availability,recover,recover,20,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:20,Safety,recover,recover,20,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:72,Security,sanitiz,sanitizers,72,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Security,Sanitiz,Sanitizer,3,// Sanitizer ignorelist arguments are generated from LanguageOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:38,Integrability,depend,dependencies,38,"// Add sanitizer ignorelists as extra dependencies.; // They won't be discovered by the regular preprocessor, so; // we let make / ninja to know about this implicit dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:165,Integrability,depend,dependency,165,"// Add sanitizer ignorelists as extra dependencies.; // They won't be discovered by the regular preprocessor, so; // we let make / ninja to know about this implicit dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:7,Security,sanitiz,sanitizer,7,"// Add sanitizer ignorelists as extra dependencies.; // They won't be discovered by the regular preprocessor, so; // we let make / ninja to know about this implicit dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:19,Integrability,depend,dependencies,19,// -fprofile-list= dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:23,Integrability,depend,dependencies,23,// Propagate the extra dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:38,Performance,Optimiz,OptimizationRemark,38,// These arguments are generated from OptimizationRemark fields of; // CodeGenOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:44,Modifiability,variab,variable,44,"// If the user set the NO_COLOR environment variable, we'll honor that; // unless the command line overrides it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:82,Availability,error,errors,82,"// We ignore MissingArgCount and the return value of ParseDiagnosticArgs.; // Any errors that would be diagnosed here will also be diagnosed later,; // when the DiagnosticsEngine actually exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:123,Modifiability,variab,variable,123,"// The key paths of diagnostic options defined in Options.td start with; // ""DiagnosticOpts->"". Let's provide the expected variable name and type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:114,Availability,error,error,114,"/// Parse the argument to the -ftest-module-file-extension; /// command-line argument.; ///; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:123,Modifiability,Plugin,PluginAction,123,"/// Return a table that associates command line option specifiers with the; /// frontend action. Note: The pair {frontend::PluginAction, OPT_plugin} is; /// intentionally missing, as this case is handled separately from other; /// frontend options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:16,Usability,simpl,simple,16,// Generating a simple flag covers most frontend actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Plugin,PluginAction,3,// PluginAction is the only program action handled separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:10,Usability,Simpl,Simplify,10,// FIXME: Simplify the complex 'AST dump' command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:11,Testability,test,testing,11,// Add the testing module file extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Safety,Detect,Detect,3,// Detect and consume the header indicator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:45,Safety,detect,detects,45,"// Add the internal paths from a driver that detects standard include paths.; // Note: Some paths that came from ""-internal-isystem"" arguments may have; // already been generated as ""-isystem"". If that's the case, their position on; // command line was such that this has no semantic impact on include paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:26,Performance,cache,cache-path,26,// Canonicalize -fmodules-cache-path before storing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:45,Safety,detect,detects,45,// Add the internal paths from a driver that detects standard include paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:29,Performance,Optimiz,Optimize,29,"// The arguments used to set Optimize, OptimizeSize and NoInlineDefine are; // generated from CodeGenOptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:39,Performance,Optimiz,OptimizeSize,39,"// The arguments used to set Optimize, OptimizeSize and NoInlineDefine are; // generated from CodeGenOptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:25,Security,Sanitiz,Sanitize,25,// ObjCAAutoRefCount and Sanitize LangOpts are used to setup the; // PassManager in BackendUtil.cpp. They need to be initialized no matter; // what the input type is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:114,Modifiability,variab,variable,114,"// The key paths of codegen options defined in Options.td start with; // ""LangOpts->"". Let's provide the expected variable name and type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:231,Testability,test,testing,231,"// ObjCWeakRuntime tracks whether the runtime supports __weak, not; // whether the feature is actually enabled. This is predominantly; // determined by -fobjc-runtime, but we allow it to be overridden; // from the command line for testing purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:66,Deployability,patch,patch,66,// Check that the version has 1 to 3 components and the minor and patch; // versions fit in two decimal digits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:11,Deployability,Configurat,Configuration,11,// OpenACC Configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:11,Modifiability,Config,Configuration,11,// OpenACC Configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:25,Integrability,depend,dependency,25,// FIXME: Eliminate this dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:48,Integrability,depend,depends,48,"// This is the __NO_INLINE__ define, which just depends on things like the; // optimization level and -fno-inline, not actually whether the backend has; // inlining enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:79,Performance,optimiz,optimization,79,"// This is the __NO_INLINE__ define, which just depends on things like the; // optimization level and -fno-inline, not actually whether the backend has; // inlining enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Availability,Error,Error,3,// Error if -mvscale-min is unbounded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Security,Validat,Validate,3,// Validate options for HLSL,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:39,Testability,log,logical,39,// TODO: Revisit restricting SPIR-V to logical once we've figured out how to; // handle PhysicalStorageBuffer64 memory model,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:157,Availability,error,error,157,"// Always avoid lexing editor placeholders when we're just running the; // preprocessor as we never want to emit the; // ""editor placeholder in source file"" error in PP only mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:10,Safety,avoid,avoid,10,"// Always avoid lexing editor placeholders when we're just running the; // preprocessor as we never want to emit the; // ""editor placeholder in source file"" error in PP only mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:30,Availability,error,error,30,// Check for missing argument error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:9,Availability,error,errors,9,// Issue errors on unknown arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:98,Integrability,depend,depend,98,// FIXME: Override value name discarding when asan or msan is used because the; // backend passes depend on the name of the alloca in order to print out; // names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:6,Security,sanitiz,sanitizer,6,"// If sanitizer is enabled, disable OPT_ffine_grained_bitfield_accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:49,Security,hash,hash,49,"// Note: For QoI reasons, the things we use as a hash here should all be; // dumped via the -module-info flag.; // Start the signature with the compiler version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the language options,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the target options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with preprocessor options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:97,Security,hash,hash,97,"// If we're supposed to ignore this macro for the purposes of modules,; // don't put it into the hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the sysroot and other header search options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the user build path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the module file extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the Swift version for API notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:39,Security,hash,hash,39,"// When compiling with -gmodules, also hash -fdebug-prefix-map as it; // affects the debug info in the PCM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,// Extend the signature with the affecting debug options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Modifiability,Extend,Extend,3,"// Extend the signature with the enabled sanitizers, if at least one is; // enabled. Sanitizers which cannot affect AST generation aren't hashed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:41,Security,sanitiz,sanitizers,41,"// Extend the signature with the enabled sanitizers, if at least one is; // enabled. Sanitizers which cannot affect AST generation aren't hashed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:85,Security,Sanitiz,Sanitizers,85,"// Extend the signature with the enabled sanitizers, if at least one is; // enabled. Sanitizers which cannot affect AST generation aren't hashed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:138,Security,hash,hashed,138,"// Extend the signature with the enabled sanitizers, if at least one is; // enabled. Sanitizers which cannot affect AST generation aren't hashed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp:43,Integrability,wrap,wrapped,43,// On MacOSX real actions may end up being wrapped in BindArchAction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:9,Integrability,Depend,DependencyFile,9,"//===--- DependencyFile.cpp - Generate dependency file --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates dependency files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:39,Integrability,depend,dependency,39,"//===--- DependencyFile.cpp - Generate dependency file --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates dependency files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:403,Integrability,depend,dependency,403,"//===--- DependencyFile.cpp - Generate dependency file --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates dependency files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:3,Integrability,Depend,Dependency,3,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:124,Integrability,depend,depended,124,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:180,Integrability,depend,dependency,180,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:109,Integrability,depend,dependency,109,"/// Print the filename, with escaping or quoting that accommodates the three; /// most likely tools that use dependency files: GNU Make, BSD Make, and; /// NMake/Jom.; ///; /// BSD Make is the simplest case: It does no escaping at all. This means; /// characters that are normally delimiters, i.e. space and # (the comment; /// character) simply aren't supported in filenames.; ///; /// GNU Make does allow space and # in filenames, but to avoid being treated; /// as a delimiter or comment, these must be escaped with a backslash. Because; /// backslash is itself the escape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:1757,Integrability,depend,dependency,1757,"scape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// original string, which probably doesn't exist either; in any case it won't; /// find; /// a\ b\#c.h; /// which is the actual filename specified by the include directive.; ///; /// Clang does what GCC does, rather than what GNU Make expects.; ///; /// NMake/Jom has a different set of scary characters, but wraps filespecs in; /// double-quotes to avoid misinterpreting them; see; /// https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx for NMake info,; /// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx; /// for Windows file-naming info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:2302,Integrability,wrap,wraps,2302,"scape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// original string, which probably doesn't exist either; in any case it won't; /// find; /// a\ b\#c.h; /// which is the actual filename specified by the include directive.; ///; /// Clang does what GCC does, rather than what GNU Make expects.; ///; /// NMake/Jom has a different set of scary characters, but wraps filespecs in; /// double-quotes to avoid misinterpreting them; see; /// https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx for NMake info,; /// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx; /// for Windows file-naming info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:440,Safety,avoid,avoid,440,"/// Print the filename, with escaping or quoting that accommodates the three; /// most likely tools that use dependency files: GNU Make, BSD Make, and; /// NMake/Jom.; ///; /// BSD Make is the simplest case: It does no escaping at all. This means; /// characters that are normally delimiters, i.e. space and # (the comment; /// character) simply aren't supported in filenames.; ///; /// GNU Make does allow space and # in filenames, but to avoid being treated; /// as a delimiter or comment, these must be escaped with a backslash. Because; /// backslash is itself the escape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:2343,Safety,avoid,avoid,2343,"scape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// original string, which probably doesn't exist either; in any case it won't; /// find; /// a\ b\#c.h; /// which is the actual filename specified by the include directive.; ///; /// Clang does what GCC does, rather than what GNU Make expects.; ///; /// NMake/Jom has a different set of scary characters, but wraps filespecs in; /// double-quotes to avoid misinterpreting them; see; /// https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx for NMake info,; /// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx; /// for Windows file-naming info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:193,Usability,simpl,simplest,193,"/// Print the filename, with escaping or quoting that accommodates the three; /// most likely tools that use dependency files: GNU Make, BSD Make, and; /// NMake/Jom.; ///; /// BSD Make is the simplest case: It does no escaping at all. This means; /// characters that are normally delimiters, i.e. space and # (the comment; /// character) simply aren't supported in filenames.; ///; /// GNU Make does allow space and # in filenames, but to avoid being treated; /// as a delimiter or comment, these must be escaped with a backslash. Because; /// backslash is itself the escape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:339,Usability,simpl,simply,339,"/// Print the filename, with escaping or quoting that accommodates the three; /// most likely tools that use dependency files: GNU Make, BSD Make, and; /// NMake/Jom.; ///; /// BSD Make is the simplest case: It does no escaping at all. This means; /// characters that are normally delimiters, i.e. space and # (the comment; /// character) simply aren't supported in filenames.; ///; /// GNU Make does allow space and # in filenames, but to avoid being treated; /// as a delimiter or comment, these must be escaped with a backslash. Because; /// backslash is itself the escape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:172,Integrability,depend,dependency,172,"// Add quotes if needed. These are the characters listed as ""special"" to; // NMake, that are legal in a Windows filespec, and that could cause; // misinterpretation of the dependency string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:17,Integrability,depend,dependency,17,"// Write out the dependency targets, trying to avoid overly long; // lines when possible. We try our best to emit exactly the same; // dependency file as GCC>=10, assuming the included files are the; // same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:135,Integrability,depend,dependency,135,"// Write out the dependency targets, trying to avoid overly long; // lines when possible. We try our best to emit exactly the same; // dependency file as GCC>=10, assuming the included files are the; // same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:47,Safety,avoid,avoid,47,"// Write out the dependency targets, trying to avoid overly long; // lines when possible. We try our best to emit exactly the same; // dependency file as GCC>=10, assuming the included files are the; // same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:16,Integrability,depend,dependency,16,"// Now add each dependency in the order it was seen, but avoiding; // duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:57,Safety,avoid,avoiding,57,"// Now add each dependency in the order it was seen, but avoiding; // duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp:9,Integrability,Depend,DependencyGraph,9,"//===--- DependencyGraph.cpp - Generate dependency file -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates a header dependency graph in DOT format, for use; // with, e.g., GraphViz.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp:40,Integrability,depend,dependency,40,"//===--- DependencyGraph.cpp - Generate dependency file -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates a header dependency graph in DOT format, for use; // with, e.g., GraphViz.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp:412,Integrability,depend,dependency,412,"//===--- DependencyGraph.cpp - Generate dependency file -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code generates a header dependency graph in DOT format, for use; // with, e.g., GraphViz.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:59,Integrability,message,message,59,"// If we have no source location, just emit the diagnostic message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:36,Integrability,message,message,36,"// Next, emit the actual diagnostic message and caret.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:113,Integrability,rout,routine,113,/// Prints an include stack when appropriate for a particular; /// diagnostic level and location.; ///; /// This routine handles all the logic of suppressing particular include; /// stacks (such as those for notes) and duplicate include stacks when; /// repeated warnings occur within the same file. It also handles the logic; /// of customizing the formatting and display of the include stack.; ///; /// \param Loc The diagnostic location.; /// \param PLoc The presumed location of the diagnostic location.; /// \param Level The diagnostic level of the message this stack pertains to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:554,Integrability,message,message,554,/// Prints an include stack when appropriate for a particular; /// diagnostic level and location.; ///; /// This routine handles all the logic of suppressing particular include; /// stacks (such as those for notes) and duplicate include stacks when; /// repeated warnings occur within the same file. It also handles the logic; /// of customizing the formatting and display of the include stack.; ///; /// \param Loc The diagnostic location.; /// \param PLoc The presumed location of the diagnostic location.; /// \param Level The diagnostic level of the message this stack pertains to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:137,Testability,log,logic,137,/// Prints an include stack when appropriate for a particular; /// diagnostic level and location.; ///; /// This routine handles all the logic of suppressing particular include; /// stacks (such as those for notes) and duplicate include stacks when; /// repeated warnings occur within the same file. It also handles the logic; /// of customizing the formatting and display of the include stack.; ///; /// \param Loc The diagnostic location.; /// \param PLoc The presumed location of the diagnostic location.; /// \param Level The diagnostic level of the message this stack pertains to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:320,Testability,log,logic,320,/// Prints an include stack when appropriate for a particular; /// diagnostic level and location.; ///; /// This routine handles all the logic of suppressing particular include; /// stacks (such as those for notes) and duplicate include stacks when; /// repeated warnings occur within the same file. It also handles the logic; /// of customizing the formatting and display of the include stack.; ///; /// \param Loc The diagnostic location.; /// \param PLoc The presumed location of the diagnostic location.; /// \param Level The diagnostic level of the message this stack pertains to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:8,Availability,redundant,redundant,8,// Skip redundant include stacks altogether.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:8,Safety,redund,redundant,8,// Skip redundant include stacks altogether.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:94,Availability,down,down,94,/// Helper to recursively walk up the include stack and print each layer; /// on the way back down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:93,Availability,down,down,93,/// Helper to recursively walk up the import stack and print each layer; /// on the way back down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:92,Availability,error,error,92,"// There is a chance that begin or end is invalid here, for example if; // specific compile error is reported.; // It is possible that the FileID's do not match, if one comes from an; // included file. In this case we can not produce a meaningful source range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:79,Integrability,message,message,79,/// A helper function for emitMacroExpansion to print the; /// macro expansion message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:102,Safety,avoid,avoid,102,// Find the spelling location for the macro definition. We must use the; // spelling location here to avoid emitting a macro backtrace for the note.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:47,Availability,error,error,47,/// Checks deserialized declarations and emits error if a name; /// matches one given in command-line using -error-on-deserialized-decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:109,Availability,error,error-on-deserialized-decl,109,/// Checks deserialized declarations and emits error if a name; /// matches one given in command-line using -error-on-deserialized-decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:17,Modifiability,plugin,plugin,17,// Validate -add-plugin args.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:3,Security,Validat,Validate,3,// Validate -add-plugin args.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:55,Integrability,wrap,wrap,55,// If there are no registered plugins we don't need to wrap the consumer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:30,Modifiability,plugin,plugins,30,// If there are no registered plugins we don't need to wrap the consumer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:56,Modifiability,plugin,plugin,56,"// If this is a code completion run, avoid invoking the plugin consumers",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:37,Safety,avoid,avoid,37,"// If this is a code completion run, avoid invoking the plugin consumers",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:23,Modifiability,plugin,plugins,23,// Collect the list of plugins that go before the main action (in Consumers); // or after it (in AfterConsumers),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:14,Modifiability,plugin,plugins,14,"// This is O(|plugins| * |add_plugins|), but since both numbers are; // way below 50 in practice, that's ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:52,Modifiability,plugin,plugins,52,"// Add to Consumers the main consumer, then all the plugins that go after it",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:14,Modifiability,plugin,plugins,14,"// If we have plugins after the main consumer, which may be the codegen; // action, they likely will need the ASTContext, so don't clear it in the; // codegen action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:131,Usability,clear,clear,131,"// If we have plugins after the main consumer, which may be the codegen; // action, they likely will need the ASTContext, so don't clear it in the; // codegen action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:85,Deployability,update,update,85,/// Collect the set of header includes needed to construct the given; /// module and update the TopHeaders file set of the module.; ///; /// \param Module The module we're collecting includes from.; ///; /// \param Includes Will be augmented with the set of \#includes or \#imports; /// needed to load all of the named headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:297,Performance,load,load,297,/// Collect the set of header includes needed to construct the given; /// module and update the TopHeaders file set of the module.; ///; /// \param Module The module we're collecting includes from.; ///; /// \param Includes Will be augmented with the set of \#includes or \#imports; /// needed to load all of the named headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:3,Performance,Load,Load,3,// Load the module map file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:149,Safety,detect,detect,149,"// If we're being run from the command-line, the module build stack will not; // have been filled in yet, so complete it now in order to allow us to detect; // module cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:136,Deployability,release,release,136,"// If we fail, reset state since the client will not end up calling the; // matching EndSourceFile(). All paths that return true should release this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:83,Modifiability,inherit,inherited,83,// Options relating to how we treat the input (but not what we do with it); // are inherited from the AST unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:32,Performance,load,loaded,32,// Preload all the module files loaded transitively by the AST unit. Also; // load all module map files that were parsed as part of building the AST; // unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:78,Performance,load,load,78,// Preload all the module files loaded transitively by the AST unit. Also; // load all module map files that were parsed as part of building the AST; // unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:63,Performance,load,load,63,"// Set up embedding for any specified files. Do this before we load any; // source files, including the primary module map for the compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:23,Performance,load,load,23,"// If we were asked to load any module map files, do so now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:44,Performance,load,load,44,"// If compiling implementation of a module, load its module map file now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:136,Modifiability,extend,extended,136,"// If modules are enabled, create the AST reader before creating; // any builtins, so that all declarations know that they might be; // extended by an external source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:32,Availability,recover,recover,32,"// FIXME: If this is a problem, recover from it by creating a multiplex; // source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:32,Safety,recover,recover,32,"// FIXME: If this is a problem, recover from it by creating a multiplex; // source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:23,Performance,load,load,23,"// If we were asked to load any module files, do so now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:107,Availability,failure,failures,107,"// If we are supposed to rebuild the global module index, do so now unless; // there were any module-build failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:24,Availability,error,error,24,"// FIXME this drops the error on the floor, but; // Index/pch-from-libclang.c seems to rely on dropping at least some of; // the error conditions!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:129,Availability,error,error,129,"// FIXME this drops the error on the floor, but; // Index/pch-from-libclang.c seems to rely on dropping at least some of; // the error conditions!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:102,Safety,avoid,avoid,102,// The resources are owned by AST when the current file is AST.; // So we reset the resources here to avoid users accessing it; // accidently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:114,Security,access,accessing,114,// The resources are owned by AST when the current file is AST.; // So we reset the resources here to avoid users accessing it; // accidently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:19,Security,expose,exposed,19,// Because this is exposed via libclang we must disable RemoveFileOnSignal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:91,Performance,cache,cache,91,"// If no output file was provided, figure out where this module would go; // in the module cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:19,Security,expose,exposed,19,// Because this is exposed via libclang we must disable RemoveFileOnSignal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:2,Security,Validat,ValidateSystemInputs,2,/*ValidateSystemInputs*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:110,Availability,avail,available,110,// The FrontendAction::BeginSourceFile () method loads the AST so that much; // of the information is already available and modules should have been; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:49,Performance,load,loads,49,// The FrontendAction::BeginSourceFile () method loads the AST so that much; // of the information is already available and modules should have been; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:153,Performance,load,loaded,153,// The FrontendAction::BeginSourceFile () method loads the AST so that much; // of the information is already available and modules should have been; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:50,Safety,avoid,avoid,50,"// Output file may need to be set to 'Binary', to avoid converting Unix style; // line feeds (<LF>) to Microsoft style line feeds (<CR><LF>) on Windows.; //; // Look to see what type of line endings the file uses. If there's a; // CRLF, then we won't open the file up in binary mode. If there is; // just an LF or CR, then we will open the file up in binary mode.; // In this fashion, the output format should match the input format, unless; // the input format has inconsistent line endings.; //; // This should be a relatively fast operation since most files won't have; // all of their source code on a single line. However, that is still a; // concern, so if we scan for too long, we'll just assume the file should; // be opened in binary mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:348,Energy Efficiency,reduce,reduce,348,"/// A callback for emitting header usage information to a file in JSON. Each; /// line in the file is a JSON object that includes the source file name and; /// the list of headers directly or indirectly included from it. For example:; ///; /// {""source"":""/tmp/foo.c"",; /// ""includes"":[""/usr/include/stdio.h"", ""/usr/include/stdlib.h""]}; ///; /// To reduce the amount of data written to the file, we only record system; /// headers that are directly included from a file that isn't in the system; /// directory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:34,Safety,avoid,avoid,34,// Write to a temporary string to avoid unnecessary flushing on errs().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:183,Integrability,depend,dependencies,183,"// Print header info for extra headers, pretending they were discovered by; // the regular preprocessor. The primary use case is to support proper; // generation of Make / Ninja file dependencies for implicit includes, such; // as sanitizer ignorelists. It's only important for cl.exe compatibility,; // the GNU way to generate rules is -M / -MM / -MD / -MMD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:231,Security,sanitiz,sanitizer,231,"// Print header info for extra headers, pretending they were discovered by; // the regular preprocessor. The primary use case is to support proper; // generation of Make / Ninja file dependencies for implicit includes, such; // as sanitizer ignorelists. It's only important for cl.exe compatibility,; // the GNU way to generate rules is -M / -MM / -MD / -MMD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:72,Availability,robust,robust,72,"// Ignore indent from <built-in>.; // FIXME: Identify headers in a more robust way than comparing their name to; // ""<command line>"" and ""<built-in>"" in a bunch of places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:186,Testability,log,logic,186,/// AddImplicitInclude - Add an implicit \#include of the specified file to the; /// predefines buffer.; /// As these includes are generated by -include arguments the header search; /// logic is going to search relatively to the current working directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:58,Safety,avoid,avoid,58,// We only want the *_WIDTH macro for the signed types to avoid too many; // predefined macros (the unsigned width and the signed width are identical.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:58,Safety,avoid,avoid,58,// We only want the *_WIDTH macro for the signed types to avoid too many; // predefined macros (the unsigned width and the signed width are identical.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:18,Energy Efficiency,power,power-of-,18,"// Fully-aligned, power-of-2 sizes no larger than the inline; // width will be inlined as lock-free operations.; // Note: we do not need to check alignment since _Atomic(T) is always; // appropriately-aligned in clang.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:30,Availability,avail,available,30,"// Not ""standard"" per se, but available even with the -undef flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:233,Testability,test,tested,233,"// FIXME: When we have full support for OpenACC, we should set this to the; // version we support. Until then, set as '1' by default, but provide a; // temporary mechanism for users to override this so real-world examples can; // be tested against.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:51,Testability,test,test,51,"/// Initialize the predefined C++ language feature test macros defined in; /// ISO/IEC JTC1/SC22/WG21 (C++) SD-6: ""SG10 Feature Test Recommendations"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:128,Testability,Test,Test,128,"/// Initialize the predefined C++ language feature test macros defined in; /// ISO/IEC JTC1/SC22/WG21 (C++) SD-6: ""SG10 Feature Test Recommendations"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:112,Testability,test,test,112,"// We provide those C++23 features as extensions in earlier language modes, so; // we also define their feature test macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:52,Availability,avail,available,52,// Check if extension is supported by target and is available in this; // OpenCL version,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:17,Deployability,patch,patch,17,"// Major, minor, patch, are given two decimal places each, so 4.2.1 becomes; // 40201.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:57,Integrability,depend,dependent,57,// darwin_constant_cfstrings controls this. This is also dependent; // on other things like the runtime I believe. This is set even for C code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:160,Deployability,update,updated,160,"// Macros to help identify the narrow and wide character sets; // FIXME: clang currently ignores -fexec-charset=. If this changes,; // then this may need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:115,Deployability,update,updated,115,"// FIXME: Less-than 32-bit wchar_t generally means UTF-16; // (e.g., Windows, 32-bit IBM). This may need to be; // updated if -fwide-exec-charset= is ever supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:73,Integrability,depend,dependent,73,// The value written by __atomic_test_and_set.; // FIXME: This is target-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:54,Integrability,wrap,wrapper,54,"// We need to communicate this to our CUDA/HIP header wrapper, which in turn; // informs the proper CUDA/HIP headers of this choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:12,Modifiability,extend,extended,12,"// For each extended integer type, g++ defines a macro mapping the; // index of the type (0 in this case) in some list of extended types; // to the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:122,Modifiability,extend,extended,122,"// For each extended integer type, g++ defines a macro mapping the; // index of the type (0 in this case) in some list of extended types; // to the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:3,Deployability,Install,Install,3,"// Install things like __POWERPC__, __GNUC__, etc into the macro table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:3,Deployability,Install,Install,3,// Install definitions to make Objective-C++ ARC work well with various; // C++ Standard Library implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:153,Deployability,configurat,configuration,153,"// Even with predefines off, some macros are still predefined.; // These should all be defined in the preprocessor according to the; // current language configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:153,Modifiability,config,configuration,153,"// Even with predefines off, some macros are still predefined.; // These should all be defined in the preprocessor according to the; // current language configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:42,Integrability,Wrap,Wrap,42,// Add on the predefines from the driver. Wrap in a #line directive to report; // that they come from the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:9,Integrability,Interface,InterfaceStubFunctionsConsumer,9,"//===--- InterfaceStubFunctionsConsumer.cpp -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:478,Security,expose,expose,478,"// Here we filter out anything that's not set to DefaultVisibility.; // DefaultVisibility is set on a decl when -fvisibility is not specified on; // the command line (or specified as default) and the decl does not have; // __attribute__((visibility(""hidden""))) set or when the command line; // argument is set to hidden but the decl explicitly has; // __attribute__((visibility (""default""))) set. We do this so that the user; // can have fine grain control of what they want to expose in the stub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:492,Testability,stub,stub,492,"// Here we filter out anything that's not set to DefaultVisibility.; // DefaultVisibility is set on a decl when -fvisibility is not specified on; // the command line (or specified as default) and the decl does not have; // __attribute__((visibility(""hidden""))) set or when the command line; // argument is set to hidden but the decl explicitly has; // __attribute__((visibility (""default""))) set. We do this so that the user; // can have fine grain control of what they want to expose in the stub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:33,Integrability,depend,dependent,33,// Bail on any VarDecl that is a dependent or templated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:9,Integrability,interface,interface,9,"// While interface stubs are in the development stage, it's probably best to; // catch anything that's not a VarDecl or Template/FunctionDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp:19,Testability,stub,stubs,19,"// While interface stubs are in the development stage, it's probably best to; // catch anything that's not a VarDecl or Template/FunctionDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InterfaceStubFunctionsConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LayoutOverrideSource.cpp:12,Usability,simpl,simple,12,/// Parse a simple identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LayoutOverrideSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LayoutOverrideSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:9,Testability,Log,LogDiagnosticPrinter,9,"//===--- LogDiagnosticPrinter.cpp - Log Diagnostic Printer ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:36,Testability,Log,Log,36,"//===--- LogDiagnosticPrinter.cpp - Log Diagnostic Printer ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:14,Integrability,message,message,14,// Format the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:35,Availability,avail,available,35,// At least print the file name if available:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:56,Integrability,depend,dependencies,56,"//===--- ModuleDependencyCollector.cpp - Collect module dependencies ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Collect the dependencies of a set of modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:395,Integrability,depend,dependencies,395,"//===--- ModuleDependencyCollector.cpp - Collect module dependencies ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Collect the dependencies of a set of modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:146,Performance,cache,cache,146,// Do not rely on real path names when executing the crash reproducer scripts; // since we only want to actually use the files we have on the VFS cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:78,Performance,cache,cache,78,// The common case is to map the virtual path to the same path inside the; // cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:91,Performance,cache,cache,91,"// When collecting entries from input vfsoverlays, copy the external; // contents into the cache but still map from the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp:304,Availability,error,errors,304,"// Always map a canonical src path to its real path into the YAML, by doing; // this we map different virtual src paths to the same entry in the VFS; // overlay, which is a way to emulate symlink inside the VFS; this is also; // needed for correctness, not doing that can lead to module redefinition; // errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ModuleDependencyCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:60,Availability,avail,available,60,"// We want only the PCH file from the real filesystem to be available,; // so we create an in-memory VFS with just that and overlay it on top.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:26,Integrability,depend,dependencies,26,"// We want to collect all dependencies for correctness. Avoiding the real; // system dependencies (e.g. stl from /usr/lib) would probably be a good idea,; // but there is no way to distinguish between those and the ones that can be; // spuriously added by '-isystem' (e.g. to suppress warnings from those; // headers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:85,Integrability,depend,dependencies,85,"// We want to collect all dependencies for correctness. Avoiding the real; // system dependencies (e.g. stl from /usr/lib) would probably be a good idea,; // but there is no way to distinguish between those and the ones that can be; // spuriously added by '-isystem' (e.g. to suppress warnings from those; // headers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:56,Safety,Avoid,Avoiding,56,"// We want to collect all dependencies for correctness. Avoiding the real; // system dependencies (e.g. stl from /usr/lib) would probably be a good idea,; // but there is no way to distinguish between those and the ones that can be; // spuriously added by '-isystem' (e.g. to suppress warnings from those; // headers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:106,Security,validat,validating,106,"// Collects files whose existence would invalidate the preamble.; // Collecting *all* of these would make validating it too slow though, so we; // just find all the candidates for 'file not found' diagnostics.; //; // A caveat that may be significant for generated files: we'll omit files under; // search path entries whose roots don't exist when the preamble is built.; // These are pruned by InitHeaderSearch and so we don't see the search path.; // It would be nice to include them but we don't want to duplicate all the rest; // of the InitHeaderSearch logic to reconstruct them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:558,Testability,log,logic,558,"// Collects files whose existence would invalidate the preamble.; // Collecting *all* of these would make validating it too slow though, so we; // just find all the candidates for 'file not found' diagnostics.; //; // A caveat that may be significant for generated files: we'll omit files under; // search path entries whose roots don't exist when the preamble is built.; // These are pruned by InitHeaderSearch and so we don't see the search path.; // It would be nice to include them but we don't want to duplicate all the rest; // of the InitHeaderSearch logic to reconstruct them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,Availability,recover,recovered,84,"// File is std::nullopt if it wasn't found.; // (We have some false negatives if PP recovered e.g. <foo> -> ""foo"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,Safety,recover,recovered,84,"// File is std::nullopt if it wasn't found.; // (We have some false negatives if PP recovered e.g. <foo> -> ""foo"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:173,Testability,assert,assertion,173,"// A temp file that would be deleted on destructor call. If destructor is not; // called for any reason, the file will be deleted at static objects'; // destruction.; // An assertion will fire if two TempPCHFiles are created with the same name,; // so it's not intended to be used outside preamble-handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,Availability,recover,recovery,84,"// FIXME: This is a hack so that we can override the preamble file during; // crash-recovery testing, which is the only case where the preamble files; // are not necessarily cleaned up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,Safety,recover,recovery,84,"// FIXME: This is a hack so that we can override the preamble file during; // crash-recovery testing, which is the only case where the preamble files; // are not necessarily cleaned up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:93,Testability,test,testing,93,"// FIXME: This is a hack so that we can override the preamble file during; // crash-recovery testing, which is the only case where the preamble files; // are not necessarily cleaned up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:138,Performance,race condition,race condition,138,"// Using the versions of createTemporaryFile() and; // createUniqueFile() with a file descriptor guarantees; // that we would never get a race condition in a multi-threaded setting; // (i.e., multiple threads getting the same temporary path).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:158,Performance,multi-thread,multi-threaded,158,"// Using the versions of createTemporaryFile() and; // createUniqueFile() with a file descriptor guarantees; // that we would never get a race condition in a multi-threaded setting; // (i.e., multiple threads getting the same temporary path).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:106,Safety,safe,safe,106,"// Shrink in-memory buffers to fit.; // This incurs a copy, but preambles tend to be long-lived.; // Only safe to call once nothing can alias the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:17,Performance,cache,caches,17,// Clear out old caches and data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:3,Usability,Clear,Clear,3,// Clear out old caches and data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:57,Performance,cache,cache,57,// Create a file manager object to provide access to and cache the filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:43,Security,access,access,43,// Create a file manager object to provide access to and cache the filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:104,Deployability,release,release,104,"// In that case, remapped buffer will be deleted by CompilerInstance on; // BeginSourceFile, so we call release() to avoid double deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:117,Safety,avoid,avoid,117,"// In that case, remapped buffer will be deleted by CompilerInstance on; // BeginSourceFile, so we call release() to avoid double deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:3,Performance,Perform,Performed,3,// Performed after BeginSourceFile to ensure Clang->Preprocessor can be; // referenced in the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:85,Energy Efficiency,reduce,reduces,85,// Shrinking the storage requires extra temporary memory.; // Destroying clang first reduces peak memory usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:3,Modifiability,Config,Configure,3,// Configure ImpicitPCHInclude.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:20,Security,access,access,20,// Make sure we can access the PCH file even if we're using a VFS,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:63,Availability,error,error,63,"// We can't read the file even from RealFS, this is clearly an error,; // but we'll just leave the current VFS as is and let clang's code; // figure out what to do with missing PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:52,Usability,clear,clearly,52,"// We can't read the file even from RealFS, this is clearly an error,; // but we'll just leave the current VFS as is and let clang's code; // figure out what to do with missing PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:78,Security,access,accessible,78,"// For in-memory preamble, we have to provide a VFS overlay that makes it; // accessible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:393,Usability,simpl,simply,393,"//===--- PrintPreprocessedOutput.cpp - Implement the -E mode --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code simply runs the preprocessor on the input file and prints out the; // result. This is the traditional behavior of the -E option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:299,Integrability,depend,depend,299,"/// Insert whitespace before emitting the next token.; ///; /// @param Tok Next token to be emitted.; /// @param RequireSpace Ensure at least one whitespace is emitted. Useful; /// if non-tokens have been emitted to the stream.; /// @param RequireSameLine Never emit newlines. Useful when semantics depend; /// on being on the same line, such as directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:473,Integrability,depend,depends,473,"/// Move to the line of the provided source location. This will; /// return true if a newline was inserted or if; /// the requested location is the first token on the first line.; /// In these cases the next output will be the first column on the line and; /// make it possible to insert indention. The newline was inserted; /// implicitly when at the beginning of the file.; ///; /// @param Tok Token where to move to.; /// @param RequireStartOfLine Whether the next line depends on being in the; /// first column, such as a directive.; ///; /// @return Whether column adjustments are necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:45,Integrability,depend,depending,45,// Emit #line directives or GNU line markers depending on what mode we're in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:106,Deployability,Update,Update,106,/// FileChanged - Whenever the preprocessor enters or exits a #include file; /// it invokes this handler. Update our conception of the current source; /// position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:266,Safety,avoid,avoid,266,"// GCC emits the # directive for this directive on the line AFTER the; // directive and emits a bunch of spaces that aren't needed. This is because; // otherwise we will emit a line marker for THIS line, which requires an; // extra blank line after the directive to avoid making all following lines; // off by one. We can do better by simply incrementing NewLine here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:335,Usability,simpl,simply,335,"// GCC emits the # directive for this directive on the line AFTER the; // directive and emits a bunch of spaces that aren't needed. This is because; // otherwise we will emit a line marker for THIS line, which requires an; // extra blank line after the directive to avoid making all following lines; // off by one. We can do better by simply incrementing NewLine here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:225,Availability,down,downstream,225,"// #__include_macros has no effect on a user of a preprocessed source; // file; the only effect is on preprocessing.; //; // FIXME: That's not *quite* true: it causes the module in question to; // be loaded, which can affect downstream diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:200,Performance,load,loaded,200,"// #__include_macros has no effect on a user of a preprocessed source; // file; the only effect is on preprocessing.; //; // FIXME: That's not *quite* true: it causes the module in question to; // be loaded, which can affect downstream diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:3,Safety,Avoid,Avoid,3,// Avoid interpreting hash as a directive under -fpreprocessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:22,Security,hash,hash,22,// Avoid interpreting hash as a directive under -fpreprocessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:46,Security,HASH,HASH,46,"// This hack prevents stuff like:; // #define HASH #; // HASH define foo bar; // From having the # character end up at column 1, which makes it so it; // is not handled as a #define next time through the preprocessor if in; // -fpreprocessed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:57,Security,HASH,HASH,57,"// This hack prevents stuff like:; // #define HASH #; // HASH define foo bar; // From having the # character end up at column 1, which makes it so it; // is not handled as a #define next time through the preprocessor if in; // -fpreprocessed mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:166,Security,hash,hash-prefixed,166,"// Don't print end of directive tokens, since they are typically newlines; // that mess up our line tracking. These come from unknown pre-processor; // directives or hash-prefixed comments in standalone assembly files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:17,Modifiability,config,configured,17,"// After we have configured the preprocessor, enter the main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp:37,Modifiability,Refactor,Refactor,37,// FIXME(llvm-project/issues/57323): Refactor Diagnostic classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp:33,Availability,avail,available,33,// At least add the file name if available:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp:463,Performance,cache,caches,463,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which is sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp:22,Usability,simpl,simplified,22,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which is sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:434,Integrability,message,messages,434,"//===------- SARIFDiagnosticPrinter.cpp - Diagnostic Printer---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This diagnostic client prints out their diagnostic messages in SARIF format.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count). Keeps track of the; // number of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:84,Availability,error,errors,84,// Default implementation (Warnings/errors count). Keeps track of the; // number of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:25,Integrability,message,message,25,// Render the diagnostic message into a temporary buffer eagerly. We'll use; // this later as we add the diagnostic to the SARIF object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:20,Usability,simpl,simpler,20,"// Use a dedicated, simpler path for diagnostics without a valid location.; // This is important as if the location is missing, we may be emitting; // diagnostics in a context that lacks language options, a source manager, or; // other infrastructure necessary when emitting more rich diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:3,Testability,Assert,Assert,3,// Assert that the rest of our infrastructure is setup properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:91,Safety,detect,detect,91,/// Remove old copies of the serialized diagnostics. This is necessary; /// so that we can detect when subprocesses write diagnostics that we should; /// merge into our own.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:48,Availability,down,down,48,/// Whether we've started finishing and tearing down this instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:107,Availability,avail,available,107,"// FIXME: It's slightly absurd to create a new diagnostics engine here, but; // the other options that are available today are worse:; //; // 1. Teach DiagnosticsConsumers to emit diagnostics to the engine they are a; // part of. The DiagnosticsEngine would need to know not to send; // diagnostics back to the consumer that failed. This would require us to; // rework ChainedDiagnosticsConsumer and teach the engine about multiple; // consumers, which is difficult today because most APIs interface with; // consumers rather than the engine itself.; //; // 2. Pass a DiagnosticsEngine to SDiagsWriter on creation - this would need; // to be distinct from the engine the writer was being added to and would; // normally not be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:490,Integrability,interface,interface,490,"// FIXME: It's slightly absurd to create a new diagnostics engine here, but; // the other options that are available today are worse:; //; // 1. Teach DiagnosticsConsumers to emit diagnostics to the engine they are a; // part of. The DiagnosticsEngine would need to know not to send; // diagnostics back to the consumer that failed. This would require us to; // rework ChainedDiagnosticsConsumer and teach the engine about multiple; // consumers, which is difficult today because most APIs interface with; // consumers rather than the engine itself.; //; // 2. Pass a DiagnosticsEngine to SDiagsWriter on creation - this would need; // to be distinct from the engine the writer was being added to and would; // normally not be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:64,Integrability,message,message,64,"// A diagnostic has severity, location (4), category, flag, and message; // size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp:42,Integrability,message,message,42,// A fixit has two locations (4 each) and message size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:8,Testability,Test,TestModuleFileExtension,8,"//===-- TestModuleFileExtension.cpp - Module Extension Tester -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:55,Testability,Test,Tester,55,"//===-- TestModuleFileExtension.cpp - Module Extension Tester -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:3,Integrability,message,message,3,// message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp:11,Integrability,message,message,11,// Write a message into the extension block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h:8,Testability,Test,TestModuleFileExtension,8,"//===-- TestModuleFileExtension.h - Module Extension Tester -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h:53,Testability,Test,Tester,53,"//===-- TestModuleFileExtension.h - Module Extension Tester -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h:37,Testability,test,testing,37,/// A module file extension used for testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TestModuleFileExtension.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:41,Integrability,wrap,wrapping,41,/// Number of spaces to indent when word-wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:586,Deployability,update,updated,586,"/// returns a printable representation of first item from input range; ///; /// This function returns a printable representation of the next item in a line; /// of source. If the next byte begins a valid and printable character, that; /// character is returned along with 'true'.; ///; /// Otherwise, if the next byte begins a valid, but unprintable character, a; /// printable, escaped representation of the character is returned, along with; /// 'false'. Otherwise a printable, escaped representation of the next byte; /// is returned along with 'false'.; ///; /// \note The index is updated to be used with a subsequent call to; /// printableTextForNextCharacter.; ///; /// \param SourceLine The line of source; /// \param I Pointer to byte index,; /// \param TabStop used to expand tabs; /// \return pair(printable text, 'true' iff original text was printable); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:10,Safety,safe,safely,10,// We can safely use the byte offset FixItStart as the column offset; // because the characters up until FixItStart are all ASCII whitespace; // characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:74,Modifiability,extend,extends,74,// Give us extra room for the ellipses; // and any of the caret line that extends past the source,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:107,Safety,Detect,Detect,107,// Skip over any whitespace we see here; we're looking for; // another bit of interesting text.; // FIXME: Detect non-ASCII whitespace characters too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:107,Safety,Detect,Detect,107,// Skip over any whitespace we see here; we're looking for; // another bit of interesting text.; // FIXME: Detect non-ASCII whitespace characters too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:48,Deployability,Update,Update,48,"// [CaretStart, CaretEnd) is the slice we want. Update the various; // output lines to show only this slice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:45,Integrability,wrap,wrapping,45,"/// Print the given string to a stream, word-wrapping it to; /// some number of columns in the process.; ///; /// \param OS the stream to which the word-wrapping string will be; /// emitted.; /// \param Str the string to word-wrap and output.; /// \param Columns the number of columns to word-wrap to.; /// \param Column the column number at which the first character of \p; /// Str will be printed. This will be non-zero when part of the first; /// line has already been printed.; /// \param Bold if the current text should be bold; /// \returns true if word-wrapping was required, or false if the; /// string fit on the first line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:153,Integrability,wrap,wrapping,153,"/// Print the given string to a stream, word-wrapping it to; /// some number of columns in the process.; ///; /// \param OS the stream to which the word-wrapping string will be; /// emitted.; /// \param Str the string to word-wrap and output.; /// \param Columns the number of columns to word-wrap to.; /// \param Column the column number at which the first character of \p; /// Str will be printed. This will be non-zero when part of the first; /// line has already been printed.; /// \param Bold if the current text should be bold; /// \returns true if word-wrapping was required, or false if the; /// string fit on the first line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:226,Integrability,wrap,wrap,226,"/// Print the given string to a stream, word-wrapping it to; /// some number of columns in the process.; ///; /// \param OS the stream to which the word-wrapping string will be; /// emitted.; /// \param Str the string to word-wrap and output.; /// \param Columns the number of columns to word-wrap to.; /// \param Column the column number at which the first character of \p; /// Str will be printed. This will be non-zero when part of the first; /// line has already been printed.; /// \param Bold if the current text should be bold; /// \returns true if word-wrapping was required, or false if the; /// string fit on the first line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:293,Integrability,wrap,wrap,293,"/// Print the given string to a stream, word-wrapping it to; /// some number of columns in the process.; ///; /// \param OS the stream to which the word-wrapping string will be; /// emitted.; /// \param Str the string to word-wrap and output.; /// \param Columns the number of columns to word-wrap to.; /// \param Column the column number at which the first character of \p; /// Str will be printed. This will be non-zero when part of the first; /// line has already been printed.; /// \param Bold if the current text should be bold; /// \returns true if word-wrapping was required, or false if the; /// string fit on the first line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:560,Integrability,wrap,wrapping,560,"/// Print the given string to a stream, word-wrapping it to; /// some number of columns in the process.; ///; /// \param OS the stream to which the word-wrapping string will be; /// emitted.; /// \param Str the string to word-wrap and output.; /// \param Columns the number of columns to word-wrap to.; /// \param Column the column number at which the first character of \p; /// Str will be printed. This will be non-zero when part of the first; /// line has already been printed.; /// \param Bold if the current text should be bold; /// \returns true if word-wrapping was required, or false if the; /// string fit on the first line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:50,Integrability,wrap,wrap,50,"// This word does not fit on the current line, so wrap to the next; // line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:37,Integrability,message,message,37,// Append any remaning text from the message with its existing formatting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:28,Integrability,message,messages,28,"// Print primary diagnostic messages in bold and without color, to visually; // indicate the transition from continuation notes and other output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:463,Performance,cache,caches,463,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:22,Usability,simpl,simplified,22,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:35,Availability,avail,available,35,// At least print the file name if available:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:40,Availability,error,error,40,// MSVC2013 and before print 'file(4) : error'. MSVC2015 gets rid of the; // space and prints 'file(4): error'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:104,Availability,error,error,104,// MSVC2013 and before print 'file(4) : error'. MSVC2015 gets rid of the; // space and prints 'file(4): error'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:174,Availability,down,downwards,174,"// Otherwise, expand A towards B to produce a range of size MaxRange. We; // attempt to expand by the same amount in both directions if B strictly; // contains A.; // Expand downwards by up to half the available amount, then upwards as; // much as possible, then downwards as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:202,Availability,avail,available,202,"// Otherwise, expand A towards B to produce a range of size MaxRange. We; // attempt to expand by the same amount in both directions if B strictly; // contains A.; // Expand downwards by up to half the available amount, then upwards as; // much as possible, then downwards as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:263,Availability,down,downwards,263,"// Otherwise, expand A towards B to produce a range of size MaxRange. We; // attempt to expand by the same amount in both directions if B strictly; // contains A.; // Expand downwards by up to half the available amount, then upwards as; // much as possible, then downwards as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:192,Integrability,depend,dependent,192,"// Insert the new code into the line just below the code; // that the user wrote.; // Note: When modifying this function, be very careful about what is a; // ""column"" (printed width, platform-dependent) and what is a; // ""byte offset"" (SourceManager ""column"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:186,Usability,simpl,simple,186,"/// Filter out invalid ranges, ranges that don't fit into the window of; /// source lines we will print, and ranges from other files.; ///; /// For the remaining ranges, convert them to simple LineRange structs,; /// which only cover one line at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:55,Integrability,rout,routine,55,/// Emit a code snippet and caret line.; ///; /// This routine emits a single line's code snippet and caret line..; ///; /// \param Loc The location for the caret.; /// \param Ranges The underlined ranges for this code snippet.; /// \param Hints The FixIt hints active for this diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:244,Availability,error,error,244,"// If caret diagnostics are enabled and we have location, we want to; // emit the caret. However, we only do this if the location moved; // from the last diagnostic, if the last diagnostic was a note that; // was part of a different warning or error diagnostic, or if the; // diagnostic has ranges. We don't want to emit the same caret; // multiple times if one loc has multiple diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:3,Deployability,Toggle,Toggle,3,// Toggle inverted colors on or off for this character.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:34,Integrability,wrap,wrapping,34,"// We specifically do not do word-wrapping or tab-expansion here,; // because this is supposed to be easy to parse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp:450,Integrability,message,messages,450,"//===- TextDiagnosticBuffer.cpp - Buffer Text Diagnostics -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a concrete diagnostic client, which buffers the diagnostic messages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp:33,Availability,error,errors,33,"/// HandleDiagnostic - Store the errors, warnings, and notes that are; /// reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:434,Integrability,message,messages,434,"//===--- TextDiagnosticPrinter.cpp - Diagnostic Printer -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This diagnostic client prints out their diagnostic messages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:140,Integrability,message,message,140,"/// Print any diagnostic option information to a raw_ostream.; ///; /// This implements all of the logic for adding diagnostic options to a message; /// (via OS). Each relevant option is comma separated and all are enclosed in; /// the standard bracketing: "" [...]"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:99,Testability,log,logic,99,"/// Print any diagnostic option information to a raw_ostream.; ///; /// This implements all of the logic for adding diagnostic options to a message; /// (via OS). Each relevant option is comma separated and all are enclosed in; /// the standard bracketing: "" [...]"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:334,Availability,error,error,334,"// The code below is somewhat fragile because we are essentially trying to; // report to the user what happened by inferring what the diagnostic engine; // did. Eventually it might make more sense to have the diagnostic engine; // include some ""why"" information in the diagnostic.; // If this is a warning which has been mapped to an error by the user (as; // inferred by checking whether the default mapping is to an error) then; // flag it as such. Note that diagnostics could also have been mapped by a; // pragma, but we don't currently have a way to distinguish this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:418,Availability,error,error,418,"// The code below is somewhat fragile because we are essentially trying to; // report to the user what happened by inferring what the diagnostic engine; // did. Eventually it might make more sense to have the diagnostic engine; // include some ""why"" information in the diagnostic.; // If this is a warning which has been mapped to an error by the user (as; // inferred by checking whether the default mapping is to an error) then; // flag it as such. Note that diagnostics could also have been mapped by a; // pragma, but we don't currently have a way to distinguish this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:25,Integrability,message,message,25,// Render the diagnostic message into a temporary buffer eagerly. We'll use; // this later as we print out the diagnostic to the terminal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:112,Availability,error,error,112,"// Keeps track of the starting position of the location; // information (e.g., ""foo.c:10:4:"") that precedes the error; // message. We use this information to determine how long the; // file+line+column number prefix is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:122,Integrability,message,message,122,"// Keeps track of the starting position of the location; // information (e.g., ""foo.c:10:4:"") that precedes the error; // message. We use this information to determine how long the; // file+line+column number prefix is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:20,Usability,simpl,simpler,20,"// Use a dedicated, simpler path for diagnostics without a valid location.; // This is important as if the location is missing, we may be emitting; // diagnostics in a context that lacks language options, a source manager, or; // other infrastructure necessary when emitting more rich diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:3,Testability,Assert,Assert,3,// Assert that the rest of our infrastructure is setup properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:450,Integrability,message,messages,450,"//===- VerifyDiagnosticConsumer.cpp - Verifying Diagnostic Client ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a concrete diagnostic client, which buffers the diagnostic messages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:35,Deployability,update,update,35,/// Hook into the preprocessor and update the list of parsed; /// files when the preprocessor indicates a new file is entered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:467,Modifiability,extend,extend,467,"// Return true if string literal S is matched in content.; // When true, P marks begin-position of the match, and calling Advance sets C; // to end-position of the match.; // If S is the empty string, then search for any letter instead (makes sense; // with FinishDirectiveToken=true).; // If EnsureStartOfWord, then skip matches that don't start a new word.; // If FinishDirectiveToken, then assume the match is the start of a comment; // directive for -verify, and extend the match to include the entire first; // token of that directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:205,Availability,error,error,205,// anonymous; // Tracker for markers in the input files. A marker is a comment of the form; //; // n = 123; // #123; //; // ... that can be referred to by a later expected-* directive:; //; // // expected-error@#123 {{undeclared identifier 'n'}}; //; // Marker declarations must be at the start of a comment or preceded by; // whitespace to distinguish them from uses of markers in directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:38,Availability,error,error,38,// Type in initial directive token: -{error|warning|note|no-diagnostics},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:22,Integrability,interface,interface,22,// DiagnosticConsumer interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:93,Availability,error,errors,93,/// HandleComment - Hook into the preprocessor and extract comments containing; /// expected errors and warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:20,Availability,error,error,20,// See if there are error mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:107,Availability,error,error,107,"// In a debug build, scan through any files that may have been missed; // during parsing and issue a fatal error if directives are contained; // within these files. If a fatal error occurs, this suggests that; // this file is being parsed separately from the main file, in which; // case consider moving the directives to the correct place, if this; // is applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:176,Availability,error,error,176,"// In a debug build, scan through any files that may have been missed; // during parsing and issue a fatal error if directives are contained; // within these files. If a fatal error occurs, this suggests that; // this file is being parsed separately from the main file, in which; // case consider moving the directives to the correct place, if this; // is applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:14,Performance,cache,cache,14,// Generate a cache of parsed FileEntry pointers for alias lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:18,Availability,error,error,18,// Report a fatal error if this file contained directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:44,Usability,clear,clear,44,"// UnparsedFiles has been processed now, so clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:14,Availability,error,error,14,// Produce an error if no expected-* directives could be found in the; // source file(s) processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:411,Energy Efficiency,adapt,adaptor,411,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:555,Energy Efficiency,adapt,adapted,555,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:34,Modifiability,Rewrite,Rewriter,34,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:411,Modifiability,adapt,adaptor,411,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:433,Modifiability,rewrite,rewrites,433,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:555,Modifiability,adapt,adapted,555,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:424,Performance,perform,performs,424,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:56,Modifiability,rewrite,rewriter,56,"// Overwriting open files on Windows is tricky, but the rewriter can do it; // for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:36,Availability,error,errors,36,// Default implementation (Warnings/errors count).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:13,Availability,error,errors,13,// Skip over errors if we are only fixing warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:25,Performance,perform,perform,25,// Make sure that we can perform all of the modifications we; // in this diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:18,Availability,error,error,18,"// If this was an error, refuse to perform any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:35,Performance,perform,perform,35,"// If this was an error, refuse to perform any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:30,Energy Efficiency,adapt,adapted,30,/// Emit a diagnostic via the adapted diagnostic client.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:30,Modifiability,adapt,adapted,30,/// Emit a diagnostic via the adapted diagnostic client.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:118,Availability,down,downstream,118,"// When producing this diagnostic, we temporarily bypass ourselves,; // clear out any current diagnostic, and let the downstream client; // format the diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:72,Usability,clear,clear,72,"// When producing this diagnostic, we temporarily bypass ourselves,; // clear out any current diagnostic, and let the downstream client; // format the diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp:13,Modifiability,rewrite,rewrite,13,// Otherwise rewrite all files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp:8,Modifiability,rewrite,rewrite,8,// Only rewrite each module file once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the contents of the module in a separate compiler instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp:21,Modifiability,rewrite,rewrite,21,// Don't recursively rewrite imports. We handle them all at the top level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FrontendActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:33,Modifiability,Rewrite,Rewrite,33,"//===--- InclusionRewriter.cpp - Rewrite includes into their expansions ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code rewrites include invocations into their expansions. This gives you; // a file with all included files merged into it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:393,Modifiability,rewrite,rewrites,393,"//===--- InclusionRewriter.cpp - Rewrite includes into their expansions ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code rewrites include invocations into their expansions. This gives you; // a file with all included files merged into it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:52,Performance,perform,performed,52,"/// Information about which #includes were actually performed,; /// created by preprocessor callbacks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:91,Integrability,depend,depending,91,"/// Write appropriate line information as either #line directives or GNU line; /// markers depending on what mode we're in, including the \p Filename and; /// \p Line we are located at, using the specified \p EOL line separator, and; /// any \p Extra context specifiers in GNU line directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:101,Integrability,wrap,wrapped,101,"// as above for `3', plus ""`4' This indicates that the following text; // should be treated as being wrapped in an implicit extern ""C"" block.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:412,Availability,error,error,412,"/// This should be called whenever the preprocessor encounters include; /// directives. It does not say whether the file has been included, but it; /// provides more information about the directive (hash location instead; /// of location inside the included file). It is assumed that the matching; /// FileChanged() or FileSkipped() is called after this (or neither is; /// called if this #include results in an error or does not textually include; /// anything).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:199,Security,hash,hash,199,"/// This should be called whenever the preprocessor encounters include; /// directives. It does not say whether the file has been included, but it; /// provides more information about the directive (hash location instead; /// of location inside the included file). It is assumed that the matching; /// FileChanged() or FileSkipped() is called after this (or neither is; /// called if this #include results in an error or does not textually include; /// anything).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:70,Security,hash,hash,70,"/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of inclusion information, FileChanges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:4,Usability,Simpl,Simple,4,"/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of inclusion information, FileChanges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:70,Security,hash,hash,70,/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of module inclusion information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:4,Usability,Simpl,Simple,4,/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of module inclusion information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:70,Security,hash,hash,70,/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of module entry information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:4,Usability,Simpl,Simple,4,/// Simple lookup for a SourceLocation (specifically one denoting the hash in; /// an inclusion directive) in the map of module entry information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:170,Safety,safe,safe,170,"// If we would output half of a line ending, advance one character to output; // the whole line ending. All buffers are null terminated, so looking ahead; // one byte is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:101,Energy Efficiency,reduce,reduce,101,"// TODO: Consider adding a switch that strips possibly unimportant content,; // such as comments, to reduce the size of repro files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:3,Deployability,update,update,3,// update our own type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:131,Performance,perform,performed,131,// First let the preprocessor process the entire file and call callbacks.; // Callbacks will record which #include's were actually performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:98,Performance,optimiz,optimization,98,"// Only preprocessor directives matter here, so disable macro expansion; // everywhere else as an optimization.; // TODO: It would be even faster if the preprocessor could be switched; // to a mode where it would parse only preprocessor directives and comments,; // nothing else matters for parsing or processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp:9,Modifiability,Rewrite,RewriteMacros,9,"//===--- RewriteMacros.cpp - Rewrite macros into their expansions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code rewrites macro invocations into their expansions. This gives you; // a macro expanded file that retains comments and #includes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp:29,Modifiability,Rewrite,Rewrite,29,"//===--- RewriteMacros.cpp - Rewrite macros into their expansions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code rewrites macro invocations into their expansions. This gives you; // a macro expanded file that retains comments and #includes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp:393,Modifiability,rewrite,rewrites,393,"//===--- RewriteMacros.cpp - Rewrite macros into their expansions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This code rewrites macro invocations into their expansions. This gives you; // a macro expanded file that retains comments and #includes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp:4,Modifiability,Rewrite,RewriteMacrosInInput,4,/// RewriteMacrosInInput - Implement -rewrite-macros mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp:38,Modifiability,rewrite,rewrite-macros,38,/// RewriteMacrosInInput - Implement -rewrite-macros mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteMacros.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:8,Modifiability,Rewrite,RewriteModernObjC,8,"//===-- RewriteModernObjC.cpp - Playground for the code rewriter ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:56,Modifiability,rewrite,rewriter,56,"//===-- RewriteModernObjC.cpp - Playground for the code rewriter ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:417,Modifiability,rewrite,rewriter,417,"//===-- RewriteModernObjC.cpp - Playground for the code rewriter ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:11,Modifiability,variab,variable,11,/* a block variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:47,Modifiability,variab,variable,47,/* the on stack structure holding the; __block variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:53,Integrability,rout,routines,53,/* called from __block (byref) copy/dispose; support routines */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:41,Modifiability,rewrite,rewrite,41,/* Misc. containers needed for meta-data rewrite. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Integrability,protocol,protocol,21,// Remember all the @protocol(<expr>) expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:82,Safety,avoid,avoid,82,// This maps an original source AST to it's rewritten form. This allows; // us to avoid rewriting the same node twice (which is very uncommon).; // This is needed to support some of the exotic property rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Integrability,interface,interface,21,// Keep track of all interface declarations seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:12,Modifiability,rewrite,rewrite,12,// We can't rewrite the same node twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:18,Modifiability,rewrite,rewrite,18,// Block specific rewrite rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:28,Integrability,rout,routines,28,// Misc. AST transformation routines. Sometimes they end up calling; // rewriting routines on the new ASTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:82,Integrability,rout,routines,82,// Misc. AST transformation routines. Sometimes they end up calling; // rewriting routines on the new ASTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:16,Integrability,rout,routines,16,// Misc. helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:6,Safety,avoid,avoid,6,"// We avoid calling Type::isBlockPointerType(), since it operates on the; // canonical type. We only care if the top-level type is a closure pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:28,Availability,error,error,28,"// FIXME. This should be an error. But if block is not called, it is OK. And it; // may break including some headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:112,Modifiability,rewrite,rewrite,112,"// Two cases: either the decl could be in the main file, or it could be in a; // #included file. If the former, rewrite it now. If the later, check to see; // if we rewrote the #include/#import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:67,Modifiability,rewrite,rewrite,67,// Look for built-in declarations that we need to refer during the rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Integrability,interface,interface,21,// Keep track of all interface declarations seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:56,Modifiability,rewrite,rewrite,56,"// If we have a decl in the main file, see if we should rewrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:39,Security,access,access,39,// Synthesize an explicit cast to gain access to the ivar.; // See objc-act.c:objc_synthesize_new_getter() for details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:85,Modifiability,rewrite,rewrite,85,"// When method is a synthesized one, such as a getter/setter there is; // nothing to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:17,Integrability,protocol,protocol,17,// FIXME: handle protocol headers that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,Integrability,protocol,protocol,25,// FIXME: handle forward protocol that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,Integrability,protocol,protocol,25,// FIXME: handle forward protocol that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Modifiability,Rewrite,RewriteObjCMethodDecl,21,"//fprintf(stderr,""In RewriteObjCMethodDecl\n"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite arguments,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:15,Modifiability,rewrite,rewriter,15,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:44,Modifiability,rewrite,rewrite,44,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:9,Safety,avoid,avoid,9,// TODO: avoid this copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:15,Modifiability,rewrite,rewriter,15,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:44,Modifiability,rewrite,rewrite,44,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteBreakStmt,4,/// RewriteBreakStmt - Rewrite for a break-stmt inside an ObjC2's foreach; /// statement to exit to its outer synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:23,Modifiability,Rewrite,Rewrite,23,/// RewriteBreakStmt - Rewrite for a break-stmt inside an ObjC2's foreach; /// statement to exit to its outer synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteContinueStmt,4,/// RewriteContinueStmt - Rewrite for a continue-stmt inside an ObjC2's foreach; /// statement to continue with its inner synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:26,Modifiability,Rewrite,Rewrite,26,/// RewriteContinueStmt - Rewrite for a continue-stmt inside an ObjC2's foreach; /// statement to continue with its inner synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCForCollectionStmt,4,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// NSUInteger limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while ((limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]));; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:35,Modifiability,Rewrite,Rewriter,35,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// NSUInteger limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while ((limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]));; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:83,Modifiability,rewrite,rewrites,83,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// NSUInteger limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while ((limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]));; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Usability,Simpl,Simply,3,// Simply use 'id' for all qualified types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Usability,Simpl,Simply,3,// Simply use 'id' for all qualified types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:152,Usability,simpl,simply,152,/* Need to treat single statements specially. For example:; *; * for (A *a in b) if (stuff()) break;; * for (A *a in b) xxxyy;; *; * The following code simply scans ahead to the semi to find the actual end.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:44,Integrability,rout,routine,44,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:62,Integrability,synchroniz,synchronized,62,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCSynchronizedStmt,4,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:52,Modifiability,rewrite,rewrites,52,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:118,Integrability,message,message,118,"// We can't use S->getSynchExpr()->getEndLoc() to find the end location, since; // the sync expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up traversal of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:100,Integrability,message,message,100,"// This can't be done with ReplaceStmt(S, ThrowExpr), since; // the throw expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:73,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,73,"// Replace this subexpr in the parent.; // delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:38,Modifiability,rewrite,rewrite,38,// This will defend against trying to rewrite synthesized expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:67,Integrability,protocol,protocol,67,"// Check for ObjC 'id' and class types that have been adorned with protocol; // information (id<p>, C<p>*). The protocol references need to be rewritten!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:112,Integrability,protocol,protocol,112,"// Check for ObjC 'id' and class types that have been adorned with protocol; // information (id<p>, C<p>*). The protocol references need to be rewritten!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,Modifiability,variab,variable,22,"// most likely, was a variable; // Now check arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:27,Integrability,rout,routine,27,// FIXME. Consolidate this routine with RewriteBlockPointerType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,Modifiability,Rewrite,RewriteBlockPointerType,40,// FIXME. Consolidate this routine with RewriteBlockPointerType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:61,Integrability,rout,routine,61,// synthesize declaration of helper functions needed in this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:61,Integrability,rout,routine,61,// synthesize declaration of helper functions needed in this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:61,Integrability,rout,routine,61,// synthesize declaration of helper functions needed in this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:37,Integrability,rout,routine,37,"/// SynthMsgSendStretCallExpr - This routine translates message expression; /// into a call to objc_msgSend_stret() entry point. Tricky part is that; /// nil check on receiver must be performed before calling objc_msgSend_stret.; /// MsgSendStretFlavor - function declaration objc_msgSend_stret(...); /// msgSendType - function type of objc_msgSend_stret(...); /// returnType - Result type of the method being synthesized.; /// ArgTypes - type of the arguments passed to objc_msgSend_stret, starting with receiver type.; /// MsgExprs - list of argument expressions being passed to objc_msgSend_stret,; /// starting with receiver.; /// Method - Method being rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:56,Integrability,message,message,56,"/// SynthMsgSendStretCallExpr - This routine translates message expression; /// into a call to objc_msgSend_stret() entry point. Tricky part is that; /// nil check on receiver must be performed before calling objc_msgSend_stret.; /// MsgSendStretFlavor - function declaration objc_msgSend_stret(...); /// msgSendType - function type of objc_msgSend_stret(...); /// returnType - Result type of the method being synthesized.; /// ArgTypes - type of the arguments passed to objc_msgSend_stret, starting with receiver type.; /// MsgExprs - list of argument expressions being passed to objc_msgSend_stret,; /// starting with receiver.; /// Method - Method being rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:184,Performance,perform,performed,184,"/// SynthMsgSendStretCallExpr - This routine translates message expression; /// into a call to objc_msgSend_stret() entry point. Tricky part is that; /// nil check on receiver must be performed before calling objc_msgSend_stret.; /// MsgSendStretFlavor - function declaration objc_msgSend_stret(...); /// msgSendType - function type of objc_msgSend_stret(...); /// returnType - Result type of the method being synthesized.; /// ArgTypes - type of the arguments passed to objc_msgSend_stret, starting with receiver type.; /// MsgExprs - list of argument expressions being passed to objc_msgSend_stret,; /// starting with receiver.; /// Method - Method being rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:115,Modifiability,rewrite,rewriter,115,"// The code for super is a little tricky to prevent collision with; // the structure definition in the header. The rewriter has it's own; // internal definition (__rw_objc_super) that is uses. This is why; // we need the cast below. For example:; // (struct __rw_objc_super *)&__rw_objc_super((id)self, (id)objc_getClass(""SUPER"")); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:115,Modifiability,rewrite,rewriter,115,"// The code for super is a little tricky to prevent collision with; // the structure definition in the header. The rewriter has it's own; // internal definition (__rw_objc_super) that is uses. This is why; // we need the cast below. For example:; // (struct __rw_objc_super *)&__rw_objc_super((id)self, (id)objc_getClass(""SUPER"")); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:177,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,177,"// We've transferred the ownership to MsgExprs. For now, we *don't* null; // out the argument in the original expression (since we aren't deleting; // the ObjCMessageExpr). See RewritePropertyOrImplicitSetter() usage for more info.; //Exp->setArg(i, 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:274,Safety,abort,abort,274,"// Need to cast objc_msgSend to ""void *"" (to workaround a GCC bandaid).; // If we don't do this cast, we get the following bizarre warning/note:; // xx.m:13: warning: function called through a non-compatible type; // xx.m:13: note: if this code is reached, the program will abort",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:192,Integrability,depend,depending,192,// We have the method which returns a struct/union. Must also generate; // call to objc_msgSend_stret and hang both varieties on a conditional; // expression which dictate which one to envoke depending on size of; // method's return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Modifiability,rewrite,rewrite,21,// Now do the actual rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:30,Integrability,Protocol,Protocol,30,// typedef struct objc_object Protocol;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,Integrability,protocol,protocol,40,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteModernObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:115,Integrability,protocol,protocol,115,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteModernObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCProtocolExpr,4,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteModernObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:30,Modifiability,Rewrite,Rewrite,30,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteModernObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:202,Modifiability,Rewrite,RewriteModernObjC,202,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteModernObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:35,Integrability,rout,routine,35,"/// IsTagDefinedInsideClass - This routine checks that a named tagged type; /// is defined inside an objective-c class. If so, it returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:36,Integrability,rout,routine,36,"/// RewriteObjCFieldDeclType - This routine rewrites a type into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCFieldDeclType,4,"/// RewriteObjCFieldDeclType - This routine rewrites a type into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:44,Modifiability,rewrite,rewrites,44,"/// RewriteObjCFieldDeclType - This routine rewrites a type into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:32,Integrability,rout,routine,32,"/// RewriteObjCFieldDecl - This routine rewrites a field into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCFieldDecl,4,"/// RewriteObjCFieldDecl - This routine rewrites a field into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,Modifiability,rewrite,rewrites,40,"/// RewriteObjCFieldDecl - This routine rewrites a field into the buffer.; /// It handles elaborated types, as well as enum types in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:48,Integrability,rout,routine,48,/// RewriteLocallyDefinedNamedAggregates - This routine rewrites locally defined; /// named aggregate types into the input buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteLocallyDefinedNamedAggregates,4,/// RewriteLocallyDefinedNamedAggregates - This routine rewrites locally defined; /// named aggregate types into the input buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:56,Modifiability,rewrite,rewrites,56,/// RewriteLocallyDefinedNamedAggregates - This routine rewrites locally defined; /// named aggregate types into the input buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCInternalStruct,4,/// RewriteObjCInternalStruct - Rewrite one internal struct corresponding to; /// an objective-c class with ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:32,Modifiability,Rewrite,Rewrite,32,/// RewriteObjCInternalStruct - Rewrite one internal struct corresponding to; /// an objective-c class with ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteIvarOffsetSymbols,4,/// RewriteIvarOffsetSymbols - Rewrite ivar offset symbols of those ivars which; /// have been referenced in an ivar access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:31,Modifiability,Rewrite,Rewrite,31,/// RewriteIvarOffsetSymbols - Rewrite ivar offset symbols of those ivars which; /// have been referenced in an ivar access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:117,Security,access,access,117,/// RewriteIvarOffsetSymbols - Rewrite ivar offset symbols of those ivars which; /// have been referenced in an ivar access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:75,Security,access,access,75,// write out ivar offset symbols which have been referenced in an ivar; // access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:221,Integrability,rout,routine,221,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:191,Modifiability,Rewrite,RewriteImplementations,191,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:229,Modifiability,rewrite,rewrites,229,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite implemented methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:32,Safety,avoid,avoid,32,"// Create local declarations to avoid rewriting all closure decl ref exprs.; // First, emit a declaration for all ""by ref"" decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:39,Modifiability,variab,variables,39,// Need to copy-in the inner copied-in variables not actually used in this; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:39,Integrability,rout,routine,39,"/// convertObjCTypeToCStyleType - This routine converts such objc types; /// as qualified objects, and blocks to their closest c/c++ types that; /// it can. It returns true if input type was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:39,Integrability,rout,routine,39,/// convertFunctionTypeOfBlocks - This routine converts a function type; /// whose result type may be a block pointer or whose argument type(s); /// might be block pointers to an equivalent function type replacing; /// all block pointers to function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:300,Integrability,message,message,300,// We need to return the rewritten expression to handle cases where the; // DeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a DeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:257,Testability,test,test,257,// We need to return the rewritten expression to handle cases where the; // DeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a DeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Modifiability,variab,variable,21,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:122,Modifiability,variab,variable,122,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrites,3,"// Rewrites the imported local variable V with external storage; // (static, extern, etc.) as *V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:31,Modifiability,variab,variable,31,"// Rewrites the imported local variable V with external storage; // (static, extern, etc.) as *V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:27,Modifiability,rewrite,rewrite,27,// Need to avoid trying to rewrite synthesized casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:11,Safety,avoid,avoid,11,// Need to avoid trying to rewrite synthesized casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:27,Modifiability,rewrite,rewrite,27,// Need to avoid trying to rewrite casts contained in macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:11,Safety,avoid,avoid,11,// Need to avoid trying to rewrite casts contained in macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:10,Modifiability,Variab,Variables,10,// Handle Variables and Typedefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:44,Integrability,rout,routine,44,"/// SynthesizeByrefCopyDestroyHelper - This routine synthesizes:; /// void __Block_byref_id_object_copy(struct Block_byref_id_object *dst,; /// struct Block_byref_id_object *src) {; /// _Block_object_assign (&_dest->object, _src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT; /// [|BLOCK_FIELD_IS_WEAK]) // object; /// _Block_object_assign(&_dest->object, _src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK; /// [|BLOCK_FIELD_IS_WEAK]) // block; /// }; /// And:; /// void __Block_byref_id_object_dispose(struct Block_byref_id_object *_src) {; /// _Block_object_dispose(_src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT; /// [|BLOCK_FIELD_IS_WEAK]) // object; /// _Block_object_dispose(_src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK; /// [|BLOCK_FIELD_IS_WEAK]) // block; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:62,Integrability,rout,routine,62,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteByRefVar,4,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:48,Modifiability,variab,variable,48,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:337,Modifiability,variab,variable,337,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:419,Modifiability,variab,variable,419,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:519,Modifiability,variab,variable,519,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:83,Modifiability,variab,variable,83,"// If type location is missing, it is because of missing type (a warning).; // Use variable's location which is good for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:24,Modifiability,variab,variable,24,// FIXME. Handle __weak variable (BLOCK_FIELD_IS_WEAK) as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:10,Modifiability,rewrite,rewriter,10,// FIXME. rewriter does not support __block c++ objects which; // require construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,Modifiability,variab,variables,22,// Add inner imported variables now used in current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:161,Integrability,rout,routine,161,// We need to save the copied-in variables in nested; // blocks because it is needed at the end for some of the API generations.; // See SynthesizeBlockLiterals routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:33,Modifiability,variab,variables,33,// We need to save the copied-in variables in nested; // blocks because it is needed at the end for some of the API generations.; // See SynthesizeBlockLiterals routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,Modifiability,variab,variable,25,// captured nested byref variable has its address passed. Do not take; // its address again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:110,Modifiability,rewrite,rewrite,110,// Pseudo-object operations and ivar references need special; // treatment because we're going to recursively rewrite them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:23,Modifiability,rewrite,rewrite,23,// Perform a bottom up rewrite of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up rewrite of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the block body in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:42,Integrability,message,message,42,"// Before we rewrite it, put the original message expression in a comment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:13,Modifiability,rewrite,rewrite,13,"// Before we rewrite it, put the original message expression in a comment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,Integrability,protocol,protocol,21,"// Need to check for protocol refs (id <P>, Foo <P> *) in variable decls; // and cast exprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:58,Modifiability,variab,variable,58,"// Need to check for protocol refs (id <P>, Foo <P> *) in variable decls; // and cast exprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:470,Integrability,depend,depends,470,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:180,Modifiability,rewrite,rewrite,180,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:405,Modifiability,Rewrite,RewriteObjCForCollectionStmt,405,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:210,Safety,avoid,avoid,210,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:10,Modifiability,rewrite,rewrite,10,// Blocks rewrite rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:108,Modifiability,rewrite,rewrite,108,"// Since function prototypes don't have ParmDecl's, we check the function; // prototype. This enables us to rewrite function declarations and; // definitions using the same code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:48,Integrability,rout,routine,48,/// Write_ProtocolExprReferencedMetadata - This routine writer out the; /// protocol reference symbols in the for of:; /// struct _protocol_t *PROTOCOL_REF = &PROTOCOL_METADATA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:76,Integrability,protocol,protocol,76,/// Write_ProtocolExprReferencedMetadata - This routine writer out the; /// protocol reference symbols in the for of:; /// struct _protocol_t *PROTOCOL_REF = &PROTOCOL_METADATA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:108,Integrability,protocol,protocol,108,// Here's a great place to add any extra declarations that may be needed.; // Write out meta data for each @protocol(<expr>).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite Objective-c meta data*,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:31,Performance,perform,performance,31,"// These need be generated for performance. Currently they are not,; // using API calls instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Integrability,synchroniz,synchronized,4,// @synchronized hooks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,Testability,test,tests,25,// We use this for clang tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:86,Safety,avoid,avoids,86,"// NOTE! Windows uses LLP64 for 64bit mode. So, cast pointer to long long; // as this avoids warning in any 64bit/32bit compilation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,Integrability,rout,routine,40,/// RewriteIvarOffsetComputation - This routine synthesizes computation of; /// ivar offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteIvarOffsetComputation,4,/// RewriteIvarOffsetComputation - This routine synthesizes computation of; /// ivar offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:911,Integrability,protocol,protocols,911,"; /// struct _prop_t {; /// const char *name;; /// char *attributes;; /// }; /// struct _prop_list_t {; /// uint32_t entsize; // sizeof(struct _prop_t); /// uint32_t count_of_properties;; /// struct _prop_t prop_list[count_of_properties];; /// }; /// struct _protocol_t;; /// struct _protocol_list_t {; /// long protocol_count; // Note, this is 32/64 bit; /// struct _protocol_t * protocol_list[protocol_count];; /// }; /// struct _objc_method {; /// SEL _cmd;; /// const char *method_type;; /// char *_imp;; /// }; /// struct _method_list_t {; /// uint32_t entsize; // sizeof(struct _objc_method); /// uint32_t method_count;; /// struct _objc_method method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:2451,Integrability,protocol,protocols,2451,hod method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// const uint8_t *weakIvarLayout;; /// const struct _prop_list_t *properties;; /// }; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t *superclass;; /// void *cache;; /// IMP *vtable;; /// struct _class_ro_t *ro;; /// }; /// struct _category_t {; /// const char *name;; /// struct _class_t *cls;; /// const struct _method_list_t *instance_methods;; /// const struct _method_list_t *class_methods;; /// const struct _protocol_list_t *protocols;; /// const struct _prop_list_t *properties;; /// }; /// MessageRefTy - LLVM for:; /// struct _message_ref_t {; /// IMP messenger;; /// SEL name;; /// };; /// SuperMessageRefTy - LLVM for:; /// struct _super_message_ref_t {; /// SUPER_IMP messenger;; /// SEL name;; /// };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:2518,Integrability,Message,MessageRefTy,2518,hod method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// const uint8_t *weakIvarLayout;; /// const struct _prop_list_t *properties;; /// }; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t *superclass;; /// void *cache;; /// IMP *vtable;; /// struct _class_ro_t *ro;; /// }; /// struct _category_t {; /// const char *name;; /// struct _class_t *cls;; /// const struct _method_list_t *instance_methods;; /// const struct _method_list_t *class_methods;; /// const struct _protocol_list_t *protocols;; /// const struct _prop_list_t *properties;; /// }; /// MessageRefTy - LLVM for:; /// struct _message_ref_t {; /// IMP messenger;; /// SEL name;; /// };; /// SuperMessageRefTy - LLVM for:; /// struct _super_message_ref_t {; /// SUPER_IMP messenger;; /// SEL name;; /// };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:1287,Modifiability,extend,extendedMethodTypes,1287,"_list[count_of_properties];; /// }; /// struct _protocol_t;; /// struct _protocol_list_t {; /// long protocol_count; // Note, this is 32/64 bit; /// struct _protocol_t * protocol_list[protocol_count];; /// }; /// struct _objc_method {; /// SEL _cmd;; /// const char *method_type;; /// char *_imp;; /// }; /// struct _method_list_t {; /// uint32_t entsize; // sizeof(struct _objc_method); /// uint32_t method_count;; /// struct _objc_method method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// const uint8_t *weakIvarLayout;; /// const struct _prop_list_t *properties;; /// }; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t *superclass;; /// void *cache;; /// IMP *vtable;; /// struct _class_ro_t *ro;; /// }; /// struct _category_t {; /// const char *name;; /// struc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:2177,Performance,cache,cache,2177,hod method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// const uint8_t *weakIvarLayout;; /// const struct _prop_list_t *properties;; /// }; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t *superclass;; /// void *cache;; /// IMP *vtable;; /// struct _class_ro_t *ro;; /// }; /// struct _category_t {; /// const char *name;; /// struct _class_t *cls;; /// const struct _method_list_t *instance_methods;; /// const struct _method_list_t *class_methods;; /// const struct _protocol_list_t *protocols;; /// const struct _prop_list_t *properties;; /// }; /// MessageRefTy - LLVM for:; /// struct _message_ref_t {; /// IMP messenger;; /// SEL name;; /// };; /// SuperMessageRefTy - LLVM for:; /// struct _super_message_ref_t {; /// SUPER_IMP messenger;; /// SEL name;; /// };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:71,Safety,avoid,avoid,71,// Add static function to initialize some of the meta-data fields.; // avoid doing it twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:42,Integrability,protocol,protocols,42,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCProtocolMetaData,4,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:34,Modifiability,Rewrite,Rewrite,34,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,Integrability,protocol,protocol,25,// Do not synthesize the protocol more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,Integrability,protocol,protocol,22,"// Must write out all protocol definitions in current qualifier list,; // and in their nested qualifiers before writing out current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocol,3,// Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:20,Integrability,protocol,protocol,20,// Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocol,3,// Protocol's property metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:40,Integrability,protocol,protocol,40,// Writer out root metadata for current protocol: struct _protocol_t,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:13,Integrability,protocol,protocol,13,// Mark this protocol as having been generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:24,Integrability,interface,interface,24,// Explicitly declared @interface's are already synthesized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:50,Integrability,Protocol,Protocol,50,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:67,Integrability,protocol,protocol,67,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,Integrability,protocol,protocol,22,"// Must write out all protocol definitions in current qualifier list,; // and in their nested qualifiers before writing out current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocol,3,// Protocol's property metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:4,Modifiability,Rewrite,RewriteObjCCategoryImplDecl,4,/// RewriteObjCCategoryImplDecl - Rewrite metadata for each category; /// implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:34,Modifiability,Rewrite,Rewrite,34,/// RewriteObjCCategoryImplDecl - Rewrite metadata for each category; /// implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:50,Integrability,Protocol,Protocol,50,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:67,Integrability,protocol,protocol,67,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,Integrability,protocol,protocol,22,"// Must write out all protocol definitions in current qualifier list,; // and in their nested qualifiers before writing out current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Integrability,Protocol,Protocol,3,// Protocol's property metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,RewriteObjCMethodsMetaData,3,// RewriteObjCMethodsMetaData - Rewrite methods metadata for instance or; /// class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:32,Modifiability,Rewrite,Rewrite,32,// RewriteObjCMethodsMetaData - Rewrite methods metadata for instance or; /// class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the base, but without actually doing replaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:46,Modifiability,variab,variable,46,// lookup which class implements the instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:9,Modifiability,Rewrite,RewriteObjC,9,"//===--- RewriteObjC.cpp - Playground for the code rewriter ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:51,Modifiability,rewrite,rewriter,51,"//===--- RewriteObjC.cpp - Playground for the code rewriter ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:417,Modifiability,rewrite,rewriter,417,"//===--- RewriteObjC.cpp - Playground for the code rewriter ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Hacks and fun related to the code rewriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:11,Modifiability,variab,variable,11,/* a block variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:47,Modifiability,variab,variable,47,/* the on stack structure holding the; __block variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:53,Integrability,rout,routines,53,/* called from __block (byref) copy/dispose; support routines */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:41,Modifiability,rewrite,rewrite,41,/* Misc. containers needed for meta-data rewrite. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:21,Integrability,protocol,protocol,21,// Remember all the @protocol(<expr>) expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:82,Safety,avoid,avoid,82,// This maps an original source AST to it's rewritten form. This allows; // us to avoid rewriting the same node twice (which is very uncommon).; // This is needed to support some of the exotic property rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:12,Modifiability,rewrite,rewrite,12,// We can't rewrite the same node twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:18,Modifiability,rewrite,rewrite,18,// Block specific rewrite rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:18,Security,access,access,18,// Rewriting ivar access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:28,Integrability,rout,routines,28,// Misc. AST transformation routines. Sometimes they end up calling; // rewriting routines on the new ASTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:82,Integrability,rout,routines,82,// Misc. AST transformation routines. Sometimes they end up calling; // rewriting routines on the new ASTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:16,Integrability,rout,routines,16,// Misc. helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:6,Safety,avoid,avoid,6,"// We avoid calling Type::isBlockPointerType(), since it operates on the; // canonical type. We only care if the top-level type is a closure pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:112,Modifiability,rewrite,rewrite,112,"// Two cases: either the decl could be in the main file, or it could be in a; // #included file. If the former, rewrite it now. If the later, check to see; // if we rewrote the #include/#import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:67,Modifiability,rewrite,rewrite,67,// Look for built-in declarations that we need to refer during the rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:56,Modifiability,rewrite,rewrite,56,"// If we have a decl in the main file, see if we should rewrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,Security,access,access,39,// Synthesize an explicit cast to gain access to the ivar.; // See objc-act.c:objc_synthesize_new_getter() for details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:85,Modifiability,rewrite,rewrite,85,"// When method is a synthesized one, such as a getter/setter there is; // nothing to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:17,Integrability,protocol,protocol,17,// FIXME: handle protocol headers that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:25,Integrability,protocol,protocol,25,// FIXME: handle forward protocol that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:25,Integrability,protocol,protocol,25,// FIXME: handle forward protocol that are declared across multiple lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:21,Modifiability,Rewrite,RewriteObjCMethodDecl,21,"//fprintf(stderr,""In RewriteObjCMethodDecl\n"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite arguments,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:15,Modifiability,rewrite,rewriter,15,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Modifiability,rewrite,rewrite,44,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:9,Safety,avoid,avoid,9,// TODO: avoid this copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:15,Modifiability,rewrite,rewriter,15,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Modifiability,rewrite,rewrite,44,"// Because the rewriter doesn't allow us to rewrite rewritten code,; // we need to suppress rewriting the sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteBreakStmt,4,/// RewriteBreakStmt - Rewrite for a break-stmt inside an ObjC2's foreach; /// statement to exit to its outer synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:23,Modifiability,Rewrite,Rewrite,23,/// RewriteBreakStmt - Rewrite for a break-stmt inside an ObjC2's foreach; /// statement to exit to its outer synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteContinueStmt,4,/// RewriteContinueStmt - Rewrite for a continue-stmt inside an ObjC2's foreach; /// statement to continue with its inner synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:26,Modifiability,Rewrite,Rewrite,26,/// RewriteContinueStmt - Rewrite for a continue-stmt inside an ObjC2's foreach; /// statement to continue with its inner synthesized loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCForCollectionStmt,4,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// unsigned long limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while (limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]);; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:35,Modifiability,Rewrite,Rewriter,35,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// unsigned long limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while (limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]);; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:83,Modifiability,rewrite,rewrites,83,/// RewriteObjCForCollectionStmt - Rewriter for ObjC2's foreach statement.; /// It rewrites:; /// for ( type elem in collection) { stmts; }; /// Into:; /// {; /// type elem;; /// struct __objcFastEnumerationState enumState = { 0 };; /// id __rw_items[16];; /// id l_collection = (id)collection;; /// unsigned long limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16];; /// if (limit) {; /// unsigned long startMutations = *enumState.mutationsPtr;; /// do {; /// unsigned long counter = 0;; /// do {; /// if (startMutations != *enumState.mutationsPtr); /// objc_enumerationMutation(l_collection);; /// elem = (type)enumState.itemsPtr[counter++];; /// stmts;; /// __continue_label: ;; /// } while (counter < limit);; /// } while (limit = [l_collection countByEnumeratingWithState:&enumState; /// objects:__rw_items count:16]);; /// elem = nil;; /// __break_label: ;; /// }; /// else; /// elem = nil;; /// }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Usability,Simpl,Simply,3,// Simply use 'id' for all qualified types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Usability,Simpl,Simply,3,// Simply use 'id' for all qualified types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:152,Usability,simpl,simply,152,/* Need to treat single statements specially. For example:; *; * for (A *a in b) if (stuff()) break;; * for (A *a in b) xxxyy;; *; * The following code simply scans ahead to the semi to find the actual end.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Integrability,rout,routine,44,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:62,Integrability,synchroniz,synchronized,62,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCSynchronizedStmt,4,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:52,Modifiability,rewrite,rewrites,52,/// RewriteObjCSynchronizedStmt -; /// This routine rewrites @synchronized(expr) stmt;; /// into:; /// objc_sync_enter(expr);; /// @try stmt @finally { objc_sync_exit(expr); }; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:118,Integrability,message,message,118,"// We can't use S->getSynchExpr()->getEndLoc() to find the end location, since; // the sync expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:32,Modifiability,variab,variables,32,"// declare a new scope with two variables, _stack and _rethrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up traversal of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up traversal of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up traversal of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up traversal of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:32,Modifiability,variab,variables,32,"// declare a new scope with two variables, _stack and _rethrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:7,Modifiability,rewrite,rewrite,7,// Now rewrite the body...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:7,Modifiability,rewrite,rewrite,7,// Now rewrite the body...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:100,Integrability,message,message,100,"// This can't be done with ReplaceStmt(S, ThrowExpr), since; // the throw expression is typically a message expression that's already; // been rewritten! (which implies the SourceLocation's are invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:73,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,73,"// Replace this subexpr in the parent.; // delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:38,Modifiability,rewrite,rewrite,38,// This will defend against trying to rewrite synthesized expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:67,Integrability,protocol,protocol,67,"// Check for ObjC 'id' and class types that have been adorned with protocol; // information (id<p>, C<p>*). The protocol references need to be rewritten!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:112,Integrability,protocol,protocol,112,"// Check for ObjC 'id' and class types that have been adorned with protocol; // information (id<p>, C<p>*). The protocol references need to be rewritten!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:22,Modifiability,variab,variable,22,"// most likely, was a variable; // Now check arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:19,Integrability,protocol,protocol,19,// Comment out the protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:27,Integrability,rout,routine,27,// FIXME. Consolidate this routine with RewriteBlockPointerType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:40,Modifiability,Rewrite,RewriteBlockPointerType,40,// FIXME. Consolidate this routine with RewriteBlockPointerType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:115,Modifiability,rewrite,rewriter,115,"// The code for super is a little tricky to prevent collision with; // the structure definition in the header. The rewriter has it's own; // internal definition (__rw_objc_super) that is uses. This is why; // we need the cast below. For example:; // (struct objc_super *)&__rw_objc_super((id)self, (id)objc_getClass(""SUPER"")); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:115,Modifiability,rewrite,rewriter,115,"// The code for super is a little tricky to prevent collision with; // the structure definition in the header. The rewriter has it's own; // internal definition (__rw_objc_super) that is uses. This is why; // we need the cast below. For example:; // (struct objc_super *)&__rw_objc_super((id)self, (id)objc_getClass(""SUPER"")); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:177,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,177,"// We've transferred the ownership to MsgExprs. For now, we *don't* null; // out the argument in the original expression (since we aren't deleting; // the ObjCMessageExpr). See RewritePropertyOrImplicitSetter() usage for more info.; //Exp->setArg(i, 0);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:274,Safety,abort,abort,274,"// Need to cast objc_msgSend to ""void *"" (to workaround a GCC bandaid).; // If we don't do this cast, we get the following bizarre warning/note:; // xx.m:13: warning: function called through a non-compatible type; // xx.m:13: note: if this code is reached, the program will abort",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:192,Integrability,depend,depending,192,// We have the method which returns a struct/union. Must also generate; // call to objc_msgSend_stret and hang both varieties on a conditional; // expression which dictate which one to envoke depending on size of; // method's return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:217,Integrability,rout,routine,217,// (sizeof(returnType) <= 8 ? objc_msgSend(...) : objc_msgSend_stret(...)); // FIXME: Value of 8 is base on ppc32/x86 ABI for the most common cases.; // For X86 it is more complicated and some kind of target specific routine; // is needed to decide what to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:21,Modifiability,rewrite,rewrite,21,// Now do the actual rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:30,Integrability,Protocol,Protocol,30,// typedef struct objc_object Protocol;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:40,Integrability,protocol,protocol,40,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:115,Integrability,protocol,protocol,115,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCProtocolExpr,4,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:30,Modifiability,Rewrite,Rewrite,30,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:202,Modifiability,Rewrite,RewriteObjC,202,/// RewriteObjCProtocolExpr - Rewrite a protocol expression into; /// a synthesized/forward data reference (to the protocol's metadata).; /// The forward references (and metadata) are generated in; /// RewriteObjC::HandleTranslationUnit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,Rewrite,RewritePropertyOrImplicitSetter,33,"// delete Exp; leak for now, see RewritePropertyOrImplicitSetter() usage for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCInternalStruct,4,/// RewriteObjCInternalStruct - Rewrite one internal struct corresponding to; /// an objective-c class with ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:32,Modifiability,Rewrite,Rewrite,32,/// RewriteObjCInternalStruct - Rewrite one internal struct corresponding to; /// an objective-c class with ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:202,Integrability,interface,interface,202,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:242,Integrability,interface,interface,242,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:79,Modifiability,rewrite,rewrites,79,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:350,Safety,avoid,avoid,350,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:40,Integrability,protocol,protocols,40,// advance to the end of the referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite the original header,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite the original header *without* disturbing the '{',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite block specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:30,Modifiability,variab,variables,30,// we don't have any instance variables - insert super struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:221,Integrability,rout,routine,221,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:191,Modifiability,Rewrite,RewriteImplementations,191,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:229,Modifiability,rewrite,rewrites,229,//===----------------------------------------------------------------------===//; // Meta Data Emission; //===----------------------------------------------------------------------===//; /// RewriteImplementations - This routine rewrites all method implementations; /// and emits meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite implemented methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:32,Safety,avoid,avoid,32,"// Create local declarations to avoid rewriting all closure decl ref exprs.; // First, emit a declaration for all ""by ref"" decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,Modifiability,variab,variables,39,// Need to copy-in the inner copied-in variables not actually used in this; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,Integrability,rout,routine,39,/// convertFunctionTypeOfBlocks - This routine converts a function type; /// whose result type may be a block pointer or whose argument type(s); /// might be block pointers to an equivalent function type replacing; /// all block pointers to function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:310,Integrability,message,message,310,// We need to return the rewritten expression to handle cases where the; // BlockDeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a BlockDeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:262,Testability,test,test,262,// We need to return the rewritten expression to handle cases where the; // BlockDeclRefExpr is embedded in another expression being rewritten.; // For example:; //; // int main() {; // __block Foo *f;; // __block int i;; //; // void (^myblock)() = ^() {; // [f test]; // f is a BlockDeclRefExpr embedded in a message (which is being rewritten).; // i = 77;; // };; //},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:21,Modifiability,variab,variable,21,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:122,Modifiability,variab,variable,122,// Rewrite the byref variable into BYREFVAR->__forwarding->BYREFVAR; // for each DeclRefExp where BYREFVAR is name of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrites,3,"// Rewrites the imported local variable V with external storage; // (static, extern, etc.) as *V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:31,Modifiability,variab,variable,31,"// Rewrites the imported local variable V with external storage; // (static, extern, etc.) as *V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:27,Modifiability,rewrite,rewrite,27,// Need to avoid trying to rewrite synthesized casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:11,Safety,avoid,avoid,11,// Need to avoid trying to rewrite synthesized casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:27,Modifiability,rewrite,rewrite,27,// Need to avoid trying to rewrite casts contained in macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:11,Safety,avoid,avoid,11,// Need to avoid trying to rewrite casts contained in macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:10,Modifiability,Variab,Variables,10,// Handle Variables and Typedefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Integrability,rout,routine,44,"/// SynthesizeByrefCopyDestroyHelper - This routine synthesizes:; /// void __Block_byref_id_object_copy(struct Block_byref_id_object *dst,; /// struct Block_byref_id_object *src) {; /// _Block_object_assign (&_dest->object, _src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT; /// [|BLOCK_FIELD_IS_WEAK]) // object; /// _Block_object_assign(&_dest->object, _src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK; /// [|BLOCK_FIELD_IS_WEAK]) // block; /// }; /// And:; /// void __Block_byref_id_object_dispose(struct Block_byref_id_object *_src) {; /// _Block_object_dispose(_src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT; /// [|BLOCK_FIELD_IS_WEAK]) // object; /// _Block_object_dispose(_src->object,; /// BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK; /// [|BLOCK_FIELD_IS_WEAK]) // block; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:62,Integrability,rout,routine,62,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteByRefVar,4,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:48,Modifiability,variab,variable,48,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:337,Modifiability,variab,variable,337,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:419,Modifiability,variab,variable,419,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:519,Modifiability,variab,variable,519,"/// RewriteByRefVar - For each __block typex ND variable this routine transforms; /// the declaration into:; /// struct __Block_byref_ND {; /// void *__isa; // NULL for everything except __weak pointers; /// struct __Block_byref_ND *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__Block_byref_id_object_copy; // If variable is __block ObjC object; /// void *__Block_byref_id_object_dispose; // If variable is __block ObjC object; /// typex ND;; /// };; ///; /// It then replaces declaration of ND variable with:; /// struct __Block_byref_ND ND = {__isa=0B, __forwarding=&ND, __flags=some_flag,; /// __size=sizeof(struct __Block_byref_ND),; /// ND=initializer-if-any};; ///; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:83,Modifiability,variab,variable,83,"// If type location is missing, it is because of missing type (a warning).; // Use variable's location which is good for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:24,Modifiability,variab,variable,24,// FIXME. Handle __weak variable (BLOCK_FIELD_IS_WEAK) as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:311,Integrability,rout,routine,311,"// Complete the newly synthesized compound expression by inserting a right; // curly brace before the end of the declaration.; // FIXME: This approach avoids rewriting the initializer expression. It; // also assumes there is only one declarator. For example, the following; // isn't currently supported by this routine (in general):; //; // double __block BYREFVAR = 1.34, BYREFVAR2 = 1.37;; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:151,Safety,avoid,avoids,151,"// Complete the newly synthesized compound expression by inserting a right; // curly brace before the end of the declaration.; // FIXME: This approach avoids rewriting the initializer expression. It; // also assumes there is only one declarator. For example, the following; // isn't currently supported by this routine (in general):; //; // double __block BYREFVAR = 1.34, BYREFVAR2 = 1.37;; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:22,Modifiability,variab,variables,22,// Add inner imported variables now used in current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:161,Integrability,rout,routine,161,// We need to save the copied-in variables in nested; // blocks because it is needed at the end for some of the API generations.; // See SynthesizeBlockLiterals routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:33,Modifiability,variab,variables,33,// We need to save the copied-in variables in nested; // blocks because it is needed at the end for some of the API generations.; // See SynthesizeBlockLiterals routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:25,Modifiability,variab,variable,25,// captured nested byref variable has its address passed. Do not take; // its address again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:110,Modifiability,rewrite,rewrite,110,// Pseudo-object operations and ivar references need special; // treatment because we're going to recursively rewrite them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:23,Modifiability,rewrite,rewrite,23,// Perform a bottom up rewrite of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Performance,Perform,Perform,3,// Perform a bottom up rewrite of all children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the block body in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:42,Integrability,message,message,42,"// Before we rewrite it, put the original message expression in a comment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:13,Modifiability,rewrite,rewrite,13,"// Before we rewrite it, put the original message expression in a comment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:21,Integrability,protocol,protocol,21,"// Need to check for protocol refs (id <P>, Foo <P> *) in variable decls; // and cast exprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:58,Modifiability,variab,variable,58,"// Need to check for protocol refs (id <P>, Foo <P> *) in variable decls; // and cast exprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:470,Integrability,depend,depends,470,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:180,Modifiability,rewrite,rewrite,180,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:405,Modifiability,Rewrite,RewriteObjCForCollectionStmt,405,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:210,Safety,avoid,avoid,210,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:10,Modifiability,rewrite,rewrite,10,// Blocks rewrite rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:108,Modifiability,rewrite,rewrite,108,"// Since function prototypes don't have ParmDecl's, we check the function; // prototype. This enables us to rewrite function declarations and; // definitions using the same code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:108,Integrability,protocol,protocol,108,// Here's a great place to add any extra declarations that may be needed.; // Write out meta data for each @protocol(<expr>).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite Objective-c meta data*,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Integrability,synchroniz,synchronized,4,// @synchronized hooks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:25,Testability,test,tests,25,// We use this for clang tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:86,Safety,avoid,avoids,86,"// NOTE! Windows uses LLP64 for 64bit mode. So, cast pointer to long long; // as this avoids warning in any 64bit/32bit compilation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:40,Integrability,rout,routine,40,/// RewriteIvarOffsetComputation - This routine synthesizes computation of; /// ivar offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteIvarOffsetComputation,4,/// RewriteIvarOffsetComputation - This routine synthesizes computation of; /// ivar offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:65,Usability,simpl,simply,65,"// FIXME: The hack below doesn't work for bitfields. For now, we simply; // place all bitfields at offset 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:42,Integrability,protocol,protocols,42,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCProtocolMetaData,4,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:34,Modifiability,Rewrite,Rewrite,34,/// RewriteObjCProtocolMetaData - Rewrite protocols meta-data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:25,Integrability,protocol,protocol,25,// Do not synthesize the protocol more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:92,Integrability,protocol,protocols,92,/* struct _objc_protocol_method_list {; int protocol_method_count;; struct protocol_methods protocols[];; }; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Integrability,protocol,protocol,44,// Output instance methods declared in this protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:41,Integrability,protocol,protocol,41,// Output class methods declared in this protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:92,Integrability,protocol,protocols,92,/* struct _objc_protocol_method_list {; int protocol_method_count;; struct protocol_methods protocols[];; }; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,Integrability,protocol,protocol,44,// Output instance methods declared in this protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:13,Integrability,protocol,protocol,13,// Mark this protocol as having been generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:24,Integrability,protocol,protocol,24,// Output the top lovel protocol meta-data for the class.; /* struct _objc_protocol_list {; struct _objc_protocol_list *next;; int protocol_count;; struct _objc_protocol *class_protocols[];; }; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:24,Integrability,interface,interface,24,// Explicitly declared @interface's are already synthesized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:45,Integrability,interface,interface,45,// FIXME: Implementation of a class with no @interface (legacy) does not; // produce correct synthesis as yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols referenced in class declaration?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:358,Integrability,protocol,protocols,358,// Declaration of class/meta-class metadata; /* struct _objc_class {; struct _objc_class *isa; // or const char *root_class_name when metadata; const char *super_class_name;; char *name;; long version;; long info;; long instance_size;; struct _objc_ivar_list *ivars;; struct _objc_method_list *methods;; struct objc_cache *cache;; struct objc_protocol_list *protocols;; const char *ivar_layout;; struct _objc_class_ext *ext;; };; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:323,Performance,cache,cache,323,// Declaration of class/meta-class metadata; /* struct _objc_class {; struct _objc_class *isa; // or const char *root_class_name when metadata; const char *super_class_name;; char *name;; long version;; long info;; long instance_size;; struct _objc_ivar_list *ivars;; struct _objc_method_list *methods;; struct objc_cache *cache;; struct objc_protocol_list *protocols;; const char *ivar_layout;; struct _objc_class_ext *ext;; };; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:4,Modifiability,Rewrite,RewriteObjCCategoryImplDecl,4,/// RewriteObjCCategoryImplDecl - Rewrite metadata for each category; /// implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:34,Modifiability,Rewrite,Rewrite,34,/// RewriteObjCCategoryImplDecl - Rewrite metadata for each category; /// implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols referenced in class declaration?; // Null CDecl is case of a category implementation with no category interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:115,Integrability,interface,interface,115,// Protocols referenced in class declaration?; // Null CDecl is case of a category implementation with no category interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:184,Integrability,protocol,protocols,184,/* struct _objc_category {; char *category_name;; char *class_name;; struct _objc_method_list *instance_methods;; struct _objc_method_list *class_methods;; struct _objc_protocol_list *protocols;; // Objective-C 1.0 extensions; uint32_t size; // sizeof (struct _objc_category); struct _objc_property_list *instance_properties; // category's own; // @property decl.; };; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,RewriteObjCMethodsMetaData,3,// RewriteObjCMethodsMetaData - Rewrite methods metadata for instance or; /// class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:32,Modifiability,Rewrite,Rewrite,32,// RewriteObjCMethodsMetaData - Rewrite methods metadata for instance or; /// class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the base, but without actually doing replaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:46,Modifiability,variab,variable,46,// lookup which class implements the instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,Security,access,access,39,// Synthesize an explicit cast to gain access to the ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:46,Modifiability,variab,variable,46,// lookup which class implements the instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,Security,access,access,39,// Synthesize an explicit cast to gain access to the ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:137,Modifiability,rewrite,rewrites,137,"// Cannot delete IV->getBase(), since PE points to it.; // Replace the old base with the cast. This is important when doing; // embedded rewrites. For example, [newInv->_container addObject:0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp:9,Modifiability,Rewrite,RewriteTest,9,"//===--- RewriteTest.cpp - Rewriter playground ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a testbed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp:27,Modifiability,Rewrite,Rewriter,27,"//===--- RewriteTest.cpp - Rewriter playground ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a testbed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp:393,Testability,test,testbed,393,"//===--- RewriteTest.cpp - Rewriter playground ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a testbed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteTest.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:15,Integrability,wrap,wrap,15,// Potentially wrap the base FE action in an ARC Migrate Tool action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the base FE action in an extract api action to generate; // symbol graph as a biproduct of comilation ( enabled with; // --emit-symbol-graph option ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:69,Energy Efficiency,adapt,adaptor,69,"// If there are any AST files to merge, create a frontend action; // adaptor to perform the merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:69,Modifiability,adapt,adaptor,69,"// If there are any AST files to merge, create a frontend action; // adaptor to perform the merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:80,Performance,perform,perform,80,"// If there are any AST files to merge, create a frontend action; // adaptor to perform the merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:56,Integrability,message,message,56,// Honor -version.; //; // FIXME: Use a better -version message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:83,Modifiability,plugin,plugins,83,"// Honor -mllvm.; //; // FIXME: Remove this, one day.; // This should happen AFTER plugins have been loaded!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:101,Performance,load,loaded,101,"// Honor -mllvm.; //; // FIXME: Remove this, one day.; // This should happen AFTER plugins have been loaded!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:29,Modifiability,plugin,plugins,29,// These should happen AFTER plugins have been loaded!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:47,Performance,load,loaded,47,// These should happen AFTER plugins have been loaded!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:19,Modifiability,config,config-help,19,// Honor -analyzer-config-help.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:17,Availability,error,errors,17,"// If there were errors in processing arguments, don't do anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/adxintrin.h:23,Availability,avail,available,23,"/* Intrinsics that are available only if __ADX__ is defined. */; /// Adds unsigned 32-bit integers \a __x and \a __y, plus 0 or 1 as indicated; /// by the carry flag \a __cf. Stores the unsigned 32-bit sum in the memory; /// at \a __p, and returns the 8-bit carry-out (carry flag).; ///; /// \code{.operation}; /// temp := (__cf == 0) ? 0 : 1; /// Store32(__p, __x + __y + temp); /// result := CF; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c ADCX instruction.; ///; /// \param __cf; /// The 8-bit unsigned carry flag; any non-zero value indicates carry.; /// \param __x; /// A 32-bit unsigned addend.; /// \param __y; /// A 32-bit unsigned addend.; /// \param __p; /// Pointer to memory for storing the sum.; /// \returns The 8-bit unsigned carry-out value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/adxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/adxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:282,Performance,perform,perform,282,"/* vec_perm */; // The vperm instruction is defined architecturally with a big-endian bias.; // For little endian, we swap the input operands and invert the permute; // control vector. Only the rightmost 5 bits matter, so we could use; // a vector of all 31s instead of all 255s to perform the inversion.; // However, when the PCV is not a constant, using 255 has an advantage; // in that the vec_xor can be recognized as a vec_nor (and for P8 and; // later, possibly a vec_nand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:299,Performance,perform,perform,299,"/* vec_sum2s */; /* The vsum2sws instruction has a big-endian bias, so that the second; input vector and the result always reference big-endian elements; 1 and 3 (little-endian element 0 and 2). For ease of porting the; programmer wants elements 1 and 3 in both cases, so for little; endian we must perform some permutes. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:276,Performance,perform,perform,276,"/* vec_sums */; /* The vsumsws instruction has a big-endian bias, so that the second; input vector and the result always reference big-endian element 3; (little-endian element 0). For ease of porting the programmer; wants element 3 in both cases, so for little endian we must perform; some permutes. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:84,Availability,avail,available,84,// Take advantage of the optimized sequence for vec_all_eq when vcmpequd is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:25,Performance,optimiz,optimized,25,// Take advantage of the optimized sequence for vec_all_eq when vcmpequd is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:254,Availability,avail,available,254,"/* Power 8 Crypto functions; Note: We diverge from the current GCC implementation with regard; to cryptography and related functions as follows:; - Only the SHA and AES instructions and builtins are disabled by -mno-crypto; - The remaining ones are only available on Power8 and up so; require -mpower8-vector; The justification for this is that export requirements require that; Category:Vector.Crypto is optional (i.e. compliant hardware may not provide; support). As a result, we need to be able to turn off support for those.; The remaining ones (currently controlled by -mcrypto for GCC) still; need to be provided on compliant hardware even if Vector.Crypto is not; provided.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:3,Energy Efficiency,Power,Power,3,"/* Power 8 Crypto functions; Note: We diverge from the current GCC implementation with regard; to cryptography and related functions as follows:; - Only the SHA and AES instructions and builtins are disabled by -mno-crypto; - The remaining ones are only available on Power8 and up so; require -mpower8-vector; The justification for this is that export requirements require that; Category:Vector.Crypto is optional (i.e. compliant hardware may not provide; support). As a result, we need to be able to turn off support for those.; The remaining ones (currently controlled by -mcrypto for GCC) still; need to be provided on compliant hardware even if Vector.Crypto is not; provided.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/altivec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Performance,Perform,Perform,4,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the imaginary part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The imaginary part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the real part; /// of the \a a element is multiplied with the imaginary part of the; /// corresponding \a b elements. The two accumulated results are added, and; /// then accumulated into the corresponding row and column of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmimfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+1]); ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+0]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:404,Performance,perform,performs,404,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the imaginary part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The imaginary part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the real part; /// of the \a a element is multiplied with the imaginary part of the; /// corresponding \a b elements. The two accumulated results are added, and; /// then accumulated into the corresponding row and column of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmimfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+1]); ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+0]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Performance,Perform,Perform,4,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the real part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The real part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the negated; /// imaginary part of the \a a element is multiplied with the imaginary; /// part of the corresponding \a b elements. The two accumulated results; /// are added, and then accumulated into the corresponding row and column; /// of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmrlfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+0]); ///			tmp.fp32[n] += FP32(-a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+1]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:399,Performance,perform,performs,399,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the real part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The real part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the negated; /// imaginary part of the \a a element is multiplied with the imaginary; /// part of the corresponding \a b elements. The two accumulated results; /// are added, and then accumulated into the corresponding row and column; /// of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmrlfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+0]); ///			tmp.fp32[n] += FP32(-a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+1]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Performance,Perform,Perform,4,/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles src0 and src1 is interpreted as a complex number with; /// FP16 real part and FP16 imaginary part.; /// This function calculates the imaginary part of the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TCMMIMFP16PS </c> instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param src0; /// The 1st source tile. Max size is 1024 Bytes.; /// \param src1; /// The 2nd source tile. Max size is 1024 Bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Performance,Perform,Perform,4,/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles src0 and src1 is interpreted as a complex number with; /// FP16 real part and FP16 imaginary part.; /// This function calculates the real part of the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TCMMRLFP16PS </c> instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param src0; /// The 1st source tile. Max size is 1024 Bytes.; /// \param src1; /// The 2nd source tile. Max size is 1024 Bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:400,Availability,fault,fault,400,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:14,Deployability,configurat,configuration,14,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:98,Deployability,configurat,configuration,98,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:366,Deployability,configurat,configurations,366,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:572,Deployability,configurat,configuration,572,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:14,Modifiability,config,configuration,14,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:98,Modifiability,config,configuration,98,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:297,Modifiability,config,config,297,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:366,Modifiability,config,configurations,366,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:572,Modifiability,config,configuration,572,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Performance,Load,Load,4,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:28,Deployability,configurat,configuration,28,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:110,Deployability,configurat,configuration,110,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:450,Deployability,configurat,configuration,450,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:28,Modifiability,config,configuration,28,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:110,Modifiability,config,configuration,110,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:236,Modifiability,config,configured,236,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:450,Modifiability,config,configuration,450,"/// Stores the current tile configuration to a 64-byte memory location; /// specified by ""mem_addr"". The tile configuration includes the tile type; /// palette, the number of bytes per row, and the number of rows. If tiles; /// are not configured, all zeroes will be stored to memory.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> STTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Deployability,Release,Release,4,"/// Release the tile configuration to return to the init state, which; /// releases all storage it currently holds.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILERELEASE </c> instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:21,Deployability,configurat,configuration,21,"/// Release the tile configuration to return to the init state, which; /// releases all storage it currently holds.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILERELEASE </c> instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:75,Deployability,release,releases,75,"/// Release the tile configuration to return to the init state, which; /// releases all storage it currently holds.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILERELEASE </c> instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:21,Modifiability,config,configuration,21,"/// Release the tile configuration to return to the init state, which; /// releases all storage it currently holds.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILERELEASE </c> instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:121,Deployability,configurat,configuration,121,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:121,Modifiability,config,configuration,121,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:146,Modifiability,config,configured,146,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Performance,Load,Load,4,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:481,Performance,load,loaded,481,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:121,Deployability,configurat,configuration,121,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:121,Modifiability,config,configuration,121,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:146,Modifiability,config,configured,146,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Performance,Load,Load,4,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:336,Performance,optimiz,optimized,336,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:656,Performance,load,loaded,656,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:110,Deployability,configurat,configuration,110,"/// Store the tile specified by ""src"" to memory specifieid by ""base"" address and; /// ""stride"" using the tile configuration previously configured via; /// ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILESTORED </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be stored in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:110,Modifiability,config,configuration,110,"/// Store the tile specified by ""src"" to memory specifieid by ""base"" address and; /// ""stride"" using the tile configuration previously configured via; /// ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILESTORED </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be stored in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:135,Modifiability,config,configured,135,"/// Store the tile specified by ""src"" to memory specifieid by ""base"" address and; /// ""stride"" using the tile configuration previously configured via; /// ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILESTORED </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be stored in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:34,Modifiability,config,configured,34,"/// AMX tile register size can be configured, the maximum size is 16x64=1024; /// bytes. Since there is no 2D type in llvm IR, we use vector type to; /// represent 2D tile and the fixed size is maximum amx tile register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,Safety,avoid,avoid,50,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:143,Integrability,depend,depends,143,"/// This struct pack the shape and tile data together for user. We suggest; /// initializing the struct as early as possible, because compiler depends; /// on the shape information to do configure. The constant value is preferred; /// for optimization by compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:187,Modifiability,config,configure,187,"/// This struct pack the shape and tile data together for user. We suggest; /// initializing the struct as early as possible, because compiler depends; /// on the shape information to do configure. The constant value is preferred; /// for optimization by compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:239,Performance,optimiz,optimization,239,"/// This struct pack the shape and tile data together for user. We suggest; /// initializing the struct as early as possible, because compiler depends; /// on the shape information to do configure. The constant value is preferred; /// for optimization by compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Performance,Load,Load,4,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:402,Performance,load,loaded,402,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Performance,Load,Load,4,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:257,Performance,optimiz,optimized,257,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:577,Performance,load,loaded,577,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h:411,Deployability,release,releases,411,"/*===---- arm_acle.h - ARM Non-Neon intrinsics -----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; * The Arm C Language Extensions specifications can be found in the following; * link: https://github.com/ARM-software/acle/releases; *; * The ACLE section numbers are subject to change. When consulting the; * specifications, it is recommended to search using section titles if; * the section numbers look outdated.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_acle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h:5,Integrability,SYNCHRONIZ,SYNCHRONIZATION,5,"/* 7 SYNCHRONIZATION, BARRIER AND HINT INTRINSICS */; /* 7.3 Memory barriers */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_acle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h:17,Performance,load,load,17,/* 8.9 Armv8.7-A load/store 64-byte intrinsics */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_acle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_acle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h:30,Security,secur,secure,30,/* checks if permissions have secure field unset */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_cmse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h:26,Security,secur,secure,26,"/* sets A flag, checks if secure field unset */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_cmse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h:3,Integrability,wrap,wrap,3,/* wrap around check */; /* Check whether the range crosses a 32-bytes aligned address */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_cmse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_cmse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_neon_sve_bridge.h:47,Integrability,Bridg,Bridge,47,"/*===---- arm_neon_sve_bridge.h - ARM NEON SVE Bridge intrinsics -----------===; *; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/arm_neon_sve_bridge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/arm_neon_sve_bridge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:124,Availability,mask,mask,124,"/// Merges 8-bit integer values from either of the two 256-bit vectors; /// \a __V1 or \a __V2, as specified by the 256-bit mask \a __M and returns; /// the resulting 256-bit integer vector.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// IF __M[7+i] == 0; /// result[7+j:j] := __V1[7+j:j]; /// ELSE; /// result[7+j:j] := __V2[7+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPBLENDVB instruction.; ///; /// \param __V1; /// A 256-bit integer vector containing source values.; /// \param __V2; /// A 256-bit integer vector containing source values.; /// \param __M; /// A 256-bit integer vector, with bit [7] of each byte specifying the; /// source for each corresponding byte of the result. When the mask bit; /// is 0, the byte is copied from \a __V1; otherwise, it is copied from; /// \a __V2.; /// \returns A 256-bit integer vector containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:798,Availability,mask,mask,798,"/// Merges 8-bit integer values from either of the two 256-bit vectors; /// \a __V1 or \a __V2, as specified by the 256-bit mask \a __M and returns; /// the resulting 256-bit integer vector.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// IF __M[7+i] == 0; /// result[7+j:j] := __V1[7+j:j]; /// ELSE; /// result[7+j:j] := __V2[7+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPBLENDVB instruction.; ///; /// \param __V1; /// A 256-bit integer vector containing source values.; /// \param __V2; /// A 256-bit integer vector containing source values.; /// \param __M; /// A 256-bit integer vector, with bit [7] of each byte specifying the; /// source for each corresponding byte of the result. When the mask bit; /// is 0, the byte is copied from \a __V1; otherwise, it is copied from; /// \a __V2.; /// \returns A 256-bit integer vector containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:998,Availability,mask,mask,998,"/// Merges 16-bit integer values from either of the two 256-bit vectors; /// \a V1 or \a V2, as specified by the immediate integer operand \a M,; /// and returns the resulting 256-bit vector of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// IF M[i] == 0; /// result[7+j:j] := V1[7+j:j]; /// result[135+j:128+j] := V1[135+j:128+j]; /// ELSE; /// result[7+j:j] := V2[7+j:j]; /// result[135+j:128+j] := V2[135+j:128+j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi16(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDW instruction.; ///; /// \param V1; /// A 256-bit vector of [16 x i16] containing source values.; /// \param V2; /// A 256-bit vector of [16 x i16] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \a M[0] determines the source for elements 0 and 8, \a M[1] for; /// elements 1 and 9, and so forth.; /// \returns A 256-bit vector of [16 x i16] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1063,Availability,mask,mask,1063,"/// Merges 16-bit integer values from either of the two 256-bit vectors; /// \a V1 or \a V2, as specified by the immediate integer operand \a M,; /// and returns the resulting 256-bit vector of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// IF M[i] == 0; /// result[7+j:j] := V1[7+j:j]; /// result[135+j:128+j] := V1[135+j:128+j]; /// ELSE; /// result[7+j:j] := V2[7+j:j]; /// result[135+j:128+j] := V2[135+j:128+j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi16(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDW instruction.; ///; /// \param V1; /// A 256-bit vector of [16 x i16] containing source values.; /// \param V2; /// A 256-bit vector of [16 x i16] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \a M[0] determines the source for elements 0 and 8, \a M[1] for; /// elements 1 and 9, and so forth.; /// \returns A 256-bit vector of [16 x i16] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed comparison, but __v32qi is a char; which may be signed or unsigned, so use __v32qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:263,Integrability,wrap,wraparound,263,"/// Multiplies corresponding 16-bit elements of two 256-bit vectors of; /// [16 x i16], forming 32-bit intermediate products, and adds pairs of; /// those products to form 32-bit sums returned as elements of the; /// [8 x i32] result.; ///; /// There is only one wraparound case: when all four of the 16-bit sources; /// are \c 0x8000, the result will be \c 0x80000000.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// temp1 := __a[j+15:j] * __b[j+15:j]; /// temp2 := __a[j+31:j+16] * __b[j+31:j+16]; /// result[j+31:j] := temp1 + temp2; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMADDWD instruction.; ///; /// \param __a; /// A 256-bit vector of [16 x i16] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [16 x i16] containing one of the source operands.; /// \returns A 256-bit vector of [8 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:29,Availability,mask,mask,29,/// Creates a 32-bit integer mask from the most significant bit of each byte; /// in the 256-bit integer vector in \a __a and returns the result.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// result[i] := __a[j+7]; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVMSKB instruction.; ///; /// \param __a; /// A 256-bit integer vector containing the source bytes.; /// \returns The 32-bit integer mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:482,Availability,mask,mask,482,/// Creates a 32-bit integer mask from the most significant bit of each byte; /// in the 256-bit integer vector in \a __a and returns the result.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// result[i] := __a[j+7]; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVMSKB instruction.; ///; /// \param __a; /// A 256-bit integer vector containing the source bytes.; /// \returns The 32-bit integer mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends bytes from the 128-bit integer vector in \a __V and returns; /// the 16-bit values in the corresponding elements of a 256-bit vector; /// of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 15; /// j := i*8; /// k := i*16; /// result[k+15:k] := SignExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBW instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [16 x i16] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:572,Modifiability,extend,extended,572,/// Sign-extends bytes from the 128-bit integer vector in \a __V and returns; /// the 16-bit values in the corresponding elements of a 256-bit vector; /// of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 15; /// j := i*8; /// k := i*16; /// result[k+15:k] := SignExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBW instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [16 x i16] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends bytes from the lower half of the 128-bit integer vector in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*8; /// k := i*32; /// result[k+31:k] := SignExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBD instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [8 x i32] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:587,Modifiability,extend,extended,587,/// Sign-extends bytes from the lower half of the 128-bit integer vector in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*8; /// k := i*32; /// result[k+31:k] := SignExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBD instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [8 x i32] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends the first four bytes from the 128-bit integer vector in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[7:0]); /// result[127:64] := SignExtend(__V[15:8]); /// result[191:128] := SignExtend(__V[23:16]); /// result[255:192] := SignExtend(__V[31:24]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBQ instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:657,Modifiability,extend,extended,657,/// Sign-extends the first four bytes from the 128-bit integer vector in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[7:0]); /// result[127:64] := SignExtend(__V[15:8]); /// result[191:128] := SignExtend(__V[23:16]); /// result[255:192] := SignExtend(__V[31:24]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXBQ instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// k := i*32; /// result[k+31:k] := SignExtend(__V[j+15:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWD instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [8 x i32] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:592,Modifiability,extend,extended,592,/// Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// k := i*32; /// result[k+31:k] := SignExtend(__V[j+15:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWD instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [8 x i32] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends 16-bit elements from the lower half of the 128-bit vector of; /// [8 x i16] in \a __V and returns the 64-bit values in the corresponding; /// elements of a 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[15:0]); /// result[127:64] := SignExtend(__V[31:16]); /// result[191:128] := SignExtend(__V[47:32]); /// result[255:192] := SignExtend(__V[64:48]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWQ instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:683,Modifiability,extend,extended,683,/// Sign-extends 16-bit elements from the lower half of the 128-bit vector of; /// [8 x i16] in \a __V and returns the 64-bit values in the corresponding; /// elements of a 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[15:0]); /// result[127:64] := SignExtend(__V[31:16]); /// result[191:128] := SignExtend(__V[47:32]); /// result[255:192] := SignExtend(__V[64:48]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWQ instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[31:0]); /// result[127:64] := SignExtend(__V[63:32]); /// result[191:128] := SignExtend(__V[95:64]); /// result[255:192] := SignExtend(__V[127:96]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXDQ instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:666,Modifiability,extend,extended,666,/// Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := SignExtend(__V[31:0]); /// result[127:64] := SignExtend(__V[63:32]); /// result[191:128] := SignExtend(__V[95:64]); /// result[255:192] := SignExtend(__V[127:96]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXDQ instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the sign-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends bytes from the 128-bit integer vector in \a __V and returns; /// the 16-bit values in the corresponding elements of a 256-bit vector; /// of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 15; /// j := i*8; /// k := i*16; /// result[k+15:k] := ZeroExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBW instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [16 x i16] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:572,Modifiability,extend,extended,572,/// Zero-extends bytes from the 128-bit integer vector in \a __V and returns; /// the 16-bit values in the corresponding elements of a 256-bit vector; /// of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 15; /// j := i*8; /// k := i*16; /// result[k+15:k] := ZeroExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBW instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [16 x i16] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends bytes from the lower half of the 128-bit integer vector in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*8; /// k := i*32; /// result[k+31:k] := ZeroExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBD instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [8 x i32] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:587,Modifiability,extend,extended,587,/// Zero-extends bytes from the lower half of the 128-bit integer vector in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*8; /// k := i*32; /// result[k+31:k] := ZeroExtend(__V[j+7:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBD instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [8 x i32] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends the first four bytes from the 128-bit integer vector in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[7:0]); /// result[127:64] := ZeroExtend(__V[15:8]); /// result[191:128] := ZeroExtend(__V[23:16]); /// result[255:192] := ZeroExtend(__V[31:24]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBQ instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:657,Modifiability,extend,extended,657,/// Zero-extends the first four bytes from the 128-bit integer vector in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[7:0]); /// result[127:64] := ZeroExtend(__V[15:8]); /// result[191:128] := ZeroExtend(__V[23:16]); /// result[255:192] := ZeroExtend(__V[31:24]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXBQ instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the source bytes.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// k := i*32; /// result[k+31:k] := ZeroExtend(__V[j+15:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXWD instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [8 x i32] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:592,Modifiability,extend,extended,592,/// Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in; /// \a __V and returns the 32-bit values in the corresponding elements of a; /// 256-bit vector of [8 x i32].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// k := i*32; /// result[k+31:k] := ZeroExtend(__V[j+15:j]); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXWD instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [8 x i32] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends 16-bit elements from the lower half of the 128-bit vector of; /// [8 x i16] in \a __V and returns the 64-bit values in the corresponding; /// elements of a 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[15:0]); /// result[127:64] := ZeroExtend(__V[31:16]); /// result[191:128] := ZeroExtend(__V[47:32]); /// result[255:192] := ZeroExtend(__V[64:48]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWQ instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:683,Modifiability,extend,extended,683,/// Zero-extends 16-bit elements from the lower half of the 128-bit vector of; /// [8 x i16] in \a __V and returns the 64-bit values in the corresponding; /// elements of a 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[15:0]); /// result[127:64] := ZeroExtend(__V[31:16]); /// result[191:128] := ZeroExtend(__V[47:32]); /// result[255:192] := ZeroExtend(__V[64:48]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVSXWQ instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:9,Modifiability,extend,extends,9,/// Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[31:0]); /// result[127:64] := ZeroExtend(__V[63:32]); /// result[191:128] := ZeroExtend(__V[95:64]); /// result[255:192] := ZeroExtend(__V[127:96]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXDQ instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:666,Modifiability,extend,extended,666,/// Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in; /// \a __V and returns the 64-bit values in the corresponding elements of a; /// 256-bit vector of [4 x i64].; ///; /// \code{.operation}; /// result[63:0] := ZeroExtend(__V[31:0]); /// result[127:64] := ZeroExtend(__V[63:32]); /// result[191:128] := ZeroExtend(__V[95:64]); /// result[255:192] := ZeroExtend(__V[127:96]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVZXDQ instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32] containing the source values.; /// \returns A 256-bit vector of [4 x i64] containing the zero-extended; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:285,Modifiability,extend,extended,285,"/// Computes four sum of absolute difference (SAD) operations on sets of eight; /// unsigned 8-bit integers from the 256-bit integer vectors \a __a and; /// \a __b.; ///; /// One SAD result is computed for each set of eight bytes from \a __a and; /// eight bytes from \a __b. The zero-extended SAD value is returned in the; /// corresponding 64-bit element of the result.; ///; /// A single SAD operation takes the differences between the corresponding; /// bytes of \a __a and \a __b, takes the absolute value of each difference,; /// and sums these eight values to form one 16-bit result. This operation; /// is repeated four times with successive sets of eight bytes.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// temp0 := ABS(__a[j+7:j] - __b[j+7:j]); /// temp1 := ABS(__a[j+15:j+8] - __b[j+15:j+8]); /// temp2 := ABS(__a[j+23:j+16] - __b[j+23:j+16]); /// temp3 := ABS(__a[j+31:j+24] - __b[j+31:j+24]); /// temp4 := ABS(__a[j+39:j+32] - __b[j+39:j+32]); /// temp5 := ABS(__a[j+47:j+40] - __b[j+47:j+40]); /// temp6 := ABS(__a[j+55:j+48] - __b[j+55:j+48]); /// temp7 := ABS(__a[j+63:j+56] - __b[j+63:j+56]); /// result[j+15:j] := temp0 + temp1 + temp2 + temp3 +; /// temp4 + temp5 + temp6 + temp7; /// result[j+63:j+16] := 0; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPSADBW instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns A 256-bit integer vector containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:141,Integrability,depend,depending,141,"/// Sets each byte of the result to the corresponding byte of the 256-bit; /// integer vector in \a __a, the negative of that byte, or zero, depending; /// on whether the corresponding byte of the 256-bit integer vector in; /// \a __b is greater than zero, less than zero, or equal to zero,; /// respectively.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector].; /// \returns A 256-bit integer vector containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:161,Integrability,depend,depending,161,"/// Sets each element of the result to the corresponding element of the; /// 256-bit vector of [16 x i16] in \a __a, the negative of that element,; /// or zero, depending on whether the corresponding element of the 256-bit; /// vector of [16 x i16] in \a __b is greater than zero, less than zero, or; /// equal to zero, respectively.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 256-bit vector of [16 x i16].; /// \param __b; /// A 256-bit vector of [16 x i16].; /// \returns A 256-bit vector of [16 x i16] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:160,Integrability,depend,depending,160,"/// Sets each element of the result to the corresponding element of the; /// 256-bit vector of [8 x i32] in \a __a, the negative of that element, or; /// zero, depending on whether the corresponding element of the 256-bit; /// vector of [8 x i32] in \a __b is greater than zero, less than zero, or; /// equal to zero, respectively.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32].; /// \returns A 256-bit vector of [8 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:4,Performance,Load,Loads,4,/// Loads the 256-bit integer vector from memory \a __V using a non-temporal; /// memory hint and returns the vector. \a __V must be aligned on a 32-byte; /// boundary.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VMOVNTDQA instruction.; ///; /// \param __V; /// A pointer to the 32-byte aligned memory containing the vector to load.; /// \returns A 256-bit integer vector loaded from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:366,Performance,load,load,366,/// Loads the 256-bit integer vector from memory \a __V using a non-temporal; /// memory hint and returns the vector. \a __V must be aligned on a 32-byte; /// boundary.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VMOVNTDQA instruction.; ///; /// \param __V; /// A pointer to the 32-byte aligned memory containing the vector to load.; /// \returns A 256-bit integer vector loaded from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:411,Performance,load,loaded,411,/// Loads the 256-bit integer vector from memory \a __V using a non-temporal; /// memory hint and returns the vector. \a __V must be aligned on a 32-byte; /// boundary.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VMOVNTDQA instruction.; ///; /// \param __V; /// A pointer to the 32-byte aligned memory containing the vector to load.; /// \returns A 256-bit integer vector loaded from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:916,Availability,mask,mask,916,"/// Merges 32-bit integer elements from either of the two 128-bit vectors of; /// [4 x i32] in \a V1 or \a V2 to the result's 128-bit vector of [4 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_blend_epi32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing source values.; /// \param V2; /// A 128-bit vector of [4 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [3:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \returns A 128-bit vector of [4 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:981,Availability,mask,mask,981,"/// Merges 32-bit integer elements from either of the two 128-bit vectors of; /// [4 x i32] in \a V1 or \a V2 to the result's 128-bit vector of [4 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_blend_epi32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing source values.; /// \param V2; /// A 128-bit vector of [4 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [3:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \returns A 128-bit vector of [4 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:915,Availability,mask,mask,915,"/// Merges 32-bit integer elements from either of the two 256-bit vectors of; /// [8 x i32] in \a V1 or \a V2 to return a 256-bit vector of [8 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi32(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x i32] containing source values.; /// \param V2; /// A 256-bit vector of [8 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is is copied from \a V2.; /// \returns A 256-bit vector of [8 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:980,Availability,mask,mask,980,"/// Merges 32-bit integer elements from either of the two 256-bit vectors of; /// [8 x i32] in \a V1 or \a V2 to return a 256-bit vector of [8 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi32(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x i32] containing source values.; /// \param V2; /// A 256-bit vector of [8 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is is copied from \a V2.; /// \returns A 256-bit vector of [8 x i32] containing the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:143,Availability,mask,mask,143,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:708,Availability,mask,mask,708,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,Performance,load,loads,18,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:626,Performance,load,loading,626,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:778,Performance,load,loaded,778,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:142,Availability,mask,mask,142,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:707,Availability,mask,mask,707,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,Performance,load,loads,18,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:625,Performance,load,loading,625,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:777,Performance,load,loaded,777,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:142,Availability,mask,mask,142,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:707,Availability,mask,mask,707,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,Performance,load,loads,18,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:625,Performance,load,loading,625,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:777,Performance,load,loaded,777,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:141,Availability,mask,mask,141,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:706,Availability,mask,mask,706,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,Performance,load,loads,18,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:624,Performance,load,loading,624,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:776,Performance,load,loaded,776,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:194,Availability,mask,mask,194,"/// Conditionally stores eight 32-bit integer elements from the 256-bit vector; /// of [8 x i32] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// Store32(__X+(i*4), __Y[j+31:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \param __Y; /// A 256-bit vector of [8 x i32] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:669,Availability,mask,mask,669,"/// Conditionally stores eight 32-bit integer elements from the 256-bit vector; /// of [8 x i32] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// Store32(__X+(i*4), __Y[j+31:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \param __Y; /// A 256-bit vector of [8 x i32] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:193,Availability,mask,mask,193,"/// Conditionally stores four 64-bit integer elements from the 256-bit vector; /// of [4 x i64] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// Store64(__X+(i*8), __Y[j+63:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \param __Y; /// A 256-bit vector of [4 x i64] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:668,Availability,mask,mask,668,"/// Conditionally stores four 64-bit integer elements from the 256-bit vector; /// of [4 x i64] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// Store64(__X+(i*8), __Y[j+63:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \param __Y; /// A 256-bit vector of [4 x i64] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:193,Availability,mask,mask,193,"/// Conditionally stores four 32-bit integer elements from the 128-bit vector; /// of [4 x i32] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// Store32(__X+(i*4), __Y[j+31:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:668,Availability,mask,mask,668,"/// Conditionally stores four 32-bit integer elements from the 128-bit vector; /// of [4 x i32] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// Store32(__X+(i*4), __Y[j+31:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:192,Availability,mask,mask,192,"/// Conditionally stores two 64-bit integer elements from the 128-bit vector; /// of [2 x i64] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// Store64(__X+(i*8), __Y[j+63:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \param __Y; /// A 128-bit vector of [2 x i64] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:667,Availability,mask,mask,667,"/// Conditionally stores two 64-bit integer elements from the 128-bit vector; /// of [2 x i64] in \a __Y to memory \a __X, if the most significant bit of; /// the corresponding element in the mask \a __M is set; otherwise, the; /// memory element is unchanged.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// Store64(__X+(i*8), __Y[j+63:j]); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for storing values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \param __Y; /// A 128-bit vector of [2 x i64] containing the values to store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:259,Availability,mask,mask,259,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:409,Availability,mask,mask,409,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:700,Availability,mask,mask,700,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:888,Availability,mask,mask,888,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1120,Availability,mask,mask,1120,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1178,Availability,mask,mask,1178,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1237,Availability,mask,mask,1237,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1264,Availability,mask,mask,1264,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1285,Availability,mask,mask,1285,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:963,Performance,load,loading,963,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1385,Performance,load,loaded,1385,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:260,Availability,mask,mask,260,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:410,Availability,mask,mask,410,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:704,Availability,mask,mask,704,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:892,Availability,mask,mask,892,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1081,Availability,mask,mask,1081,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1139,Availability,mask,mask,1139,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1198,Availability,mask,mask,1198,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1225,Availability,mask,mask,1225,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1246,Availability,mask,mask,1246,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:967,Performance,load,loading,967,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1346,Performance,load,loaded,1346,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:259,Availability,mask,mask,259,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:409,Availability,mask,mask,409,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:700,Availability,mask,mask,700,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:888,Availability,mask,mask,888,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1077,Availability,mask,mask,1077,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1135,Availability,mask,mask,1135,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1194,Availability,mask,mask,1194,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1221,Availability,mask,mask,1221,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1242,Availability,mask,mask,1242,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:963,Performance,load,loading,963,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1342,Performance,load,loaded,1342,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:260,Availability,mask,mask,260,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:410,Availability,mask,mask,410,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:704,Availability,mask,mask,704,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:892,Availability,mask,mask,892,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1081,Availability,mask,mask,1081,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1139,Availability,mask,mask,1139,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1198,Availability,mask,mask,1198,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1225,Availability,mask,mask,1225,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1246,Availability,mask,mask,1246,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:967,Performance,load,loading,967,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1346,Performance,load,loaded,1346,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:258,Availability,mask,mask,258,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:408,Availability,mask,mask,408,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:695,Availability,mask,mask,695,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:882,Availability,mask,mask,882,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1071,Availability,mask,mask,1071,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1128,Availability,mask,mask,1128,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1187,Availability,mask,mask,1187,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1214,Availability,mask,mask,1214,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1235,Availability,mask,mask,1235,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,Performance,load,loading,957,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1335,Performance,load,loaded,1335,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:259,Availability,mask,mask,259,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:409,Availability,mask,mask,409,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:699,Availability,mask,mask,699,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:886,Availability,mask,mask,886,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1075,Availability,mask,mask,1075,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1132,Availability,mask,mask,1132,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1191,Availability,mask,mask,1191,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1218,Availability,mask,mask,1218,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1239,Availability,mask,mask,1239,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:961,Performance,load,loading,961,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1339,Performance,load,loaded,1339,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:257,Availability,mask,mask,257,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:471,Availability,mask,mask,471,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:783,Availability,mask,mask,783,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:970,Availability,mask,mask,970,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1197,Availability,mask,mask,1197,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1254,Availability,mask,mask,1254,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1313,Availability,mask,mask,1313,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1340,Availability,mask,mask,1340,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1361,Availability,mask,mask,1361,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1083,Performance,load,loading,1083,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1461,Performance,load,loaded,1461,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:258,Availability,mask,mask,258,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:408,Availability,mask,mask,408,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:698,Availability,mask,mask,698,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:885,Availability,mask,mask,885,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1074,Availability,mask,mask,1074,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1131,Availability,mask,mask,1131,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1190,Availability,mask,mask,1190,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1217,Availability,mask,mask,1217,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1238,Availability,mask,mask,1238,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:960,Performance,load,loading,960,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1338,Performance,load,loaded,1338,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:247,Availability,mask,mask,247,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:397,Availability,mask,mask,397,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:688,Availability,mask,mask,688,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:873,Availability,mask,mask,873,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1062,Availability,mask,mask,1062,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1117,Availability,mask,mask,1117,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1176,Availability,mask,mask,1176,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1203,Availability,mask,mask,1203,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1224,Availability,mask,mask,1224,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:948,Performance,load,loading,948,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1324,Performance,load,loaded,1324,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:248,Availability,mask,mask,248,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:398,Availability,mask,mask,398,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:692,Availability,mask,mask,692,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:877,Availability,mask,mask,877,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1066,Availability,mask,mask,1066,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1121,Availability,mask,mask,1121,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1180,Availability,mask,mask,1180,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1207,Availability,mask,mask,1207,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1228,Availability,mask,mask,1228,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:952,Performance,load,loading,952,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1328,Performance,load,loaded,1328,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:246,Availability,mask,mask,246,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:460,Availability,mask,mask,460,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:776,Availability,mask,mask,776,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:961,Availability,mask,mask,961,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1181,Availability,mask,mask,1181,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1236,Availability,mask,mask,1236,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1295,Availability,mask,mask,1295,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1322,Availability,mask,mask,1322,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1343,Availability,mask,mask,1343,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1074,Performance,load,loading,1074,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1443,Performance,load,loaded,1443,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:247,Availability,mask,mask,247,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:397,Availability,mask,mask,397,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:691,Availability,mask,mask,691,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:876,Availability,mask,mask,876,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1065,Availability,mask,mask,1065,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1120,Availability,mask,mask,1120,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1179,Availability,mask,mask,1179,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1206,Availability,mask,mask,1206,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1227,Availability,mask,mask,1227,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:951,Performance,load,loading,951,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1327,Performance,load,loaded,1327,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:246,Availability,mask,mask,246,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:396,Availability,mask,mask,396,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:693,Availability,mask,mask,693,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:878,Availability,mask,mask,878,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1110,Availability,mask,mask,1110,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1165,Availability,mask,mask,1165,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1224,Availability,mask,mask,1224,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1251,Availability,mask,mask,1251,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1272,Availability,mask,mask,1272,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:953,Performance,load,loading,953,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1372,Performance,load,loaded,1372,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:247,Availability,mask,mask,247,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:397,Availability,mask,mask,397,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:697,Availability,mask,mask,697,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:882,Availability,mask,mask,882,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1071,Availability,mask,mask,1071,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1126,Availability,mask,mask,1126,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1185,Availability,mask,mask,1185,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1212,Availability,mask,mask,1212,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1233,Availability,mask,mask,1233,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,Performance,load,loading,957,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1333,Performance,load,loaded,1333,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:246,Availability,mask,mask,246,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:396,Availability,mask,mask,396,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:693,Availability,mask,mask,693,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:878,Availability,mask,mask,878,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1067,Availability,mask,mask,1067,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1122,Availability,mask,mask,1122,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1181,Availability,mask,mask,1181,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1208,Availability,mask,mask,1208,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1229,Availability,mask,mask,1229,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:953,Performance,load,loading,953,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1329,Performance,load,loaded,1329,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:247,Availability,mask,mask,247,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:397,Availability,mask,mask,397,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:697,Availability,mask,mask,697,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:882,Availability,mask,mask,882,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1071,Availability,mask,mask,1071,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1126,Availability,mask,mask,1126,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1185,Availability,mask,mask,1185,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1212,Availability,mask,mask,1212,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1233,Availability,mask,mask,1233,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,Performance,load,loading,957,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1333,Performance,load,loaded,1333,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:582,Performance,load,loading,582,"/// Gathers two 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_i32gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:586,Performance,load,loading,586,"/// Gathers four 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_i32gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:582,Performance,load,loading,582,"/// Gathers two 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_i64gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:586,Performance,load,loading,586,"/// Gathers four 64-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_i64gather_pd(const double *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,Performance,load,loading,581,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_i32gather_ps(const float *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,Performance,load,loading,585,"/// Gathers eight 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_i32gather_ps(const float *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:659,Performance,load,loading,659,"/// Gathers two 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The upper two; /// elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_i64gather_ps(const float *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:584,Performance,load,loading,584,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+64:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_i64gather_ps(const float *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:583,Performance,load,loading,583,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i32gather_epi32(const int *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:587,Performance,load,loading,587,"/// Gathers eight 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i32gather_epi32(const int *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:654,Performance,load,loading,654,"/// Gathers two 32-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [2 x i64] in \a i. The upper two elements; /// of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i64gather_epi32(const int *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:579,Performance,load,loading,579,"/// Gathers four 32-bit integer values from memory \a m using scaled indexes; /// from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_i64gather_epi32(const int *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,Performance,load,loading,581,"/// Gathers two 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i32gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,Performance,load,loading,585,"/// Gathers four 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i32gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,Performance,load,loading,581,"/// Gathers two 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [2 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i64gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,Performance,load,loading,585,"/// Gathers four 64-bit integer values from memory \a m using scaled indexes; /// from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i64gather_epi64(const long long *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:307,Modifiability,extend,extended,307,"/// Convert One BF16 Data to One Single Float Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic does not correspond to a specific instruction.; ///; /// \param __A; /// A bfloat data.; /// \returns A float data whose sign field and exponent field keep unchanged,; /// and fraction field is extended to 23 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:379,Availability,mask,mask,379,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __B; /// A 512-bit vector of [16 x float].; /// \param __W; /// A 512-bit vector of [32 x bfloat].; /// \param __U; /// A 32-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 512-bit vector of [32 x bfloat] whose lower 256 bits come from; /// conversion of __B, and higher 256 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:323,Availability,mask,mask,323,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __B; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 32-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 512-bit vector of [32 x bfloat] whose lower 256 bits come from; /// conversion of __B, and higher 256 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:315,Availability,mask,mask,315,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __W; /// A 256-bit vector of [16 x bfloat].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 256-bit vector of [16 x bfloat] come from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:259,Availability,mask,mask,259,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 256-bit vector of [16 x bfloat] come from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:387,Availability,mask,mask,387,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [32 x bfloat].; /// \param __B; /// A 512-bit vector of [32 x bfloat].; /// \param __D; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 512-bit vector of [16 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:387,Availability,mask,mask,387,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [32 x bfloat].; /// \param __B; /// A 512-bit vector of [32 x bfloat].; /// \param __D; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 512-bit vector of [16 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 16-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:141,Availability,mask,mask,141,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 16-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:194,Availability,mask,mask,194,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 16-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 512-bit vector of [16 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 16-bit mask.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:223,Availability,mask,mask,223,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 512-bit vector of [16 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 16-bit mask.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:274,Availability,mask,mask,274,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 512-bit vector of [16 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 16-bit mask.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v32qi is a char; which may be signed or unsigned, so use __v32qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:92,Integrability,interface,interface,92,/* We need an explicitly signed variant for char. Note that this shouldn't; * appear in the interface though. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:8,Performance,load,load,8,/* SIMD load ops */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:3,Availability,Mask,Mask,3,/* Mask ops */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:66,Testability,log,logic,66,"/// \enum _MM_TERNLOG_ENUM; /// A helper to represent the ternary logic operations among vector \a A,; /// \a B and \a C. The representation is passed to \a imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:7,Testability,Test,Test,7,/* Bit Test */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:665,Performance,perform,performed,665,"/* Vector-reduction arithmetic accepts vectors as inputs and produces scalars as; * outputs. This class of vector operation forms the basis of many scientific; * computations. In vector-reduction arithmetic, the evaluation order is; * independent of the order of the input elements of V. * For floating-point intrinsics:; * 1. When using fadd/fmul intrinsics, the order of operations within the; * vector is unspecified (associative math).; * 2. When using fmin/fmax intrinsics, NaN or -0.0 elements within the vector; * produce unspecified results. * Used bisection method. At each step, we partition the vector with previous; * step in half, and the operation is performed on its two halves.; * This takes log2(n) steps where n is the number of elements in the vector.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:193,Energy Efficiency,reduce,reduce-fadd-intrinsic,193,"// -0.0 is used to ignore the start value since it is the neutral value of; // floating point addition. For more information, please refer to; // https://llvm.org/docs/LangRef.html#llvm-vector-reduce-fadd-intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Performance,Load,Loads,4,/// Loads 8 double-precision (64-bit) floating-point elements stored at memory; /// locations starting at location \a base_addr at packed 32-bit integer indices; /// stored in the lower half of \a vindex scaled by \a scale them in dst.; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:241,Availability,mask,mask,241,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:302,Availability,mask,mask,302,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:494,Availability,mask,mask,494,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Performance,Load,Loads,4,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Performance,Load,Loads,4,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst.; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:224,Availability,mask,mask,224,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:290,Availability,mask,mask,290,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:477,Availability,mask,mask,477,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Performance,Load,Loads,4,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:261,Availability,mask,mask,261,/// Stores 8 packed double-precision (64-bit) floating-point elements in \a v1; /// to memory locations starting at location \a base_addr at packed 32-bit; /// integer indices stored in \a vindex scaled by \a scale. Only those elements; /// whose corresponding mask bit is set in writemask \a mask are written to; /// memory.; ///; /// This intrinsic corresponds to the <c> VSCATTERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:293,Availability,mask,mask,293,/// Stores 8 packed double-precision (64-bit) floating-point elements in \a v1; /// to memory locations starting at location \a base_addr at packed 32-bit; /// integer indices stored in \a vindex scaled by \a scale. Only those elements; /// whose corresponding mask bit is set in writemask \a mask are written to; /// memory.; ///; /// This intrinsic corresponds to the <c> VSCATTERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:492,Availability,mask,mask,492,/// Stores 8 packed double-precision (64-bit) floating-point elements in \a v1; /// to memory locations starting at location \a base_addr at packed 32-bit; /// integer indices stored in \a vindex scaled by \a scale. Only those elements; /// whose corresponding mask bit is set in writemask \a mask are written to; /// memory.; ///; /// This intrinsic corresponds to the <c> VSCATTERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:225,Availability,mask,mask,225,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:265,Availability,mask,mask,265,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:479,Availability,mask,mask,479,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h:3,Performance,load,loads,3,// loads with vmovsh:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:375,Availability,mask,mask,375,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:320,Availability,mask,mask,320,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:377,Availability,mask,mask,377,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [16 x bfloat].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:321,Availability,mask,mask,321,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,Availability,mask,mask,312,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,Availability,mask,mask,257,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,Availability,mask,mask,312,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,Availability,mask,mask,257,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,Availability,mask,mask,383,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,Availability,mask,mask,383,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:386,Availability,mask,mask,386,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:385,Availability,mask,mask,385,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:140,Availability,mask,mask,140,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:193,Availability,mask,mask,193,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:140,Availability,mask,mask,140,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:193,Availability,mask,mask,193,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:222,Availability,mask,mask,222,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:272,Availability,mask,mask,272,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:325,Availability,mask,mask,325,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:222,Availability,mask,mask,222,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:272,Availability,mask,mask,272,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:325,Availability,mask,mask,325,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:127,Energy Efficiency,charge,charge,127,"/*===------ avx512vlvp2intersectintrin.h - VL VP2INTERSECT intrinsics ------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:1021,Integrability,CONTRACT,CONTRACT,1021,"/*===------ avx512vlvp2intersectintrin.h - VL VP2INTERSECT intrinsics ------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:415,Availability,mask,mask,415,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:467,Availability,mask,mask,467,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:415,Availability,mask,mask,415,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:467,Availability,mask,mask,467,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:128,Energy Efficiency,charge,charge,128,"/*===------- avx512vpintersectintrin.h - VP2INTERSECT intrinsics ------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:1022,Integrability,CONTRACT,CONTRACT,1022,"/*===------- avx512vpintersectintrin.h - VP2INTERSECT intrinsics ------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:471,Availability,mask,mask,471,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:92,Integrability,interface,interface,92,/* We need an explicitly signed variant for char. Note that this shouldn't; * appear in the interface though. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:922,Availability,Down,Downward,922,"/// Rounds the values in a 256-bit vector of [4 x double] as specified; /// by the byte operand. The source values are rounded to integer values and; /// returned as 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_round_pd(__m256d V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [4 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:695,Deployability,update,updated,695,"/// Rounds the values in a 256-bit vector of [4 x double] as specified; /// by the byte operand. The source values are rounded to integer values and; /// returned as 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_round_pd(__m256d V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [4 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:901,Availability,Down,Downward,901,"/// Rounds the values stored in a 256-bit vector of [8 x float] as; /// specified by the byte operand. The source values are rounded to integer; /// values and returned as floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_round_ps(__m256 V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [8 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:674,Deployability,update,updated,674,"/// Rounds the values stored in a 256-bit vector of [8 x float] as; /// specified by the byte operand. The source values are rounded to integer; /// values and returned as floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_round_ps(__m256 V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [8 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,Availability,down,down,11,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:106,Availability,down,down,106,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:507,Availability,down,down,507,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,Availability,down,down,11,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:105,Availability,down,down,105,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:478,Availability,down,down,478,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:19,Performance,Perform,Performs,19,/* Logical */; /// Performs a bitwise AND of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:3,Testability,Log,Logical,3,/* Logical */; /// Performs a bitwise AND of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of two 256-bit vectors of [4 x double], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [4 x double] containing the right source operand.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of two 256-bit vectors of [8 x float], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [8 x float] containing the right source operand.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise XOR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise XOR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:560,Availability,mask,mask,560,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:645,Availability,mask,mask,645,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:710,Availability,mask,mask,710,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:843,Availability,mask,mask,843,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:534,Availability,mask,mask,534,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:619,Availability,mask,mask,619,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:684,Availability,mask,mask,684,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:817,Availability,mask,mask,817,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:441,Availability,mask,mask,441,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:542,Availability,mask,mask,542,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:622,Availability,mask,mask,622,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:756,Availability,mask,mask,756,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:438,Availability,mask,mask,438,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:562,Availability,mask,mask,562,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:642,Availability,mask,mask,642,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:771,Availability,mask,mask,771,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:864,Availability,mask,mask,864,"/* Vector shuffle */; /// Selects 8 float values from the 256-bit operands of [8 x float], as; /// specified by the immediate value operand.; ///; /// The four selected elements in each operand are copied to the destination; /// according to the bits specified in the immediate operand. The selected; /// elements from the first 256-bit operand are copied to bits [63:0] and; /// bits [191:128] of the destination, and the selected elements from the; /// second 256-bit operand are copied to bits [127:64] and bits [255:192] of; /// the destination. For example, if bits [7:0] of the immediate operand; /// contain a value of 0xFF, the 256-bit destination vector would contain the; /// following values: b[7], b[7], a[7], a[7], b[3], b[3], a[3], a[3].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:1434,Availability,mask,mask,1434,"ied to bits [127:64] and bits [255:192] of; /// the destination. For example, if bits [7:0] of the immediate operand; /// contain a value of 0xFF, the 256-bit destination vector would contain the; /// following values: b[7], b[7], a[7], a[7], b[3], b[3], a[3], a[3].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:2592,Availability,mask,mask,2592,"56_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. \n; /// 11: Bits [127:96] and [255:224] are copied from the selected operand. \n; /// Note: To generate a mask, you can use the \c _MM_SHUFFLE macro.; /// <c>_MM_SHUFFLE(b6, b4, b2, b0)</c> can create an 8-bit mask of the form; /// <c>[b6, b4, b2, b0]</c>.; /// \returns A 256-bit vector of [8 x float] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:2696,Availability,mask,mask,2696,"56_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. \n; /// 11: Bits [127:96] and [255:224] are copied from the selected operand. \n; /// Note: To generate a mask, you can use the \c _MM_SHUFFLE macro.; /// <c>_MM_SHUFFLE(b6, b4, b2, b0)</c> can create an 8-bit mask of the form; /// <c>[b6, b4, b2, b0]</c>.; /// \returns A 256-bit vector of [8 x float] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:694,Availability,mask,mask,694,"/// Selects four double-precision values from the 256-bit operands of; /// [4 x double], as specified by the immediate value operand.; ///; /// The selected elements from the first 256-bit operand are copied to bits; /// [63:0] and bits [191:128] in the destination, and the selected elements; /// from the second 256-bit operand are copied to bits [127:64] and bits; /// [255:192] in the destination. For example, if bits [3:0] of the immediate; /// operand contain a value of 0xF, the 256-bit destination vector would; /// contain the following values: b[3], a[3], b[1], a[1].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_shuffle_pd(__m256d a, __m256d b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPD </c> instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double].; /// \param b; /// A 256-bit vector of [4 x double].; /// \param mask; /// An immediate value containing 8-bit values specifying which elements to; /// copy from \a a and \a b: \n; /// Bit [0]=0: Bits [63:0] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [0]=1: Bits [127:64] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [1]=0: Bits [63:0] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [1]=1: Bits [127:64] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [2]=0: Bits [191:128] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [2]=1: Bits [255:192] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [3]=0: Bits [191:128] are copied from \a b to bits [255:192] of the; /// destination. \n; /// Bit [3]=1: Bits [255:192] are copied from \a b to bits [255:192] of the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:912,Availability,mask,mask,912,"/// Selects four double-precision values from the 256-bit operands of; /// [4 x double], as specified by the immediate value operand.; ///; /// The selected elements from the first 256-bit operand are copied to bits; /// [63:0] and bits [191:128] in the destination, and the selected elements; /// from the second 256-bit operand are copied to bits [127:64] and bits; /// [255:192] in the destination. For example, if bits [3:0] of the immediate; /// operand contain a value of 0xF, the 256-bit destination vector would; /// contain the following values: b[3], a[3], b[1], a[1].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_shuffle_pd(__m256d a, __m256d b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPD </c> instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double].; /// \param b; /// A 256-bit vector of [4 x double].; /// \param mask; /// An immediate value containing 8-bit values specifying which elements to; /// copy from \a a and \a b: \n; /// Bit [0]=0: Bits [63:0] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [0]=1: Bits [127:64] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [1]=0: Bits [63:0] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [1]=1: Bits [127:64] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [2]=0: Bits [191:128] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [2]=1: Bits [255:192] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [3]=0: Bits [191:128] are copied from \a b to bits [255:192] of the; /// destination. \n; /// Bit [3]=1: Bits [255:192] are copied from \a b to bits [255:192] of the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:288,Usability,clear,cleared,288,"/// Compares each of the corresponding scalar double-precision values of; /// two 128-bit vectors of [2 x double], using the operation specified by the; /// immediate integer operand.; ///; /// If the result is true, all 64 bits of the destination vector are set;; /// otherwise they are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_cmp_sd(__m128d a, __m128d b, const int c);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCMPSD </c> instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double].; /// \param b; /// A 128-bit vector of [2 x double].; /// \param c; /// An immediate integer operand, with bits [4:0] specifying which comparison; /// operation to use: \n; /// 0x00: Equal (ordered, non-signaling) \n; /// 0x01: Less-than (ordered, signaling) \n; /// 0x02: Less-than-or-equal (ordered, signaling) \n; /// 0x03: Unordered (non-signaling) \n; /// 0x04: Not-equal (unordered, non-signaling) \n; /// 0x05: Not-less-than (unordered, signaling) \n; /// 0x06: Not-less-than-or-equal (unordered, signaling) \n; /// 0x07: Ordered (non-signaling) \n; /// 0x08: Equal (unordered, non-signaling) \n; /// 0x09: Not-greater-than-or-equal (unordered, signaling) \n; /// 0x0A: Not-greater-than (unordered, signaling) \n; /// 0x0B: False (ordered, non-signaling) \n; /// 0x0C: Not-equal (ordered, non-signaling) \n; /// 0x0D: Greater-than-or-equal (ordered, signaling) \n; /// 0x0E: Greater-than (ordered, signaling) \n; /// 0x0F: True (unordered, non-signaling) \n; /// 0x10: Equal (ordered, signaling) \n; /// 0x11: Less-than (ordered, non-signaling) \n; /// 0x12: Less-than-or-equal (ordered, non-signaling) \n; /// 0x13: Unordered (signaling) \n; /// 0x14: Not-equal (unordered, signaling) \n; /// 0x15: Not-less-than (unordered, non-signaling) \n; /// 0x16: Not-less-than-or-equal (unordered, non-signaling) \n; /// 0x17: Ordered (signaling) \n; /// 0x18: Equal (unordered, signaling) \n; /// 0x19: Not-greater-than-or-equal (unordered, non-si",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:270,Usability,clear,cleared,270,"/// Compares each of the corresponding scalar values of two 128-bit; /// vectors of [4 x float], using the operation specified by the immediate; /// integer operand.; ///; /// If the result is true, all 32 bits of the destination vector are set;; /// otherwise they are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_cmp_ss(__m128 a, __m128 b, const int c);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCMPSS </c> instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float].; /// \param b; /// A 128-bit vector of [4 x float].; /// \param c; /// An immediate integer operand, with bits [4:0] specifying which comparison; /// operation to use: \n; /// 0x00: Equal (ordered, non-signaling) \n; /// 0x01: Less-than (ordered, signaling) \n; /// 0x02: Less-than-or-equal (ordered, signaling) \n; /// 0x03: Unordered (non-signaling) \n; /// 0x04: Not-equal (unordered, non-signaling) \n; /// 0x05: Not-less-than (unordered, signaling) \n; /// 0x06: Not-less-than-or-equal (unordered, signaling) \n; /// 0x07: Ordered (non-signaling) \n; /// 0x08: Equal (unordered, non-signaling) \n; /// 0x09: Not-greater-than-or-equal (unordered, signaling) \n; /// 0x0A: Not-greater-than (unordered, signaling) \n; /// 0x0B: False (ordered, non-signaling) \n; /// 0x0C: Not-equal (ordered, non-signaling) \n; /// 0x0D: Greater-than-or-equal (ordered, signaling) \n; /// 0x0E: Greater-than (ordered, signaling) \n; /// 0x0F: True (unordered, non-signaling) \n; /// 0x10: Equal (ordered, signaling) \n; /// 0x11: Less-than (ordered, non-signaling) \n; /// 0x12: Less-than-or-equal (ordered, non-signaling) \n; /// 0x13: Unordered (signaling) \n; /// 0x14: Not-equal (unordered, signaling) \n; /// 0x15: Not-less-than (unordered, non-signaling) \n; /// 0x16: Not-less-than-or-equal (unordered, non-signaling) \n; /// 0x17: Ordered (signaling) \n; /// 0x18: Equal (unordered, signaling) \n; /// 0x19: Not-greater-than-or-equal (unordered, non-signaling) \n; /// 0x1A: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:580,Modifiability,extend,extended,580,"/// Takes a [8 x i32] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi32(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit vector of [8 x i32].; /// \param N; /// An immediate integer operand with bits [2:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 32 bits of extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:595,Modifiability,extend,extended,595,"/// Takes a [16 x i16] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi16(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [16 x i16].; /// \param N; /// An immediate integer operand with bits [3:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 16 bits of zero extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:591,Modifiability,extend,extended,591,"/// Takes a [32 x i8] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi8(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [32 x i8].; /// \param N; /// An immediate integer operand with bits [4:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 8 bits of zero extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:594,Modifiability,extend,extended,594,"/// Takes a [4 x i64] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// long long _mm256_extract_epi64(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [4 x i64].; /// \param N; /// An immediate integer operand with bits [1:0] determining which vector; /// element is extracted and returned.; /// \returns A 64-bit integer containing the extracted 64 bits of extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:285,Deployability,update,updated,285,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:78,Performance,perform,perform,78,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:7,Testability,Test,Test,7,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:269,Deployability,update,updated,269,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the CF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the CF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:269,Deployability,update,updated,269,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:270,Deployability,update,updated,270,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:23,Availability,mask,mask,23,"/* Vector extract sign mask */; /// Extracts the sign bits of double-precision floating point elements; /// in a 256-bit vector of [4 x double] and writes them to the lower order; /// bits of the return value.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVMSKPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing the double-precision; /// floating point values with sign bits to be extracted.; /// \returns The sign bits from the operand, written to bits [3:0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:10,Performance,load,load,10,/* Vector load with broadcast */; /// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 128-bit vector of [4 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:38,Performance,Load,Loads,38,/* Vector load with broadcast */; /// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 128-bit vector of [4 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads a scalar double-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x double] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSD </c> instruction.; ///; /// \param __a; /// The double-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 64-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [8 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads the data from a 128-bit vector of [2 x double] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [2 x double] to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads the data from a 128-bit vector of [4 x float] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [4 x float] to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,Performance,load,load,8,/* SIMD load ops */; /// Loads 4 double-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPD </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing; /// double-precision floating point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:25,Performance,Load,Loads,25,/* SIMD load ops */; /// Loads 4 double-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPD </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing; /// double-precision floating point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 8 single-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPS </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing float values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 4 double-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing double-precision floating; /// point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 8 single-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing single-precision floating; /// point values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from a 32-byte aligned memory; /// location pointed to by \a __p into elements of a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQA </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a 256-bit integer vector containing integer; /// values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:150,Performance,perform,perform,150,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:216,Performance,cache,cache,216,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:203,Availability,mask,mask,203,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:547,Availability,mask,mask,547,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:619,Availability,mask,mask,619,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:635,Availability,mask,mask,635,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:186,Integrability,depend,depending,186,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:15,Performance,load,load,15,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:46,Performance,load,loads,46,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:712,Performance,load,loaded,712,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:850,Performance,load,loaded,850,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:175,Availability,mask,mask,175,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:537,Availability,mask,mask,537,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:613,Availability,mask,mask,613,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:634,Availability,mask,mask,634,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:158,Integrability,depend,depending,158,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:711,Performance,load,loaded,711,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:844,Performance,load,loaded,844,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:174,Availability,mask,mask,174,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:518,Availability,mask,mask,518,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:590,Availability,mask,mask,590,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:606,Availability,mask,mask,606,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,Integrability,depend,depending,157,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:683,Performance,load,loaded,683,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:820,Performance,load,loaded,820,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:174,Availability,mask,mask,174,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:533,Availability,mask,mask,533,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:606,Availability,mask,mask,606,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:622,Availability,mask,mask,622,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,Integrability,depend,depending,157,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:699,Performance,load,loaded,699,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:836,Performance,load,loaded,836,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:195,Availability,mask,mask,195,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:483,Availability,mask,mask,483,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:548,Availability,mask,mask,548,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:580,Availability,mask,mask,580,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:596,Availability,mask,mask,596,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,Availability,mask,mask,152,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:425,Availability,mask,mask,425,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:482,Availability,mask,mask,482,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:509,Availability,mask,mask,509,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:525,Availability,mask,mask,525,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,Availability,mask,mask,152,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:443,Availability,mask,mask,443,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:511,Availability,mask,mask,511,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:543,Availability,mask,mask,543,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:559,Availability,mask,mask,559,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:166,Availability,mask,mask,166,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:439,Availability,mask,mask,439,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:496,Availability,mask,mask,496,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:523,Availability,mask,mask,523,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:539,Availability,mask,mask,539,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:3,Performance,Cache,Cacheability,3,"/* Cacheability support ops */; /// Moves integer data from a 256-bit integer vector to a 32-byte; /// aligned memory location. To minimize caching, the data is flagged as; /// non-temporal (unlikely to be used again soon).; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQ </c> instruction.; ///; /// \param __a; /// A pointer to a 32-byte aligned memory location that will receive the; /// integer values.; /// \param __b; /// A 256-bit integer vector containing the values to be moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:1121,Integrability,depend,depending,1121,"/*; Vector insert.; We use macros rather than inlines because we only want to accept; invocations where the immediate M is a constant expression.; */; /// Constructs a new 256-bit vector of [8 x float] by first duplicating; /// a 256-bit vector of [8 x float] given in the first parameter, and then; /// replacing either the upper or the lower 128 bits with the contents of a; /// 128-bit vector of [4 x float] in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_insertf128_ps(__m256 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float]. This vector is copied to the result; /// first, and then either the upper or the lower 128 bits of the result will; /// be replaced by the contents of \a V2.; /// \param V2; /// A 128-bit vector of [4 x float]. The contents of this parameter are; /// written to either the upper or the lower 128 bits of the result depending; /// on the value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit vector of [8 x float] containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:978,Integrability,depend,depending,978,"/// Constructs a new 256-bit vector of [4 x double] by first duplicating; /// a 256-bit vector of [4 x double] given in the first parameter, and then; /// replacing either the upper or the lower 128 bits with the contents of a; /// 128-bit vector of [2 x double] in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_insertf128_pd(__m256d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double]. This vector is copied to the result; /// first, and then either the upper or the lower 128 bits of the result will; /// be replaced by the contents of \a V2.; /// \param V2; /// A 128-bit vector of [2 x double]. The contents of this parameter are; /// written to either the upper or the lower 128 bits of the result depending; /// on the value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit vector of [4 x double] containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:941,Integrability,depend,depending,941,"/// Constructs a new 256-bit integer vector by first duplicating a; /// 256-bit integer vector given in the first parameter, and then replacing; /// either the upper or the lower 128 bits with the contents of a 128-bit; /// integer vector in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256i _mm256_insertf128_si256(__m256i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit integer vector. This vector is copied to the result first, and; /// then either the upper or the lower 128 bits of the result will be; /// replaced by the contents of \a V2.; /// \param V2; /// A 128-bit integer vector. The contents of this parameter are written to; /// either the upper or the lower 128 bits of the result depending on the; /// value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit integer vector containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,Performance,load,load,8,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:37,Performance,Load,Loads,37,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:315,Performance,load,load,315,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads two 128-bit floating-point vectors of [2 x double] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [4 x double] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [4 x double] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:284,Performance,load,load,284,/// Loads two 128-bit floating-point vectors of [2 x double] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [4 x double] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [4 x double] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads two 128-bit integer vectors from unaligned memory locations and; /// constructs a 256-bit integer vector by concatenating the two 128-bit; /// vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[255:128] of the result. The; /// address of the memory location does not have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[127:0] of the result. The; /// address of the memory location does not have to be aligned.; /// \returns A 256-bit integer vector containing the concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:238,Performance,load,load,238,/// Loads two 128-bit integer vectors from unaligned memory locations and; /// constructs a 256-bit integer vector by concatenating the two 128-bit; /// vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[255:128] of the result. The; /// address of the memory location does not have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[127:0] of the result. The; /// address of the memory location does not have to be aligned.; /// \returns A 256-bit integer vector containing the concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h:126,Energy Efficiency,charge,charge,126,"/*===--------------- avxvnniintrin.h - VNNI intrinsics --------------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h:1020,Integrability,CONTRACT,CONTRACT,1020,"/*===--------------- avxvnniintrin.h - VNNI intrinsics --------------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,Availability,mask,mask,123,"/// Deposit (scatter) low-order bits from the unsigned 32-bit integer \a __X; /// into the 32-bit result, according to the mask in the unsigned 32-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying where to deposit source bits.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:580,Availability,mask,mask,580,"/// Deposit (scatter) low-order bits from the unsigned 32-bit integer \a __X; /// into the 32-bit result, according to the mask in the unsigned 32-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying where to deposit source bits.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,Availability,mask,mask,134,"/// Extract (gather) bits from the unsigned 32-bit integer \a __X into the; /// low-order bits of the 32-bit result, according to the mask in the; /// unsigned 32-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying which source bits to extract.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:591,Availability,mask,mask,591,"/// Extract (gather) bits from the unsigned 32-bit integer \a __X into the; /// low-order bits of the 32-bit result, according to the mask in the; /// unsigned 32-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying which source bits to extract.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,Availability,mask,mask,123,"/// Deposit (scatter) low-order bits from the unsigned 64-bit integer \a __X; /// into the 64-bit result, according to the mask in the unsigned 64-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying where to deposit source bits.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:580,Availability,mask,mask,580,"/// Deposit (scatter) low-order bits from the unsigned 64-bit integer \a __X; /// into the 64-bit result, according to the mask in the unsigned 64-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying where to deposit source bits.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,Availability,mask,mask,134,"/// Extract (gather) bits from the unsigned 64-bit integer \a __X into the; /// low-order bits of the 64-bit result, according to the mask in the; /// unsigned 64-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying which source bits to extract.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:591,Availability,mask,mask,591,"/// Extract (gather) bits from the unsigned 64-bit integer \a __X into the; /// low-order bits of the 64-bit result, according to the mask in the; /// unsigned 64-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying which source bits to extract.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _andn_u32(unsigned int __X, unsigned int __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:292,Usability,clear,cleared,292,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:360,Usability,clear,clearing,360,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:369,Usability,clear,cleared,369,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:437,Usability,clear,clearing,437,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:343,Availability,mask,mask,343,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:412,Availability,mask,mask,412,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:422,Availability,mask,mask,422,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:491,Availability,mask,mask,491,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:281,Usability,clear,cleared,281,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:349,Usability,clear,clearing,349,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:358,Usability,clear,cleared,358,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:426,Usability,clear,clearing,426,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _andn_u64(unsigned long long __X,; /// unsigned long long __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:299,Usability,clear,cleared,299,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:374,Usability,clear,clearing,374,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:388,Usability,clear,cleared,388,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:463,Usability,clear,clearing,463,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:350,Availability,mask,mask,350,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:426,Availability,mask,mask,426,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:441,Availability,mask,mask,441,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:517,Availability,mask,mask,517,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:288,Usability,clear,cleared,288,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:363,Usability,clear,clearing,363,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:377,Usability,clear,cleared,377,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:452,Usability,clear,clearing,452,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h:628,Availability,error,error,628,"/*===---- builtins.h - Standard header for extra builtins -----------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/; /// Some legacy compilers have builtin definitions in a file named builtins.h.; /// This header file has been added to allow compatibility with code that was; /// written for those compilers. Code may have an include line for this file; /// and to avoid an error an empty file with this name is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h:619,Safety,avoid,avoid,619,"/*===---- builtins.h - Standard header for extra builtins -----------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/; /// Some legacy compilers have builtin definitions in a file named builtins.h.; /// This header file has been added to allow compatibility with code that was; /// written for those compilers. Code may have an include line for this file; /// and to avoid an error an empty file with this name is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h:30,Performance,cache,cache,30,/// Hint to hardware that the cache line that contains \p __P should be demoted; /// from the cache closest to the processor core to a level more distant from; /// the processor core.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CLDEMOTE </c> instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h:94,Performance,cache,cache,94,/// Hint to hardware that the cache line that contains \p __P should be demoted; /// from the cache closest to the processor core to a level more distant from; /// the processor core.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CLDEMOTE </c> instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:34,Performance,cache,cache,34,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:99,Performance,cache,cache,99,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:298,Performance,cache,cache,298,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:30,Performance,cache,cache,30,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:135,Performance,cache,cache,135,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:163,Performance,cache,cache,163,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:373,Performance,cache,cache,373,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h:19,Performance,cache,cache,19,/// Zeroes out the cache line for the address \a __line. This uses a; /// non-temporal store. Calling \c _mm_sfence() afterward might be needed; /// to enforce ordering.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CLZERO instruction.; ///; /// \param __line; /// An address within the cache line to zero out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h:324,Performance,cache,cache,324,/// Zeroes out the cache line for the address \a __line. This uses a; /// non-temporal store. Calling \c _mm_sfence() afterward might be needed; /// to enforce ordering.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CLZERO instruction.; ///; /// \param __line; /// An address within the cache line to zero out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h:34,Safety,detect,detection,34,"/*===---- cpuid.h - X86 cpu model detection --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cpuid.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:282,Security,checksum,checksum,282,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:398,Security,checksum,checksum,398,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:473,Security,checksum,checksum,473,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:283,Security,checksum,checksum,283,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:400,Security,checksum,checksum,400,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:475,Security,checksum,checksum,475,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:59,Security,checksum,checksum,59,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:298,Security,checksum,checksum,298,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:415,Security,checksum,checksum,415,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:490,Security,checksum,checksum,490,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:292,Security,checksum,checksum,292,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:409,Security,checksum,checksum,409,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:484,Security,checksum,checksum,484,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed comparison, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,Performance,perform,performs,92,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst.; /// This intrinsics may only be used in User mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMD </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,Performance,perform,performs,92,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst; /// This intrinsic may only be used in Privileged mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMDS </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:529,Availability,Down,Down,529,"/// Converts a 32-bit single-precision float value to a 16-bit; /// half-precision float value.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned short _cvtss_sh(float a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 32-bit single-precision float value to be converted to a 16-bit; /// half-precision float value.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns The converted 16-bit half-precision float value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:515,Availability,Down,Down,515,"/// Converts a 128-bit vector containing 32-bit float values into a; /// 128-bit vector containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cvtps_ph(__m128 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 128-bit vector containing 32-bit float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing converted 16-bit half-precision float; /// values. The lower 64 bits are used to store the converted 16-bit; /// half-precision floating-point values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:578,Availability,Down,Down,578,"/// Converts a 256-bit vector of [8 x float] into a 128-bit vector; /// containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm256_cvtps_ph(__m256 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 256-bit vector containing 32-bit single-precision float values to be; /// converted to 16-bit half-precision float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing the converted 16-bit half-precision; /// float values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:42,Availability,mask,masking,42,/* Default attributes for simple form (no masking). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:26,Usability,simpl,simple,26,/* Default attributes for simple form (no masking). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:30,Availability,mask,masked,30,/* Default attributes for ZMM masked forms. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:30,Availability,mask,masked,30,/* Default attributes for VLX masked forms. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:12,Performance,Load,Load,12,"/* Circular Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_circ_load_update_D(Word64 dst, Word64 *ptr, UWord32 incr, UWord32 bufsize, UWord32 K); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:15,Performance,Load,Load,15,"/* Bit Reverse Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_bitrev_load_update_D(Word64 dst, Word64 *ptr, UWord32 Iu4); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:102,Availability,mask,mask,102,/* ==========================================================================; Assembly Syntax: Rdd32=mask(Pt4); C Intrinsic Prototype: Word64 Q6_P_mask_p(Byte Pt); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Deployability,toggle,togglebit,101,"/* ==========================================================================; Assembly Syntax: Rd32=togglebit(Rs32,#u5); C Intrinsic Prototype: Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Deployability,toggle,togglebit,101,"/* ==========================================================================; Assembly Syntax: Rd32=togglebit(Rs32,Rt32); C Intrinsic Prototype: Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt); Instruction Type: S_3op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Availability,mask,mask,101,"/* ==========================================================================; Assembly Syntax: Rd32=mask(#u5,#U5); C Intrinsic Prototype: Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h:62,Safety,predict,prediction,62,/// Provides a hint to the processor to selectively reset the prediction; /// history of the current logical processor specified by a 32-bit integer; /// value \a __eax.; ///; /// This intrinsic corresponds to the <c> HRESET </c> instruction.; ///; /// \code{.operation}; /// IF __eax == 0; /// // nop; /// ELSE; /// FOR i := 0 to 31; /// IF __eax[i]; /// ResetPredictionFeature(i); /// FI; /// ENDFOR; /// FI; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h:101,Testability,log,logical,101,/// Provides a hint to the processor to selectively reset the prediction; /// history of the current logical processor specified by a 32-bit integer; /// value \a __eax.; ///; /// This intrinsic corresponds to the <c> HRESET </c> instruction.; ///; /// \code{.operation}; /// IF __eax == 0; /// // nop; /// ELSE; /// FOR i := 0 to 31; /// IF __eax[i]; /// ResetPredictionFeature(i); /// FI; /// ENDFOR; /// FI; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:44,Energy Efficiency,Power,PowerPC,44,"/*===---- htmintrin.h - Standard header for PowerPC HTM ---------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:7,Safety,abort,abort,7,/* The abort codes below this threshold are reserved for machine use. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:58,Availability,failure,failure,58,/* Helper intrinsics to retry tbegin in case of transient failure. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:35,Availability,avail,available,35,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:167,Availability,avail,available,167,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:151,Usability,Guid,Guide,151,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:15,Availability,failure,failure,15,/* Transaction failure diagnostics */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:232,Testability,log,logic,232,/* __x86_64__ */; /// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param __A; /// An unsigned 32-bit integer operand.; /// \returns A 32-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see _popcnt32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:271,Testability,log,logic,271,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _popcnt32(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param A; /// An unsigned 32-bit integer operand.; /// \returns A 32-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see __popcntd,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:214,Testability,log,logic,214,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param __A; /// An unsigned 64-bit integer operand.; /// \returns A 64-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see _popcnt64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:292,Testability,log,logic,292,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// long long _popcnt64(unsigned long long A);; /// \endcode; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param A; /// An unsigned 64-bit integer operand.; /// \returns A 64-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see __popcntq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:98,Usability,clear,cleared,98,/// Returns the program status and control \c RFLAGS register with the \c VM; /// and \c RF flags cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PUSHFQ + \c POP instruction sequence.; ///; /// \returns The 64-bit value of the RFLAGS register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:117,Usability,clear,cleared,117,/* !__x86_64__ */; /// Returns the program status and control \c EFLAGS register with the \c VM; /// and \c RF flags cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PUSHFD + \c POP instruction sequence.; ///; /// \returns The 32-bit value of the EFLAGS register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:276,Security,checksum,checksum,276,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:392,Security,checksum,checksum,392,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:467,Security,checksum,checksum,467,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:277,Security,checksum,checksum,277,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:394,Security,checksum,checksum,394,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:469,Security,checksum,checksum,469,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:286,Security,checksum,checksum,286,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:403,Security,checksum,checksum,403,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:478,Security,checksum,checksum,478,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:286,Security,checksum,checksum,286,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:403,Security,checksum,checksum,403,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:478,Security,checksum,checksum,478,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:54,Energy Efficiency,monitor,monitoring,54,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:42,Performance,perform,performance,42,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:138,Performance,perform,performance,138,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:311,Performance,perform,performance,311,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:385,Performance,perform,performance,385,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:36,Energy Efficiency,monitor,monitoring,36,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:24,Performance,perform,performance,24,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:120,Performance,perform,performance,120,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:360,Performance,perform,performance,360,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:434,Performance,perform,performance,434,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:43,Performance,load,load,43,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:263,Performance,Load,Load,263,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:473,Performance,load,load,473,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Performance,Load,Load,4,/// Load a 32-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 32-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:214,Performance,load,load,214,/// Load a 32-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 32-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Performance,Load,Load,4,/// Load a 64-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 64-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:214,Performance,load,load,214,/// Load a 64-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 64-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:37,Availability,avail,available,37,/* Intrinsics inside adcintrin.h are available at all times. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange Add; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange Add; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Increment; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Increment; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Decrement; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Decrement; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked And; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked And; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:102,Testability,Test,Testing,102,/*----------------------------------------------------------------------------*\; |* Bit Counting and Testing; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Or; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Or; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Xor; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Xor; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:3,Performance,Load,Loads,3,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:142,Performance,load,loaded,142,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:216,Performance,load,loaded,216,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:124,Energy Efficiency,charge,charge,124,"/*===----------------- keylockerintrin.h - KL Intrinsics -------------------===; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1018,Integrability,CONTRACT,CONTRACT,1018,"/*===----------------- keylockerintrin.h - KL Intrinsics -------------------===; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:18,Integrability,wrap,wrapping,18,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Performance,Load,Load,4,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:215,Performance,load,loaded,215,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:321,Performance,load,loaded,321,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:471,Performance,LOAD,LOADIWKEY,471,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:547,Performance,LOAD,LOADKWKEY,547,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:627,Performance,LOAD,LOADIWKEY,627,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:2020,Performance,load,loaded,2020,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:197,Security,encrypt,encryption,197,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:299,Security,integrity,integrity,299,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1132,Security,Encrypt,Encryption,1132,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1187,Security,Encrypt,Encryption,1187,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1243,Security,Integrity,IntegrityKey,1243,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1534,Security,Encrypt,Encryption,1534,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1616,Security,Encrypt,Encryption,1616,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1702,Security,Encrypt,Encryption,1702,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1802,Security,Integrity,IntegrityKey,1802,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Integrability,Wrap,Wrap,4,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:696,Security,Integrity,Integrity,696,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:724,Security,Encrypt,Encryption,724,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:929,Security,Integrity,Integrity,929,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Integrability,Wrap,Wrap,4,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:769,Security,Integrity,Integrity,769,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:797,Security,Encrypt,Encryption,797,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:49,Security,encrypt,encrypt,49,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:49,Security,encrypt,encrypt,49,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESDEC128KL performs 10 rounds of AES to decrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := (HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES128Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESDEC128KL performs 10 rounds of AES to decrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := (HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES128Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESDEC256KL performs 10 rounds of AES to decrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h]; /// IllegalHandle := (HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Security,Encrypt,Encrypt,4,"/// Encrypt __idata[0] to __idata[7] using 128-bit AES key indicated by handle; /// at __h and store each resultant block back from __odata to __odata+7. And; /// return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENCWIDE128KL </c> instructions.; ///; /// \code{.operation}; /// Handle := MEM[__h+383:__h]; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF Authentic == 0; /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// FOR i := 0 to 7; /// __odata[i] := AES128Encrypt (__idata[i], UnwrappedKey); /// ENDFOR; /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Security,Encrypt,Encrypt,4,"/// Encrypt __idata[0] to __idata[7] using 256-bit AES key indicated by handle; /// at __h and store each resultant block back from __odata to __odata+7. And; /// return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENCWIDE256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h]; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES512 ); /// IF (IllegalHandle); /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF Authentic == 0; /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// FOR i := 0 to 7; /// __odata[i] := AES256Encrypt (__idata[i], UnwrappedKey); /// ENDFOR; /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:552,Integrability,Synchroniz,Synchronized,552,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:270,Modifiability,extend,extended,270,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:362,Modifiability,extend,extended,362,"/// Decrements the LWP programmed value sample event counter. If the result is; /// negative, inserts an event record into the LWP event ring buffer in memory; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPVAL </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:534,Integrability,Synchroniz,Synchronized,534,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 64-bit value is inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Usability,Clear,Clears,4,/// Clears the MMX state by setting the state of the x87 stack registers; /// to empty.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> EMMS </c> instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:240,Usability,clear,cleared,240,"/// Right-shifts each 16-bit integer element of the first parameter,; /// which is a 64-bit integer vector of [4 x i16], by the number of bits; /// specified by the second parameter, which is a 64-bit integer.; ///; /// High-order bits are cleared. The 16-bit results are packed into a 64-bit; /// integer vector of [4 x i16].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLW </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [4 x i16].; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector of [4 x i16] containing the right-shifted; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:173,Usability,clear,cleared,173,/// Right-shifts each 16-bit integer element of a 64-bit integer vector; /// of [4 x i16] by the number of bits specified by a 32-bit integer.; ///; /// High-order bits are cleared. The 16-bit results are packed into a 64-bit; /// integer vector of [4 x i16].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLW </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [4 x i16].; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector of [4 x i16] containing the right-shifted; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:240,Usability,clear,cleared,240,"/// Right-shifts each 32-bit integer element of the first parameter,; /// which is a 64-bit integer vector of [2 x i32], by the number of bits; /// specified by the second parameter, which is a 64-bit integer.; ///; /// High-order bits are cleared. The 32-bit results are packed into a 64-bit; /// integer vector of [2 x i32].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLD </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [2 x i32].; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector of [2 x i32] containing the right-shifted; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:173,Usability,clear,cleared,173,/// Right-shifts each 32-bit integer element of a 64-bit integer vector; /// of [2 x i32] by the number of bits specified by a 32-bit integer.; ///; /// High-order bits are cleared. The 32-bit results are packed into a 64-bit; /// integer vector of [2 x i32].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLD </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [2 x i32].; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector of [2 x i32] containing the right-shifted; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:159,Usability,clear,cleared,159,/// Right-shifts the first 64-bit integer parameter by the number of bits; /// specified by the second 64-bit integer parameter.; ///; /// High-order bits are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLQ </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector containing the right-shifted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:189,Usability,clear,cleared,189,"/// Right-shifts the first parameter, which is a 64-bit integer, by the; /// number of bits specified by the second parameter, which is a 32-bit; /// integer.; ///; /// High-order bits are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLQ </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector containing the right-shifted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PAND </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise NOT of the first 64-bit integer vector, and then; /// performs a bitwise AND of the intermediate result and the second 64-bit; /// integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PANDN </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector. The one's complement of this parameter is used; /// in the bitwise AND.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of the second; /// parameter and the one's complement of the first parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:77,Performance,perform,performs,77,"/// Performs a bitwise NOT of the first 64-bit integer vector, and then; /// performs a bitwise AND of the intermediate result and the second 64-bit; /// integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PANDN </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector. The one's complement of this parameter is used; /// in the bitwise AND.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of the second; /// parameter and the one's complement of the first parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> POR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise OR of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise exclusive OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PXOR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise exclusive OR of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h:196,Performance,load,load,196,"/* __x86_64__ */; /*; * movdir64b - Move 64 bytes as direct store.; * The destination must be 64 byte aligned, and the store is atomic.; * The source address has no alignment requirement, and the load from; * the source address is not atomic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/movdirintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:27,Energy Efficiency,MONITOR,MONITORX,27,"/*===---- mwaitxintrin.h - MONITORX/MWAITX intrinsics ----------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:52,Energy Efficiency,monitor,monitored,52,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:97,Energy Efficiency,monitor,monitor,97,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:150,Energy Efficiency,monitor,monitored,150,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:305,Energy Efficiency,MONITOR,MONITORX,305,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:376,Energy Efficiency,monitor,monitored,376,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:516,Energy Efficiency,monitor,monitoring,516,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:582,Energy Efficiency,monitor,monitoring,582,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:21,Energy Efficiency,MONITOR,MONITORX,21,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:85,Energy Efficiency,monitor,monitor,85,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:133,Energy Efficiency,monitor,monitored,133,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:394,Energy Efficiency,monitor,monitoring,394,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:494,Energy Efficiency,monitor,monitoring,494,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:93,Availability,error,error,93,/**; * A positive float constant expression. HUGE_VALF evaluates; * to +infinity. Used as an error value returned by the built-in; * math functions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:93,Availability,error,error,93,/**; * A positive double constant expression. HUGE_VAL evaluates; * to +infinity. Used as an error value returned by the built-in; * math functions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:53,Integrability,Synchroniz,Synchronization,53,"// OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; // Flag type and values for barrier, mem_fence, read_mem_fence, write_mem_fence",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to local memory; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to global memory; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:74,Testability,test,test,74,"/**; * Subgroups have different requirements on forward progress, so just test; * all the relevant macros.; * CL 3.0 sub-groups ""they are not guaranteed to make independent forward progress""; * KHR subgroups ""Subgroups within a workgroup are independent, make forward progress with respect to each other""; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct ordering of memory; * operations between work-items of a work-group to; * image memory.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:3,Performance,Optimiz,Optimizations,3,// Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:36,Availability,error,error,36,//cl_khr_fp16; /**; * Complementary error function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Availability,Error,Error,22,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:52,Deployability,integrat,integrating,52,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:52,Integrability,integrat,integrating,52,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:45,Energy Efficiency,power,power,45,//cl_khr_fp16; /**; * Multiply x by 2 to the power n.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Log,Log,22,//cl_khr_fp16; /**; * Log gamma function. Returns the natural; * logarithm of the absolute value of the gamma; * function. The sign of the gamma function is; * returned in the signp argument of lgamma_r.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:65,Testability,log,logarithm,65,//cl_khr_fp16; /**; * Log gamma function. Returns the natural; * logarithm of the absolute value of the gamma; * function. The sign of the gamma function is; * returned in the signp argument of lgamma_r.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:75,Testability,log,logarithm,75,//defined(__opencl_c_named_address_space_builtins); /**; * Compute natural logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Testability,log,logarithm,39,//cl_khr_fp16; /**; * Compute a base 2 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:40,Testability,log,logarithm,40,//cl_khr_fp16; /**; * Compute a base 10 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Testability,log,logarithm,39,//cl_khr_fp16; /**; * Compute a base e logarithm of (1.0 + x).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:82,Testability,log,logr,82,"//cl_khr_fp16; /**; * Compute the exponent of x, which is the integral; * part of logr | x |.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,//cl_khr_fp16; /**; * Compute x to the power y.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,"//cl_khr_fp16; /**; * Compute x to the power y, where y is an integer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,"//cl_khr_fp16; /**; * Compute x to the power y, where x is >= 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,//cl_khr_fp16; /**; * Compute x to the power 1/y.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:23,Testability,log,logarithm,23,/**; * Compute natural logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Testability,log,logarithm,24,/**; * Compute a base 2 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:25,Testability,log,logarithm,25,/**; * Compute a base 10 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Energy Efficiency,power,power,24,"/**; * Compute x to the power y, where x is >= 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:75,Availability,error,error,75,/**; * Compute cosine over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:74,Availability,error,error,74,/**; * Compute x / y over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:97,Availability,error,error,97,/**; * Compute the base- e exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:97,Availability,error,error,97,/**; * Compute the base- 2 exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:98,Availability,error,error,98,/**; * Compute the base- 10 exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:85,Availability,error,error,85,/**; * Compute natural logarithm over an implementationdefined; * range. The maximum error is implementation; * defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:23,Testability,log,logarithm,23,/**; * Compute natural logarithm over an implementationdefined; * range. The maximum error is implementation; * defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:86,Availability,error,error,86,/**; * Compute a base 2 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Testability,log,logarithm,24,/**; * Compute a base 2 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:87,Availability,error,error,87,/**; * Compute a base 10 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:25,Testability,log,logarithm,25,/**; * Compute a base 10 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:114,Availability,error,error,114,"/**; * Compute x to the power y, where x is >= 0. The range of; * x and y are implementation-defined. The maximum error; * is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Energy Efficiency,power,power,24,"/**; * Compute x to the power y, where x is >= 0. The range of; * x and y are implementation-defined. The maximum error; * is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:79,Availability,error,error,79,/**; * Compute reciprocal over an implementation-defined; * range. The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:87,Availability,error,error,87,/**; * Compute inverse square root over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:73,Availability,error,error,73,/**; * Compute sine over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:80,Availability,error,error,80,/**; * Compute square root over an implementation-defined; * range. The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:76,Availability,error,error,76,/**; * Compute tangent over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:275,Performance,perform,performed,275,// defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_1_2); /**; * Multiply two 24-bit integer values x and y and add; * the 32-bit integer result to the 32-bit integer z.; * Refer to definition of mul24 to see how the 24-bit; * integer multiplication is performed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:122,Performance,perform,perform,122,"/**; * Multiply two 24-bit integer values x and y. x and y; * are 32-bit integers but only the low 24-bits are used; * to perform the multiplication. mul24 should only; * be used when values in x and y are in the range [-; * 2^23, 2^23-1] if x and y are signed integers and in the; * range [0, 2^24-1] if x and y are unsigned integers. If; * x and y are not in this range, the multiplication; * result is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:77,Performance,perform,performs,77,"//cl_khr_fp16; /**; * Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and; * performs smooth Hermite interpolation between 0; * and 1when edge0 < x < edge1. This is useful in; * cases where you would want a threshold function; * with a smooth transition.; * This is equivalent to:; * gentype t;; * t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);; * return t * t * (3 - 2 * t);; * Results are undefined if edge0 >= edge1 or if x,; * edge0 or edge1 is a NaN.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:190,Availability,error,error,190,"/**; * Returns a vector in the same direction as p but with a; * length of 1. fast_normalize is computed as:; * p * half_rsqrt (p.x^2 + p.y^2 + ... ); * The result shall be within 8192 ulps error from the; * infinitely precise result of; * if (all(p == 0.0f)); * result = p;; * else; * result = p / sqrt (p.x^2 + p.y^2 + ...);; * with the following exceptions:; * 1) If the sum of squares is greater than FLT_MAX; * then the value of the floating-point values in the; * result vector are undefined.; * 2) If the sum of squares is less than FLT_MIN then; * the implementation may return back p.; * 3) If the device is in ""denorms are flushed to zero""; * mode, individual operand elements with magnitude; * less than sqrt(FLT_MIN) may be flushed to zero; * before proceeding with the calculation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for finite value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for infinity value (+ve or -ve) .; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for a NaN.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for a normal value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,"//cl_khr_fp16; /**; * Test if arguments are ordered. isordered() takes; * arguments x and y, and returns the result; * isequal(x, x) && isequal(y, y).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,"//cl_khr_fp16; /**; * Test if arguments are unordered. isunordered(); * takes arguments x and y, returning non-zero if x or y; * is NaN, and zero otherwise.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for sign bit. The scalar version of the function; * returns a 1 if the sign bit in the float is set else returns; * 0. The vector version of the function returns the; * following for each component in floatn: a -1 if the; * sign bit in the float is set else returns 0.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:80,Performance,Load,Load,80,"//cl_khr_fp16; // OpenCL v1.1 s6.11.7, v1.2 s6.12.7, v2.0 s6.13.7 - Vector Data Load and Store Functions; // OpenCL extensions v1.1 s9.6.6, v1.2 s9.5.6, v2.0 s9.4.6 - Vector Data Load and Store Functions for Half Type; /**; * Use generic type gentype to indicate the built-in data types; * char, uchar, short, ushort, int, uint, long, ulong, float,; * double or half.; *; * vloadn return sizeof (gentypen) bytes of data read from address (p + (offset * n)).; *; * vstoren write sizeof (gentypen) bytes given by data to address (p + (offset * n)).; *; * The address computed as (p + (offset * n)) must be; * 8-bit aligned if gentype is char, uchar;; * 16-bit aligned if gentype is short, ushort, half;; * 32-bit aligned if gentype is int, uint, float;; * 64-bit aligned if gentype is long, ulong, double.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:179,Performance,Load,Load,179,"//cl_khr_fp16; // OpenCL v1.1 s6.11.7, v1.2 s6.12.7, v2.0 s6.13.7 - Vector Data Load and Store Functions; // OpenCL extensions v1.1 s9.6.6, v1.2 s9.5.6, v2.0 s9.4.6 - Vector Data Load and Store Functions for Half Type; /**; * Use generic type gentype to indicate the built-in data types; * char, uchar, short, ushort, int, uint, long, ulong, float,; * double or half.; *; * vloadn return sizeof (gentypen) bytes of data read from address (p + (offset * n)).; *; * vstoren write sizeof (gentypen) bytes given by data to address (p + (offset * n)).; *; * The address computed as (p + (offset * n)) must be; * 8-bit aligned if gentype is char, uchar;; * 16-bit aligned if gentype is short, ushort, half;; * 32-bit aligned if gentype is int, uint, float;; * 64-bit aligned if gentype is long, ulong, double.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1491,Deployability,update,updated,1491,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:105,Integrability,Synchroniz,Synchronization,105,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1104,Modifiability,variab,variables,1104,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:783,Performance,queue,queues,783,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1143,Performance,queue,queue,1143,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1287,Performance,queue,queue,1287,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:165,Performance,load,loads,165,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:236,Performance,load,loads,236,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:322,Performance,load,loads,322,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:47,Performance,load,loads,47,/**; * Read memory barrier that orders only; * loads.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1116,Integrability,synchroniz,synchronization,1116,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:322,Performance,Perform,Perform,322,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:418,Performance,perform,performed,418,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1092,Performance,perform,perform,1092,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1181,Performance,perform,performing,1181,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1002,Integrability,synchroniz,synchronization,1002,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Performance,Perform,Perform,22,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:297,Performance,perform,performed,297,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:978,Performance,perform,perform,978,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1067,Performance,perform,performing,1067,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:161,Deployability,release,released,161,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:191,Performance,perform,performed,191,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:72,Performance,cache,cache,72,/**; * Prefetch num_elements * sizeof(gentype); * bytes into the global cache. The prefetch; * instruction is applied to a work-item in a workgroup; * and does not affect the functional; * behavior of the kernel.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:438,Availability,mask,mask,438,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:479,Availability,mask,mask,479,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:606,Availability,mask,mask,606,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:709,Availability,mask,mask,709,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:759,Availability,mask,mask,759,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:995,Availability,mask,mask,995,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1160,Availability,mask,mask,1160,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1229,Availability,mask,mask,1229,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1268,Availability,mask,mask,1268,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1356,Availability,mask,mask,1356,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1418,Availability,mask,mask,1418,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1468,Availability,mask,mask,1468,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1520,Availability,mask,mask,1520,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1571,Availability,mask,mask,1571,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:26,Security,Access,Access,26,/**; * Sampler-less Image Access; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:26,Security,Access,Access,26,/**; * Sampler-less Image Access; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:140,Security,access,access,140,"//defined(__opencl_c_read_write_images); // Note: In OpenCL v1.0/1.1/1.2, image argument of image query builtin functions does not have; // access qualifier, which by default assume read_only access qualifier. Image query builtin; // functions with write_only image argument should also be declared.; /**; * Return the image width in pixels.; *; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:192,Security,access,access,192,"//defined(__opencl_c_read_write_images); // Note: In OpenCL v1.0/1.1/1.2, image argument of image query builtin functions does not have; // access qualifier, which by default assume read_only access qualifier. Image query builtin; // functions with write_only image argument should also be declared.; /**; * Return the image width in pixels.; *; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:3,Integrability,Wrap,Wrappers,3,// Wrappers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h:41,Deployability,configurat,configuration,41,"/*===---- pconfigintrin.h - X86 platform configuration ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h:41,Modifiability,config,configuration,41,"/*===---- pconfigintrin.h - X86 platform configuration ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:4,Performance,Load,Loads,4,"/// Loads data from an unaligned memory location to elements in a 128-bit; /// vector.; ///; /// If the address of the data is not 16-byte aligned, the instruction may; /// read two adjacent aligned blocks of memory to retrieve the requested; /// data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 128-bit integer vector containing integer values.; /// \returns A 128-bit vector containing the moved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:52,Energy Efficiency,monitor,monitored,52,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:97,Energy Efficiency,monitor,monitor,97,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:150,Energy Efficiency,monitor,monitored,150,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:239,Energy Efficiency,MONITOR,MONITOR,239,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:445,Energy Efficiency,MONITOR,MONITOR,445,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:515,Energy Efficiency,monitor,monitored,515,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:655,Energy Efficiency,monitor,monitoring,655,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:721,Energy Efficiency,monitor,monitoring,721,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:21,Energy Efficiency,MONITOR,MONITOR,21,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:84,Energy Efficiency,monitor,monitor,84,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:132,Energy Efficiency,monitor,monitored,132,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:530,Energy Efficiency,monitor,monitoring,530,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:630,Energy Efficiency,monitor,monitoring,630,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:153,Integrability,depend,dependent,153,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Performance,Load,Loads,4,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:94,Performance,cache,cache,94,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:167,Integrability,depend,dependent,167,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Performance,Load,Loads,4,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:108,Performance,cache,cache,108,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Performance,Load,Loads,4,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:87,Performance,cache,cache,87,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:105,Performance,cache,cache-coherency,105,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:194,Performance,cache,cache,194,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:384,Integrability,depend,dependent,384,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Performance,Load,Loads,4,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:90,Performance,cache,cache,90,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:109,Performance,cache,cache-coherency,109,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:190,Performance,cache,cache,190,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:256,Performance,cache,cache,256,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:321,Performance,perform,performed,321,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically add a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] + __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically and a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] AND __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,Performance,perform,performance,233,"/// Atomically or a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] OR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically xor a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] XOR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically add a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] + __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically and a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] AND __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,Performance,perform,performance,233,"/// Atomically or a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] OR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically xor a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] XOR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h:43,Deployability,configurat,configuration,43,"/*===---- sgxintrin.h - X86 SGX intrinsics configuration -------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sgxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h:43,Modifiability,config,configuration,43,"/*===---- sgxintrin.h - X86 SGX intrinsics configuration -------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sgxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:52,Energy Efficiency,schedul,scheduling,52,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:44,Integrability,message,message,44,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:163,Integrability,message,message,163,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,Performance,perform,performs,96,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:52,Energy Efficiency,schedul,scheduling,52,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:44,Integrability,message,message,44,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:157,Integrability,message,message,157,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,Performance,perform,performs,96,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:340,Deployability,update,updated,340,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:428,Deployability,update,updated,428,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:211,Integrability,message,message,211,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:433,Deployability,update,updated,433,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1412,Deployability,update,updated,1412,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:60,Integrability,message,message,60,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:231,Integrability,message,message,231,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1163,Integrability,message,message,1163,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:317,Modifiability,variab,variable,317,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1189,Modifiability,variab,variable,1189,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:401,Performance,perform,perform,401,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:667,Performance,perform,performs,667,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:618,Deployability,update,updated,618,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:163,Integrability,message,message,163,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:550,Integrability,message,message,550,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:31,Modifiability,variab,variable,31,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:63,Modifiability,variab,variables,63,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:79,Integrability,message,message,79,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:111,Integrability,message,message,111,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:398,Integrability,message,message,398,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:487,Integrability,message,message,487,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:553,Deployability,update,updated,553,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:68,Integrability,message,message,68,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:105,Integrability,message,message,105,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:478,Integrability,message,message,478,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:455,Deployability,update,updated,455,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1135,Deployability,update,updated,1135,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:304,Integrability,message,message,304,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:615,Performance,perform,performs,615,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:568,Deployability,update,updated,568,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:81,Integrability,message,message,81,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:113,Integrability,message,message,113,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:402,Integrability,message,message,402,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:491,Integrability,message,message,491,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:557,Deployability,update,updated,557,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:70,Integrability,message,message,70,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:107,Integrability,message,message,107,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:482,Integrability,message,message,482,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:49,Energy Efficiency,schedul,scheduling,49,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:41,Integrability,message,message,41,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:145,Integrability,message,message,145,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,Performance,perform,performs,91,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:49,Energy Efficiency,schedul,scheduling,49,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:41,Integrability,message,message,41,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:144,Integrability,message,message,144,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,Performance,perform,performs,91,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:525,Availability,mask,masks,525,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:330,Deployability,update,updated,330,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:295,Modifiability,variab,variables,295,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4key4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4key4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 1; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4rnds4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:47,Security,encrypt,encryption,47,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4rnds4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4rnds4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:47,Security,encrypt,encryption,47,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4rnds4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,Availability,down,down,11,/// Rounds down each element of the 128-bit vector of [4 x float] to an; /// an integer and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ps(__m128 X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float] values to be rounded down.; /// \returns A 128-bit vector of [4 x float] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:424,Availability,down,down,424,/// Rounds down each element of the 128-bit vector of [4 x float] to an; /// an integer and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ps(__m128 X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float] values to be rounded down.; /// \returns A 128-bit vector of [4 x float] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,Availability,down,down,11,/// Rounds down each element of the 128-bit vector of [2 x double] to an; /// integer and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_pd(__m128d X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \returns A 128-bit vector of [2 x double] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,down,down,172,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds down the lowest element of the second 128-bit vector; /// operand to an integer and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ss(__m128 X, __m128 Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:784,Availability,down,down,784,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds down the lowest element of the second 128-bit vector; /// operand to an integer and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ss(__m128 X, __m128 Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:163,Availability,down,down,163,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds down the lower element of the second 128-bit vector operand to an; /// integer and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_sd(__m128d X, __m128d Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:777,Availability,down,down,777,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds down the lower element of the second 128-bit vector operand to an; /// integer and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_sd(__m128d X, __m128d Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:938,Availability,Down,Downward,938,"/// Rounds each element of the 128-bit vector of [4 x float] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ps(__m128 X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:715,Deployability,update,updated,715,"/// Rounds each element of the 128-bit vector of [4 x float] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ps(__m128 X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1437,Availability,Down,Downward,1437,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds the lowest element of the second 128-bit vector; /// operand to an integer value according to the rounding control specified; /// by the third argument and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ss(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1214,Deployability,update,updated,1214,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds the lowest element of the second 128-bit vector; /// operand to an integer value according to the rounding control specified; /// by the third argument and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ss(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:943,Availability,Down,Downward,943,"/// Rounds each element of the 128-bit vector of [2 x double] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_pd(__m128d X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:720,Deployability,update,updated,720,"/// Rounds each element of the 128-bit vector of [2 x double] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_pd(__m128d X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1430,Availability,Down,Downward,1430,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds the lower element of the second 128-bit vector operand to an; /// integer value according to the rounding control specified by the third; /// argument and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_sd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1207,Deployability,update,updated,1207,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds the lower element of the second 128-bit vector operand to an; /// integer value according to the rounding control specified by the third; /// argument and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_sd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:212,Availability,mask,mask,212,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:600,Availability,mask,mask,600,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:685,Availability,mask,mask,685,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:750,Availability,mask,mask,750,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:878,Availability,mask,mask,878,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,Availability,mask,mask,171,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:554,Availability,mask,mask,554,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:639,Availability,mask,mask,639,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:704,Availability,mask,mask,704,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:832,Availability,mask,mask,832,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:470,Availability,mask,mask,470,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Availability,mask,mask,560,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:640,Availability,mask,mask,640,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:770,Availability,mask,mask,770,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,Availability,mask,mask,171,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:467,Availability,mask,mask,467,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:566,Availability,mask,mask,566,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:646,Availability,mask,mask,646,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:776,Availability,mask,mask,776,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:464,Availability,mask,mask,464,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:561,Availability,mask,mask,561,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:641,Availability,mask,mask,641,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:770,Availability,mask,mask,770,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Availability,mask,mask,557,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:642,Availability,mask,mask,642,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:707,Availability,mask,mask,707,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:835,Availability,mask,mask,835,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:727,Availability,Mask,Mask,727,"/* SSE4 Floating Point Dot Product Instructions. */; /// Computes the dot product of the two 128-bit vectors of [4 x float]; /// and returns it in the elements of the 128-bit result vector of; /// [4 x float].; ///; /// The immediate integer operand controls which input elements; /// will contribute to the dot product, and where the final results are; /// returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_dp_ps(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VDPPS / DPPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param Y; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand. Mask bits [7:4] determine which elements; /// of the input vectors are used, with bit [4] corresponding to the lowest; /// element and bit [7] corresponding to the highest element of each [4 x; /// float] vector. If a bit is set, the corresponding elements from the two; /// input vectors are used as an input for dot product; otherwise that input; /// is treated as zero. Bits [3:0] determine which elements of the result; /// will receive a copy of the final dot product, with bit [0] corresponding; /// to the lowest element and bit [3] corresponding to the highest element of; /// each [4 x float] subvector. If a bit is set, the dot product is returned; /// in the corresponding element; otherwise that element is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the dot product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:681,Availability,Mask,Mask,681,"/// Computes the dot product of the two 128-bit vectors of [2 x double]; /// and returns it in the elements of the 128-bit result vector of; /// [2 x double].; ///; /// The immediate integer operand controls which input; /// elements will contribute to the dot product, and where the final results; /// are returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_dp_pd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VDPPD / DPPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param Y; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand. Mask bits [5:4] determine which elements; /// of the input vectors are used, with bit [4] corresponding to the lowest; /// element and bit [5] corresponding to the highest element of each of [2 x; /// double] vector. If a bit is set, the corresponding elements from the two; /// input vectors are used as an input for dot product; otherwise that input; /// is treated as zero. Bits [1:0] determine which elements of the result; /// will receive a copy of the final dot product, with bit [0] corresponding; /// to the lowest element and bit [1] corresponding to the highest element of; /// each [2 x double] vector. If a bit is set, the dot product is returned in; /// the corresponding element; otherwise that element is set to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:18,Performance,Load,Load,18,/* SSE4 Streaming Load Hint Instruction. */; /// Loads integer values from a 128-bit aligned memory location to a; /// 128-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQA / MOVNTDQA </c> instruction.; ///; /// \param __V; /// A pointer to a 128-bit aligned memory location that contains the integer; /// values.; /// \returns A 128-bit integer vector containing the data stored at the; /// specified memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:49,Performance,Load,Loads,49,/* SSE4 Streaming Load Hint Instruction. */; /// Loads integer values from a 128-bit aligned memory location to a; /// 128-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQA / MOVNTDQA </c> instruction.; ///; /// \param __V; /// A pointer to a 128-bit aligned memory location that contains the integer; /// values.; /// \returns A 128-bit integer vector containing the data stored at the; /// specified memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1182,Usability,clear,cleared,1182," X and inserts an element from the second; /// argument \a Y as selected by the third argument \a N. That result then; /// has elements zeroed out also as selected by the third argument \a N. The; /// resulting 128-bit vector of [4 x float] is then returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_insert_ps(__m128 X, __m128 Y, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTPS </c> instruction.; ///; /// \param X; /// A 128-bit vector source operand of [4 x float]. With the exception of; /// those bits in the result copied from parameter \a Y and zeroed by bits; /// [3:0] of \a N, all bits from this parameter are copied to the result.; /// \param Y; /// A 128-bit vector source operand of [4 x float]. One single-precision; /// floating-point element from this source, as determined by the immediate; /// parameter, is copied to the result.; /// \param N; /// Specifies which bits from operand \a Y will be copied, which bits in the; /// result they will be copied to, and which bits in the result will be; /// cleared. The following assignments are made: \n; /// Bits [7:6] specify the bits to copy from operand \a Y: \n; /// 00: Selects bits [31:0] from operand \a Y. \n; /// 01: Selects bits [63:32] from operand \a Y. \n; /// 10: Selects bits [95:64] from operand \a Y. \n; /// 11: Selects bits [127:96] from operand \a Y. \n; /// Bits [5:4] specify the bits in the result to which the selected bits; /// from operand \a Y are copied: \n; /// 00: Copies the selected bits from \a Y to result bits [31:0]. \n; /// 01: Copies the selected bits from \a Y to result bits [63:32]. \n; /// 10: Copies the selected bits from \a Y to result bits [95:64]. \n; /// 11: Copies the selected bits from \a Y to result bits [127:96]. \n; /// Bits[3:0]: If any of these bits are set, the corresponding result; /// element is cleared.; /// \returns A 128-bit vector of [4 x float] containing the copied; /// single-precision floating point ele",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1984,Usability,clear,cleared,1984," from the second; /// argument \a Y as selected by the third argument \a N. That result then; /// has elements zeroed out also as selected by the third argument \a N. The; /// resulting 128-bit vector of [4 x float] is then returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_insert_ps(__m128 X, __m128 Y, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTPS </c> instruction.; ///; /// \param X; /// A 128-bit vector source operand of [4 x float]. With the exception of; /// those bits in the result copied from parameter \a Y and zeroed by bits; /// [3:0] of \a N, all bits from this parameter are copied to the result.; /// \param Y; /// A 128-bit vector source operand of [4 x float]. One single-precision; /// floating-point element from this source, as determined by the immediate; /// parameter, is copied to the result.; /// \param N; /// Specifies which bits from operand \a Y will be copied, which bits in the; /// result they will be copied to, and which bits in the result will be; /// cleared. The following assignments are made: \n; /// Bits [7:6] specify the bits to copy from operand \a Y: \n; /// 00: Selects bits [31:0] from operand \a Y. \n; /// 01: Selects bits [63:32] from operand \a Y. \n; /// 10: Selects bits [95:64] from operand \a Y. \n; /// 11: Selects bits [127:96] from operand \a Y. \n; /// Bits [5:4] specify the bits in the result to which the selected bits; /// from operand \a Y are copied: \n; /// 00: Copies the selected bits from \a Y to result bits [31:0]. \n; /// 01: Copies the selected bits from \a Y to result bits [63:32]. \n; /// 10: Copies the selected bits from \a Y to result bits [95:64]. \n; /// 11: Copies the selected bits from \a Y to result bits [127:96]. \n; /// Bits[3:0]: If any of these bits are set, the corresponding result; /// element is cleared.; /// \returns A 128-bit vector of [4 x float] containing the copied; /// single-precision floating point elements from the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:107,Modifiability,extend,extended,107,"/* __x86_64__ */; /* Extract int from packed integer array at index. This returns the element; * as a zero extended value, so it is unsigned.; */; /// Extracts an 8-bit element from the 128-bit integer vector of; /// [16 x i8], using the immediate value parameter \a N as a selector.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_extract_epi8(__m128i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPEXTRB / PEXTRB </c> instruction.; ///; /// \param X; /// A 128-bit integer vector.; /// \param N; /// An immediate value. Bits [3:0] specify which 8-bit vector element from; /// the argument \a X to extract and copy to the result. \n; /// 0000: Bits [7:0] of parameter \a X are extracted. \n; /// 0001: Bits [15:8] of the parameter \a X are extracted. \n; /// 0010: Bits [23:16] of the parameter \a X are extracted. \n; /// 0011: Bits [31:24] of the parameter \a X are extracted. \n; /// 0100: Bits [39:32] of the parameter \a X are extracted. \n; /// 0101: Bits [47:40] of the parameter \a X are extracted. \n; /// 0110: Bits [55:48] of the parameter \a X are extracted. \n; /// 0111: Bits [63:56] of the parameter \a X are extracted. \n; /// 1000: Bits [71:64] of the parameter \a X are extracted. \n; /// 1001: Bits [79:72] of the parameter \a X are extracted. \n; /// 1010: Bits [87:80] of the parameter \a X are extracted. \n; /// 1011: Bits [95:88] of the parameter \a X are extracted. \n; /// 1100: Bits [103:96] of the parameter \a X are extracted. \n; /// 1101: Bits [111:104] of the parameter \a X are extracted. \n; /// 1110: Bits [119:112] of the parameter \a X are extracted. \n; /// 1111: Bits [127:120] of the parameter \a X are extracted.; /// \returns An unsigned integer, whose lower 8 bits are selected from the; /// 128-bit integer vector parameter and the remaining bits are assigned; /// zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Testability,Test,Tests,52,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:327,Testability,test,tested,327,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:405,Testability,test,test,405,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:278,Testability,test,tested,278,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:356,Testability,test,test,356,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:300,Testability,test,tested,300,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:378,Testability,test,test,378,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_ones(__m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param V; /// A 128-bit integer vector containing the bits to be tested.; /// \returns TRUE if the bits specified in the operand are all set to 1; FALSE; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:345,Testability,test,tested,345,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_ones(__m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param V; /// A 128-bit integer vector containing the bits to be tested.; /// \returns TRUE if the bits specified in the operand are all set to 1; FALSE; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:384,Testability,test,tested,384,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:460,Testability,test,test,460,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:358,Testability,test,tested,358,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:434,Testability,test,test,434,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Modifiability,extend,extends,52,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:505,Modifiability,extend,extended,505,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:596,Modifiability,extend,extended,596,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:461,Modifiability,extend,extended,461,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:552,Modifiability,extend,extended,552,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Modifiability,extend,extends,52,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:505,Modifiability,extend,extended,505,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:596,Modifiability,extend,extended,596,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:461,Modifiability,extend,extended,461,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:552,Modifiability,extend,extended,552,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:275,Availability,mask,mask,275,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1716,Availability,mask,mask,1716,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1798,Availability,mask,mask,1798,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1854,Availability,mask,mask,1854,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2275,Availability,mask,mask,2275,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1995,Modifiability,extend,extended,1995,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2064,Modifiability,extend,extended,2064,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:83,Performance,perform,perform,83,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:863,Performance,perform,perform,863,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1673,Performance,perform,perform,1673,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2151,Performance,perform,performed,2151,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1652,Availability,mask,mask,1652,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1734,Availability,mask,mask,1734,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1790,Availability,mask,mask,1790,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:802,Performance,perform,perform,802,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1609,Performance,perform,perform,1609,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:231,Availability,mask,mask,231,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1848,Availability,mask,mask,1848," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1930,Availability,mask,mask,1930," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1986,Availability,mask,mask,1986," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2410,Availability,mask,mask,2410," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2127,Modifiability,extend,extended,2127," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2196,Modifiability,extend,extended,2196," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:995,Performance,perform,perform,995,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1805,Performance,perform,perform,1805," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2283,Performance,perform,performed,2283," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1828,Availability,mask,mask,1828,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1910,Availability,mask,mask,1910,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1966,Availability,mask,mask,1966,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestri(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:978,Performance,perform,perform,978,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestri(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1785,Performance,perform,perform,1785,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:252,Availability,mask,mask,252,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1720,Availability,mask,mask,1720," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1802,Availability,mask,mask,1802," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1858,Availability,mask,mask,1858," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1982,Availability,mask,mask,1982," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:101,Performance,perform,perform,101,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:908,Performance,perform,perform,908,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1677,Performance,perform,perform,1677," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,Availability,mask,mask,190,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1607,Availability,mask,mask,1607,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1689,Availability,mask,mask,1689,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1745,Availability,mask,mask,1745,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1866,Availability,mask,mask,1866,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:798,Performance,perform,perform,798,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1564,Performance,perform,perform,1564,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,Availability,mask,mask,204,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1582,Availability,mask,mask,1582,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1664,Availability,mask,mask,1664,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1720,Availability,mask,mask,1720,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1858,Availability,mask,mask,1858,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:773,Performance,perform,perform,773,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1539,Performance,perform,perform,1539,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,Availability,mask,mask,1643,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1725,Availability,mask,mask,1725,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1781,Availability,mask,mask,1781,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:831,Performance,perform,perform,831,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1600,Performance,perform,perform,1600,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,Availability,mask,mask,1643,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1725,Availability,mask,mask,1725,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1781,Availability,mask,mask,1781,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:831,Performance,perform,perform,831,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1600,Performance,perform,perform,1600,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,Availability,mask,mask,190,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1834,Availability,mask,mask,1834," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1916,Availability,mask,mask,1916," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1972,Availability,mask,mask,1972," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2093,Availability,mask,mask,2093," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1022,Performance,perform,perform,1022,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1791,Performance,perform,perform,1791," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:196,Availability,mask,mask,196,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1792,Availability,mask,mask,1792,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1874,Availability,mask,mask,1874,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1930,Availability,mask,mask,1930,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2060,Availability,mask,mask,2060,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:980,Performance,perform,perform,980,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1749,Performance,perform,perform,1749,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,Availability,mask,mask,204,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1761,Availability,mask,mask,1761,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1843,Availability,mask,mask,1843,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1899,Availability,mask,mask,1899,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2034,Availability,mask,mask,2034,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:949,Performance,perform,perform,949,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1718,Performance,perform,perform,1718,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1819,Availability,mask,mask,1819," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1901,Availability,mask,mask,1901," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1957,Availability,mask,mask,1957," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1007,Performance,perform,perform,1007,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1776,Performance,perform,perform,1776," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1802,Availability,mask,mask,1802,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1884,Availability,mask,mask,1884,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1940,Availability,mask,mask,1940,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:990,Performance,perform,perform,990,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1759,Performance,perform,perform,1759,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:503,Integrability,interface,interfaces,503,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:640,Integrability,interface,interfaces,640,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:706,Integrability,interface,interfaces,706,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:863,Integrability,interface,interfaces,863,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:1280,Integrability,interface,interfaces,1280,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:21,Modifiability,Variab,Variable,21,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:585,Security,expose,expose,585,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:1503,Usability,simpl,simple,1503,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdatomic.h:273,Availability,error,error,273,"/* If we're hosted, fall back to the system's stdatomic.h. FreeBSD, for; * example, already has a Clang-compatible stdatomic.h header.; *; * Exclude the MSVC path as well as the MSVC header as of the 14.31.30818; * explicitly disallows `stdatomic.h` in the C mode via an `#error`. Fallback; * to the clang resource header until that is fully supported. The; * `stdatomic.h` header requires C++ 23 or newer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdatomic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdatomic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h:41,Performance,perform,performing,41,/* C23 7.20.1 Defines several macros for performing checked integer arithmetic*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdckdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h:438,Integrability,message,message,438,"// Both A and B shall be any integer type other than ""plain"" char, bool, a bit-; // precise integer type, or an enumerated type, and they need not be the same.; // R shall be a modifiable lvalue of any integer type other than ""plain"" char,; // bool, a bit-precise integer type, or an enumerated type. It shouldn't be; // short type, either. Otherwise, it may be unable to hold two the result of; // operating two 'int's.; // A diagnostic message will be produced if A or B are not suitable integer; // types, or if R is not a modifiable lvalue of a suitable integer type or R; // is short type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdckdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:503,Integrability,interface,interfaces,503,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:640,Integrability,interface,interfaces,640,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:706,Integrability,interface,interfaces,706,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:863,Integrability,interface,interfaces,863,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:1280,Integrability,interface,interfaces,1280,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:585,Security,expose,expose,585,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:1503,Usability,simpl,simple,1503,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h:79,Security,expose,exposes,79,"/* NB: The C standard requires that these be the same value, but the compiler; exposes separate internal width macros. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h:79,Security,expose,exposes,79,"/* NB: The C standard requires that these be the same value, but the compiler; exposes separate internal width macros. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:132,Safety,avoid,avoid,132,/*; * Allow additional definitions and implementation-defined values on Apple; * platforms. This is done after #include <math.h> to avoid depcycle conflicts; * between libcxx and darwin in C++ modules builds.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:3,Testability,log,log,3,// log,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:3,Testability,log,logb,3,// logb,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:87,Usability,clear,clears,87,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:512,Usability,Clear,Clear,512,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:802,Usability,clear,cleared,802,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:86,Usability,clear,clears,86,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:508,Usability,Clear,Clear,508,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:768,Usability,clear,cleared,768,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,Performance,perform,perform,56,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:494,Usability,clear,clear,494,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:495,Usability,clear,clear,495,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the doubleword in the second source is; /// positive, copy the corresponding word from the first source to the; /// destination. If the doubleword in the second source is zero, clear the; /// corresponding word in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control doublewords corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:513,Usability,clear,clear,513,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the doubleword in the second source is; /// positive, copy the corresponding word from the first source to the; /// destination. If the doubleword in the second source is zero, clear the; /// corresponding word in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control doublewords corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,Performance,perform,perform,56,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:494,Usability,clear,clear,494,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNW instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:495,Usability,clear,clear,495,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNW instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding doubleword in the first source, and; /// write that value to the destination. If the doubleword in the second; /// source is positive, copy the corresponding doubleword from the first; /// source to the destination. If the doubleword in the second source is; /// zero, clear the corresponding doubleword in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGND instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing two control doublewords corresponding; /// to positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:530,Usability,clear,clear,530,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding doubleword in the first source, and; /// write that value to the destination. If the doubleword in the second; /// source is positive, copy the corresponding doubleword from the first; /// source to the destination. If the doubleword in the second source is; /// zero, clear the corresponding doubleword in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGND instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing two control doublewords corresponding; /// to positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:44,Performance,load,load,44,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:147,Performance,load,loads,147,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:243,Performance,load,load,243,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:298,Safety,abort,abort,298,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:42,Performance,load,load,42,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:120,Performance,load,load,120,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:203,Performance,load,load,203,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:367,Safety,abort,abort,367,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:446,Performance,load,loads,446,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:382,Safety,abort,abort,382,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
