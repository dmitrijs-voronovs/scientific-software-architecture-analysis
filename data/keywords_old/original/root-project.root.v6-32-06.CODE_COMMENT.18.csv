id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:59,Performance,load,loaded,59,"// Try to get the region from which the released value was loaded.; // Note that, unlike diagnosing for missing releases, here we don't track; // values that must not be released in the state. This is because even if; // these values escape, it is still an error under the rules of MRR to; // release them in -dealloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:54,Deployability,release,released,54,"// If the ivar belongs to a property that must not be released directly; // in dealloc, emit a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:88,Integrability,interface,interface,88,"// If the property is readwrite but it shadows a read-only property in its; // external interface, treat the property a read-only. If the outside; // world cannot write to a property then the internal implementation is free; // to make its own convention about whether the value is stored retained; // or not. We look up the shadow here rather than in; // getDeallocReleaseRequirement() because doing so can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:42,Modifiability,variab,variable,42,// Find the property backing the instance variable that M; // is dealloc'ing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:32,Deployability,release,release,32,/// Add a transition noting the release of the given value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:33,Deployability,release,release,33,/// Remove the Value requiring a release from the tracked set for; /// Instance and return the resultant state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:43,Deployability,release,release,43,// Mark the value as no longer requiring a release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:86,Deployability,release,released,86,/// Determines whether the instance variable for \p PropImpl must or must not be; /// released in -dealloc or whether it cannot be determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:36,Modifiability,variab,variable,36,/// Determines whether the instance variable for \p PropImpl must or must not be; /// released in -dealloc or whether it cannot be determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:124,Deployability,release,released,124,// Retain and copy setters retain/copy their values before storing and so; // the value in their instance variables must be released in -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:106,Modifiability,variab,variables,106,// Retain and copy setters retain/copy their values before storing and so; // the value in their instance variables must be released in -dealloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:105,Deployability,release,release,105,"// It is common for the ivars for read-only assign properties to; // always be stored retained, so their release requirement cannot be; // be determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:16,Deployability,release,released,16,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:60,Deployability,release,releases,60,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:111,Modifiability,variab,variable,111,/// Returns the released value if M is a call a setter that releases; /// and nils out its underlying instance variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:151,Deployability,release,releases,151,"/// Returns true if the ID is a class in which is known to have; /// a separate teardown lifecycle. In this case, -dealloc warnings; /// about missing releases should be suppressed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:143,Availability,down,down,143,"// FIXME: For now, ignore classes that subclass SenTestCase and XCTestCase,; // as these don't need to implement -dealloc. They implement tear down in; // another way, which we should try and catch later.; // http://llvm.org/bugs/show_bug.cgi?id=3187",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:67,Deployability,release,release,67,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:254,Deployability,release,release,254,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:344,Deployability,release,release,344,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:412,Deployability,release,released,412,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:89,Modifiability,variab,variables,89,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:136,Modifiability,variab,variable,136,"/// The -dealloc method in CIFilter highly unusual in that is will release; /// instance variables belonging to its *subclasses* if the variable name; /// starts with ""input"" or backs a property whose name starts with ""input"".; /// Subclasses should not release these ivars in their own -dealloc method --; /// doing so could result in an over release.; ///; /// This method returns true if the property will be released by; /// -[CIFilter dealloc].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:100,Performance,load,loading,100,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:193,Performance,load,loading,193,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:310,Performance,load,loading,310,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp:500,Integrability,interface,interface,500,"//===-- CheckObjCInstMethSignature.cpp - Check ObjC method signatures -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCInstMethSignature, a flow-insensitive check; // that determines if an Objective-C class interface incorrectly redefines; // the method signature in a subclass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp:126,Deployability,patch,patch,126,// Right now don't compare the compatibility of pointers. That involves; // looking at subtyping relationships. FIXME: Future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCInstMethSignature.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:42,Security,secur,security,42,"//==- CheckSecuritySyntaxOnly.cpp - Basic security checks --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of flow-insensitive security checks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:427,Security,secur,security,427,"//==- CheckSecuritySyntaxOnly.cpp - Basic security checks --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of flow-insensitive security checks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:27,Usability,simpl,simple,27,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:45,Security,secur,security,45,"// If the callee isn't defined, it is not of security concern.; // Check and evaluate the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:305,Integrability,depend,depending,305,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:107,Modifiability,variab,variable,107,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:159,Security,secur,security,159,"//===----------------------------------------------------------------------===//; // Check: floating point variable used as loop counter.; // Implements: CERT security coding advisory FLP-30.; //===----------------------------------------------------------------------===//; // Returns either 'x' or 'y', depending on which one of them is incremented; // in 'expr', or nullptr if none of them is incremented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:102,Modifiability,variab,variable,102,"/// CheckLoopConditionForFloat - This check looks for 'for' statements that; /// use a floating point variable as a loop counter.; /// CERT: FLP30-C, FLP30-CPP.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:20,Modifiability,variab,variables,20,// Are we comparing variables?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:28,Modifiability,variab,variables,28,// Does at least one of the variables have a floating point type?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:15,Modifiability,variab,variable,15,// Does either variable appear in increment?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:12,Availability,error,error,12,// Emit the error. First figure out which DeclRefExpr in the condition; // referenced the compared variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:99,Modifiability,variab,variable,99,// Emit the error. First figure out which DeclRefExpr in the condition; // referenced the compared variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:20,Security,secur,security,20,"// Fall back to the security check of looking for enough 'X's in the; // format string, since that is a less severe warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:119,Modifiability,variab,variables,119,"// Currently we only handle string literals. It is possible to do better,; // either by looking at references to const variables, or by doing real; // flow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:55,Safety,unsafe,unsafe,55,// Issue a warning. ArgIndex == -1: Deprecated but not unsafe (has size; // restrictions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:130,Modifiability,variab,variables,130,"// Currently we only handle (not wide) string literals. It is possible to do; // better, either by looking at references to const variables, or by doing; // real flow analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:199,Energy Efficiency,Efficient,Efficient,199,"//===----------------------------------------------------------------------===//; // Check: Linear congruent random number generators should not be used,; // i.e. rand(), random().; //; // E. Bach, ""Efficient prediction of Marsaglia-Zaman random number generators,""; // in IEEE Transactions on Information Theory, vol. 44, no. 3, pp. 1253-1257,; // May 1998, https://doi.org/10.1109/18.669305; //; // CWE-338: Use of cryptographically weak prng; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:209,Safety,predict,prediction,209,"//===----------------------------------------------------------------------===//; // Check: Linear congruent random number generators should not be used,; // i.e. rand(), random().; //; // E. Bach, ""Efficient prediction of Marsaglia-Zaman random number generators,""; // in IEEE Transactions on Information Theory, vol. 44, no. 3, pp. 1253-1257,; // May 1998, https://doi.org/10.1109/18.669305; //; // CWE-338: Use of cryptographically weak prng; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:9,Availability,avail,availability,9,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:167,Availability,avail,available,167,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:29,Security,secur,secure,29,"// Check availability of the secure alternative:; // iOS 11+, macOS 10.13+, tvOS 11+, and watchOS 4.0+; // FIXME: We probably shouldn't register the check if it's not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:466,Security,access,access,466,"//===----------------------------------------------------------------------===//; // Check: The caller should always verify that the privileges; // were dropped successfully.; //; // Some library functions, like setuid() and setgid(), should always be used; // with a check of the return value to verify that the function completed; // successfully. If the drop fails, the software will continue to run; // with the raised privileges, which might provide additional access; // to unprivileged users.; //; // (Note that this check predates __attribute__((warn_unused_result)).; // Do we still need it now that we have a compiler warning for this?; // Are these standard functions already annotated this way?); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:56,Integrability,depend,depending,56,// Verify that the function takes one or two arguments (depending on; // the function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:85,Security,Secur,SecuritySyntaxChecker,85,//===----------------------------------------------------------------------===//; // SecuritySyntaxChecker; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:34,Safety,detect,detection,34,"//===--- CloneChecker.cpp - Clone detection checker -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// CloneChecker is a checker that reports clones in the current translation; /// unit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:370,Availability,error,errors,370,"// At this point, every statement in the translation unit has been analyzed by; // the CloneDetector. The only thing left to do is to report the found clones.; // Let the CloneDetector create a list of clones from all the analyzed; // statements. We don't filter for matching variable patterns at this point; // because reportSuspiciousClones() wants to search them for errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:276,Modifiability,variab,variable,276,"// At this point, every statement in the translation unit has been analyzed by; // the CloneDetector. The only thing left to do is to report the found clones.; // Let the CloneDetector create a list of clones from all the analyzed; // statements. We don't filter for matching variable patterns at this point; // because reportSuspiciousClones() wants to search them for errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:66,Availability,error,errors,66,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:33,Safety,detect,detector,33,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:50,Modifiability,variab,variable,50,"// For now, we only report clones which break the variable pattern just; // once because multiple differences in a pattern are an indicator that; // those differences are maybe intended (e.g. because it's actually a; // different algorithm).; // FIXME: In very big clones even multiple variables can be unintended,; // so replacing this number with a percentage could better handle such; // cases. On the other hand it could increase the false-positive rate; // for all clones if the percentage is too high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:286,Modifiability,variab,variables,286,"// For now, we only report clones which break the variable pattern just; // once because multiple differences in a pattern are an indicator that; // those differences are maybe intended (e.g. because it's actually a; // different algorithm).; // FIXME: In very big clones even multiple variables can be unintended,; // so replacing this number with a percentage could better handle such; // cases. On the other hand it could increase the false-positive rate; // for all clones if the percentage is too high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:189,Performance,perform,perform,189,"// FIXME: We are ignoring the suggestions currently, because they are; // only 50% accurate (even if the second suggestion is unavailable),; // which may confuse the user.; // Think how to perform more accurate suggestions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:58,Availability,alive,alive,58,// Keep symbolic expressions of container begins and ends alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:7,Usability,clear,clear,7,"// The clear() operation invalidates all the iterators, except the past-end; // iterators of list-like containers",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:36,Modifiability,variab,variable,36,// First try to get the name of the variable from the region,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid overflow in our later calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Usability,Simpl,Simple,3,// Simple case: the destination can store all values of the source type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:8,Security,access,access,8,// read access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:6,Usability,usab,usable,6,// Re-usable checks,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:65,Modifiability,Refactor,Refactor,65,// FIXME: This was originally copied from ArrayBoundChecker.cpp. Refactor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:40,Security,access,access,40,// Check for out of bound array element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:24,Security,access,accessed,24,// Get the index of the accessed element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:44,Security,access,accessible,44,// Check if the first byte of the buffer is accessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:11,Security,access,access,11,// Get the access length and make sure it is known.; // FIXME: This assumes the caller has already checked that the access length; // is positive. And that it's unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:116,Security,access,access,116,// Get the access length and make sure it is known.; // FIXME: This assumes the caller has already checked that the access length; // is positive. And that it's unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Security,access,accessed,48,// Compute the offset of the last element to be accessed: size-1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:37,Safety,abort,abort,37,"// If the buffer isn't large enough, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:222,Availability,failure,failure,222,"// Do a simple check for overlap: if the two arguments are from the same; // buffer, see if the end of the first is greater than the start of the second; // or vice versa.; // If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:8,Usability,simpl,simple,8,"// Do a simple check for overlap: if the two arguments are from the same; // buffer, see if the end of the first is greater than the start of the second; // or vice versa.; // If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:52,Performance,perform,perform,52,"// If we don't know which one comes first, we can't perform this test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:65,Testability,test,test,65,"// If we don't know which one comes first, we can't perform this test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:67,Usability,clear,clear,67,"// FIXME: It would be nice to eventually make this diagnostic more clear,; // e.g., by referencing the original declaration or by saying *why* this; // reference is outside the range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:109,Availability,error,error,109,"// FIXME: This call uses the word ""API"" as the description of the bug;; // it should be replaced by a better error message (if this unlikely; // situation continues to exist as a separate bug type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:115,Integrability,message,message,115,"// FIXME: This call uses the word ""API"" as the description of the bug;; // it should be replaced by a better error message (if this unlikely; // situation continues to exist as a separate bug type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:22,Availability,error,error,22,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:28,Integrability,message,message,28,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:49,Availability,failure,failure,49,"// If a previous check has failed, propagate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,reliab,reliable,48,"// Other regions (mostly non-data) can't have a reliable C string length.; // For now, just ignore the change.; // FIXME: These are rare but not impossible. We should output some kind of; // warning for things like strcpy((char[]){'a', 0}, ""b"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:35,Deployability,update,update,35,"// Otherwise, get a new symbol and update the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,reliab,reliable,48,"// Other regions (mostly non-data) can't have a reliable C string length.; // In this case, an error is emitted and UndefinedVal is returned.; // The caller should always be prepared to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:95,Availability,error,error,95,"// Other regions (mostly non-data) can't have a reliable C string length.; // In this case, an error is emitted and UndefinedVal is returned.; // The caller should always be prepared to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:68,Security,access,accessed,68,// cf top comment.; // Compute the offset of the last element to be accessed: size-1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:40,Security,access,access,40,// Check for out of bound array element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:24,Security,access,accessed,24,// Get the index of the accessed element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:47,Security,access,access,47,"// If destination buffer is a field region and access is in bound, do; // not invalidate its super region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:174,Modifiability,refactor,refactored,174,"// FIXME: This is a simplified version of what's in CFRefCount.cpp -- it makes; // some assumptions about the value that CFRefCount can't. Even so, it should; // probably be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:20,Usability,simpl,simplified,20,"// FIXME: This is a simplified version of what's in CFRefCount.cpp -- it makes; // some assumptions about the value that CFRefCount can't. Even so, it should; // probably be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:21,Modifiability,layers,layers,21,// FIXME: What about layers of ElementRegions?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the destination buffer and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:14,Security,access,accesses,14,// Ensure the accesses are valid and that the buffers do not overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,Availability,error,errors,48,// These two values allow checking two kinds of errors:; // - actual overflows caused by a source that doesn't fit in the destination; // - potential overflows caused by a bound that could exceed the destination,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:46,Security,access,access,46,// FIXME: Why do we choose the srcExpr if the access has no size?; // Note that the 3rd argument of the call would be the size parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:362,Security,access,accessed,362,"// For strncpy and strlcat, this is just checking; // that lenVal <= sizeof(dst).; // (Yes, strncpy and strncat differ in how they treat termination.; // strncat ALWAYS terminates, but strncpy doesn't.); // We need a special case for when the copy size is zero, in which; // case strncpy will do no work at all. Our bounds check uses n-1; // as the last element accessed, so n == 0 is problematic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:6,Modifiability,extend,extend,6,// we extend the dst string with the src; // finalStrLength >= dstStrLength,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:200,Usability,clear,clear,200,"// Invalidate the destination (regular invalidation without pointer-escaping; // the address of the top-level region). This must happen before we set the; // C string length because invalidation will clear the length.; // FIXME: Even if we can't perfectly model the copy, we should see if we; // can use LazyCompoundVals to copy the source values into the destination.; // This would probably remove any existing bindings past the end of the; // string, but that's still an improvement over blank invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the buffer and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,Security,access,access,57,"// If the size is zero, there won't be any actual memory access,; // In this case we just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:46,Safety,safe,safe,46,"// Pro-actively check that argument types are safe to do arithmetic upon.; // We do not want to crash if someone accidentally passes a structure; // into, say, a C++ overload of any of these functions. We could not check; // that for std::copy because they may have arguments of other types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:152,Safety,safe,safety,152,"// If the evaluate call resulted in no change, chain to the next eval call; // handler.; // Note, the custom CString evaluation calls assume that basic safety; // properties are held. However, if the user chooses to turn off some of these; // checks, we ignore the issues and leave the call evaluation to a generic; // handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp:569,Modifiability,polymorphi,polymorphic,569,"//=== CXXDeleteChecker.cpp -------------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the following new checkers for C++ delete expressions:; //; // * DeleteWithNonVirtualDtorChecker; // Defines a checker for the OOP52-CPP CERT rule: Do not delete a; // polymorphic object without a virtual destructor.; //; // Diagnostic flags -Wnon-virtual-dtor and -Wdelete-non-virtual-dtor; // report if an object with a virtual function but a non-virtual; // destructor exists or is deleted, respectively.; //; // This check exceeds them by comparing the dynamic and static types of; // the object at the point of destruction and only warns if it happens; // through a pointer to a base type without a virtual destructor. The; // check places a note at the last point where the conversion from; // derived to base happened.; //; // * CXXArrayDeleteChecker; // Defines a checker for the EXP51-CPP CERT rule: Do not delete an array; // through a pointer of the incorrect type.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXDeleteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp:433,Testability,test,tests,433,"//=== CXXSelfAssignmentChecker.cpp -----------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines CXXSelfAssignmentChecker, which tests all custom defined; // copy and move assignment operators for the case of self assignment, thus; // where the parameter refers to the same location where the this pointer; // points to. The checker itself does not do any checks at all, but it; // causes the analyzer to check every copy and move assignment operator twice:; // once for when 'this' aliases with the parameter and once for when it may not.; // It is the task of the other enabled checkers to find the bugs in these two; // different cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CXXSelfAssignmentChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:55,Modifiability,variab,variables,55,"//==- DeadStoresChecker.cpp - Check for stores to dead variables -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a DeadStores, a flow-sensitive checker that looks for; // stores to variables that are no longer live.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:469,Modifiability,variab,variables,469,"//==- DeadStoresChecker.cpp - Check for stores to dead variables -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a DeadStores, a flow-sensitive checker that looks for; // stores to variables that are no longer live.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:6,Usability,simpl,simple,6,/// A simple visitor to record what VarDecls occur in EH-handling code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:79,Modifiability,variab,variable,79,"// Special case: self-assignments. These are often used to shut up; // ""unused variable"" compiler warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:30,Modifiability,variab,variable,30,// A dead initialization is a variable that is dead after it; // is initialized. We don't flag warnings for those variables; // marked 'unused' or 'objc_precise_lifetime'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:114,Modifiability,variab,variables,114,// A dead initialization is a variable that is dead after it; // is initialized. We don't flag warnings for those variables; // marked 'unused' or 'objc_precise_lifetime'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:60,Modifiability,variab,variables,60,// Special case: check for initialization from constant; // variables.; //; // e.g. extern const int MyConstant;; // int x = MyConstant;; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:146,Availability,error,error,146,// Special case: check for initialization from scalar; // parameters. This is often a form of defensive; // programming. Non-scalars are still an error since; // because it more likely represents an actual algorithmic; // bug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:15,Modifiability,variab,variables,15,// Treat local variables captured by reference in C++ lambdas as escaped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp:85,Modifiability,Config,ConfigDumper,85,//===----------------------------------------------------------------------===//; // ConfigDumper; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DebugCheckers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:449,Performance,perform,performs,449,"//===-- DereferenceChecker.cpp - Null dereference checker -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines NullDerefChecker, a builtin check in ExprEngine that performs; // checks for null pointers at loads and stores.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:490,Performance,load,loads,490,"//===-- DereferenceChecker.cpp - Null dereference checker -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines NullDerefChecker, a builtin check in ExprEngine that performs; // checks for null pointers at loads and stores.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:94,Performance,load,load,94,// Walk through lvalue casts to get the original expression; // that syntactically caused the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:302,Availability,error,error,302,"// Do not report dereferences on memory that use address space #256, #257,; // and #258. Those address spaces are used when dereferencing address spaces; // relative to the GS, FS, and SS segments on x86/x86-64 targets.; // Dereferencing a null pointer in these address spaces is not defined; // as an error. All other null dereferences in other address spaces; // are defined as an error unless explicitly defined.; // See https://clang.llvm.org/docs/LanguageExtensions.html, the section; // ""X86/X86-64 Language Extensions""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:383,Availability,error,error,383,"// Do not report dereferences on memory that use address space #256, #257,; // and #258. Those address spaces are used when dereferencing address spaces; // relative to the GS, FS, and SS segments on x86/x86-64 targets.; // Dereferencing a null pointer in these address spaces is not defined; // as an error. All other null dereferences in other address spaces; // are defined as an error unless explicitly defined.; // See https://clang.llvm.org/docs/LanguageExtensions.html, the section; // ""X86/X86-64 Language Extensions""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:99,Availability,error,error,99,"// Otherwise, we have the case where the location could either be; // null or not-null. Record the error node as an ""implicit"" null; // dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:213,Safety,safe,safe,213,"// Unlike a regular null dereference, initializing a reference with a; // dereferenced null pointer does not actually cause a runtime exception in; // Clang's implementation of references.; //; // int &r = *p; // safe??; // if (p != NULL) return; // uh-oh; // r = 5; // trap here; //; // The standard says this is invalid as soon as we try to create a ""null; // reference"" (there is no such thing), but turning this into an assumption; // that 'p' is never null will not match our actual runtime behavior.; // So we do not record this assumption, allowing us to warn on the last line; // of this example.; //; // We do need to add a transition because we may have generated a sink for; // the ""implicit"" null dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:238,Modifiability,variab,variable,238,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:109,Performance,perform,performed,109,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:214,Performance,perform,perform,214,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,Security,access,accesses,47,"// Register the checker that checks for direct accesses in functions annotated; // with __attribute__((annotate(""objc_no_direct_instance_variable_assignment""))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:117,Integrability,rout,routines,117,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,Security,access,accesses,47,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp:447,Performance,perform,performs,447,"//== DivZeroChecker.cpp - Division by zero checker --------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines DivZeroChecker, a builtin check in ExprEngine that performs; // checks for division by zeros.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:625,Availability,error,error,625,"//== DynamicTypeChecker.cpp ------------------------------------ -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker looks for cases where the dynamic type of an object is unrelated; // to its static type. The type information utilized by this check is collected; // by the DynamicTypePropagation checker. This check does not report any type; // error for ObjC Generic types, in order to avoid duplicate erros from the; // ObjC Generics checker. This checker is not supposed to modify the program; // state, it is just the observer of the type information provided by other; // checkers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:667,Safety,avoid,avoid,667,"//== DynamicTypeChecker.cpp ------------------------------------ -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker looks for cases where the dynamic type of an object is unrelated; // to its static type. The type information utilized by this check is collected; // by the DynamicTypePropagation checker. This check does not report any type; // error for ObjC Generic types, in order to avoid duplicate erros from the; // ObjC Generics checker. This checker is not supposed to modify the program; // state, it is just the observer of the type information provided by other; // checkers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:34,Safety,detect,detect,34,// Strip kindeofness to correctly detect subtyping relationships.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:539,Availability,error,errors,539,"//===- DynamicTypePropagation.cpp ------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains two checkers. One helps the static analyzer core to track; // types, the other does type inference on Obj-C generics and report type; // errors.; //; // Dynamic Type Propagation:; // This checker defines the rules for dynamic type gathering and propagation.; //; // Generics Checker for Objective-C:; // This checker tries to find type errors that the compiler is not able to catch; // due to the implicit conversions that were introduced for backward; // compatibility.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:738,Availability,error,errors,738,"//===- DynamicTypePropagation.cpp ------------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains two checkers. One helps the static analyzer core to track; // types, the other does type inference on Obj-C generics and report type; // errors.; //; // Dynamic Type Propagation:; // This checker defines the rules for dynamic type gathering and propagation.; //; // Generics Checker for Objective-C:; // This checker tries to find type errors that the compiler is not able to catch; // due to the implicit conversions that were introduced for backward; // compatibility.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:107,Integrability,message,message,107,// Check if we can statically infer the actual type precisely.; //; // 1. Class is written directly in the message:; // \code; // [ActualClass classMethod];; // \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:80,Modifiability,variab,variable,80,"// Another way we can guess what is in Class object, is when it is a; // 'self' variable of the current class method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:151,Integrability,message,message,151,// We assume that the type of the object returned by alloc and new are the; // pointer to the object of the class specified in the receiver of the; // message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:171,Integrability,depend,depends,171,"// We used to assume that whatever type we got from inferring the; // type is actually precise (and it is not exactly correct).; // A big portion of the existing behavior depends on that assumption; // (e.g. certain inlining won't take place). For this reason, we don't; // use ObjTy.Precise flag here.; //; // TODO: We should mitigate this problem some time in the future; // and replace hardcoded 'false' with '!ObjTy.Precise'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:18,Usability,undo,undo,18,// We may need to undo the effects of our pre-call check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:314,Availability,avail,available,314,"// FIXME: In C++17 classes with non-virtual bases may be treated as; // aggregates, and in such case no top-frame constructor will be called.; // Figure out if we need to do anything in this case.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) available in this; // callback, ideally as part of CallEvent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:198,Modifiability,inherit,inheritance,198,"// Return a better dynamic type if one can be derived from the cast.; // Compare the current dynamic type of the region and the new type to which we; // are casting. If the new type is lower in the inheritance hierarchy, pick it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:6,Availability,down,downcast,6,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:97,Availability,down,downcast,97,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:275,Availability,recover,recover,275,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:275,Safety,recover,recover,275,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:498,Modifiability,rewrite,rewrite,498,"// TODO: The above 4 cases are not exhaustive. In particular, it is possible; // for Current to be incomparable with StaticLowerBound, StaticUpperBound,; // or both.; //; // For example, suppose Foo<T> and Bar<T> are unrelated types.; //; // Foo<T> *f = ...; // Bar<T> *b = ...; //; // id t1 = b;; // f = t1;; // id t2 = f; // StaticLowerBound is Foo<T>, Current is Bar<T>; //; // We should either constrain the callers of this function so that the stated; // preconditions hold (and assert it) or rewrite the function to expicitly; // handle the additional cases.; // Precondition",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:484,Testability,assert,assert,484,"// TODO: The above 4 cases are not exhaustive. In particular, it is possible; // for Current to be incomparable with StaticLowerBound, StaticUpperBound,; // or both.; //; // For example, suppose Foo<T> and Bar<T> are unrelated types.; //; // Foo<T> *f = ...; // Bar<T> *b = ...; //; // id t1 = b;; // f = t1;; // id t2 = f; // StaticLowerBound is Foo<T>, Current is Bar<T>; //; // We should either constrain the callers of this function so that the stated; // preconditions hold (and assert it) or rewrite the function to expicitly; // handle the additional cases.; // Precondition",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:61,Modifiability,inherit,inheritance,61,// The type arguments might not be forwarded at any point of inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:60,Availability,avail,available,60,"/// Type inference based on static type information that is available for the; /// cast and the tracked type information for the given symbol. When the tracked; /// symbol and the destination type of the cast are unrelated, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:234,Availability,error,error,234,"/// Type inference based on static type information that is available for the; /// cast and the tracked type information for the given symbol. When the tracked; /// symbol and the destination type of the cast are unrelated, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:16,Safety,detect,detects,16,// This checker detects the subtyping relationships using the assignment; // rules. In order to be able to do this the kindofness must be stripped; // first. The checker treats every type as kindof type anyways: when the; // tracked type is the subtype of the static type it tries to look up the; // methods in the tracked type first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:493,Availability,down,down,493,"// Treat explicit casts as an indication from the programmer that the; // Objective-C type system is not rich enough to express the needed; // invariant. In such cases, forget any existing information inferred; // about the type arguments. We don't assume the casted-to specialized; // type here because the invariant the programmer specifies in the cast; // may only hold at this particular program point and not later ones.; // We don't want a suppressing cast to require a cascade of casts down the; // line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:120,Availability,down,downcast,120,"// The tracked type should be the sub or super class of the static destination; // type. When an (implicit) upcast or a downcast happens according to static; // types, and there is no subtyping relationship between the tracked and the; // static destination types, it indicates an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:281,Availability,error,error,281,"// The tracked type should be the sub or super class of the static destination; // type. When an (implicit) upcast or a downcast happens according to static; // types, and there is no subtyping relationship between the tracked and the; // static destination types, it indicates an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:10,Availability,down,downcasts,10,// Handle downcasts and upcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:58,Integrability,interface,interface,58,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:115,Integrability,depend,dependent,115,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:28,Modifiability,parameteriz,parameterized,28,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:26,Availability,avail,available,26,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:108,Availability,avail,available,108,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:43,Integrability,interface,interface,43,"/// A method might not be available in the interface indicated by the static; /// type. However it might be available in the tracked type. In order to; /// properly substitute the type parameters we need the declaration context of; /// the method. The more specialized the enclosing class of the method is, the; /// more likely that the parameter substitution will be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:33,Integrability,depend,depends,33,// Check whether the result type depends on a type parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:95,Integrability,message,message,95,"/// When the receiver has a tracked type, use that type to validate the; /// argumments of the message expression and the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:59,Security,validat,validate,59,"/// When the receiver has a tracked type, use that type to validate the; /// argumments of the message expression and the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:129,Performance,perform,performing,129,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:650,Safety,Safe,Safe,650,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:762,Safety,Safe,Safe,762,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:799,Safety,Unsafe,Unsafe,799,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:436,Availability,error,errors,436,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:107,Integrability,message,messages,107,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:55,Modifiability,variab,variables,55,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:144,Modifiability,variab,variables,144,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:360,Modifiability,Extend,Extend,360,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:98,Security,validat,validate,98,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:66,Integrability,message,message,66,// We try to figure out the type from the receiver of the 'class' message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:75,Integrability,message,message,75,// We try to figure out the type from the receiver of the 'superclass'; // message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:160,Integrability,message,message,160,// Check if it really had super class.; //; // TODO: we can probably pay closer attention to cases when the class; // object can be 'nil' as the result of such message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:26,Availability,avail,available,26,"// When there is an entry available for the return symbol in DynamicTypeMap,; // the call was inlined, and the information in the DynamicTypeMap is should; // be precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:29,Integrability,message,message,29,// Try to add details to the message:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:8,Performance,perform,perform,8,"// Only perform enum range check on casts where such checks are valid. For; // all other cast kinds (where enum range checks are unnecessary or invalid),; // just return immediately. TODO: The set of casts allowed for enum range; // checking may be incomplete. Better to add a missing cast kind to enable a; // missing check than to generate false negatives and have to remove those; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp:143,Testability,stub,stub,143,"// If the cast is an enum, get its declaration.; // If the isEnumeralType() returned true, then the declaration must exist; // even if it is a stub declaration. It is up to the getDeclValuesForEnum(); // function to handle this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/EnumCastOutOfRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:424,Safety,detect,detect,424,"//=== ErrnoChecker.cpp ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines an ""errno checker"" that can detect some invalid use of the; // system-defined value 'errno'. This checker works together with the; // ErrnoModeling checker and other checkers like StdCLibraryFunctions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:25,Performance,load,load,25,"/// Indicates if a read (load) of \c errno is allowed in a non-condition part; /// of \c if, \c switch, loop and conditional statements when the errno; /// value may be undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:32,Performance,load,load,32,"// 'errno' has to be checked. A load is required for this, with no more; // information we can assume that it is checked somehow.; // After this place 'errno' is allowed to be read and written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:160,Safety,avoid,avoid,160,"// If 'errno' must be checked, it should be done as soon as possible, and; // before any other call to a system function (something in a system header).; // To avoid use of a long list of functions that may change 'errno'; // (which may be different with standard library versions) assume that any; // function can change it.; // A list of special functions can be used that are allowed here without; // generation of diagnostic. For now the only such case is 'errno' itself.; // Probably 'strerror'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:474,Availability,avail,available,474,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:697,Modifiability,variab,variable,697,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:903,Modifiability,variab,variable,903,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:570,Security,access,accessible,570,"//=== ErrnoModeling.cpp -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a checker `ErrnoModeling`, which is used to make the system; // value 'errno' available to other checkers.; // The 'errno' value is stored at a special memory region that is accessible; // through the `errno_modeling` namespace. The memory region is either the; // region of `errno` itself if it is a variable, otherwise an artifically; // created region (in the system memory space). If `errno` is defined by using; // a function which returns the address of it (this is always the case if it is; // not a variable) this function is recognized and evaluated. In this way; // `errno` becomes visible to the analysis and checkers can change its value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:23,Modifiability,variab,variable,23,"// Name of the ""errno"" variable.; // FIXME: Is there a system where it is not called ""errno"" but is a variable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:102,Modifiability,variab,variable,102,"// Name of the ""errno"" variable.; // FIXME: Is there a system where it is not called ""errno"" but is a variable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:33,Modifiability,variab,variable,33,"// The declaration of an ""errno"" variable or ""errno location"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:216,Integrability,depend,dependent,216,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:66,Modifiability,variab,variable,66,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:18,Usability,usab,usable,18,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:123,Energy Efficiency,allocate,allocated,123,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:32,Modifiability,variab,variable,32,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:111,Modifiability,variab,variable,111,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:53,Availability,avail,available,53,"// First set the errno value, the old state is still available at 'checkBind'; // or 'checkLocation' for errno value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:4,Usability,Clear,Clear,4,/// Clear state of errno (make it irrelevant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:101,Modifiability,variab,variable,101,/// Determine if a `Decl` node related to 'errno'.; /// This is true if the declaration is the errno variable or a function; /// that returns a pointer to the 'errno' value (usually the 'errno' macro is; /// defined with this function). \p D is not required to be a canonical; /// declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:39,Integrability,message,message,39,"/// Create a NoteTag that displays the message if the 'errno' memory region is; /// marked as interesting, and resets the interestingness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:80,Availability,failure,failure,80,"/// Set errno state for the common case when a standard function indicates; /// failure only by \c errno. Sets \c ErrnoCheckState to \c MustBeChecked, and; /// invalidates the errno region (clear of previous value).; /// \arg \c InvalE Expression that causes invalidation of \c errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:190,Usability,clear,clear,190,"/// Set errno state for the common case when a standard function indicates; /// failure only by \c errno. Sets \c ErrnoCheckState to \c MustBeChecked, and; /// invalidates the errno region (clear of previous value).; /// \arg \c InvalE Expression that causes invalidation of \c errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:433,Testability,test,test,433,"//=== ErrnoTesterChecker.cpp ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ErrnoTesterChecker, which is used to test functionality of the; // errno_check API.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:160,Availability,failure,failure,160,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfError() \endcode.; /// Simulate a standard library function tha returns 0 on success and 1 on; /// failure. On the success case \c errno is not allowed to be used (may be; /// undefined). On the failure case \c errno is set to a fixed value 11 and; /// is not needed to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:256,Availability,failure,failure,256,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfError() \endcode.; /// Simulate a standard library function tha returns 0 on success and 1 on; /// failure. On the success case \c errno is not allowed to be used (may be; /// undefined). On the failure case \c errno is set to a fixed value 11 and; /// is not needed to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:194,Availability,failure,failure,194,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfErrorRange(); /// \endcode. Same as \c ErrnoTesterChecker_setErrnoIfError but \c errno is; /// set to a range (to be nonzero) at the failure case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:338,Availability,error,error,338,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:444,Availability,failure,failure,444,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:508,Availability,failure,failure,508,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:747,Availability,failure,failure,747,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:868,Availability,failure,failure,868,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:54,Testability,test,tests,54,"//==- ExprInspectionChecker.cpp - Used for regression tests ------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:123,Integrability,message,message,123,"// An inlined function could conceivably also be analyzed as a top-level; // function. We ignore this case and only emit a message (TRUE or FALSE); // when we are analyzing it as an inlined function. This means that; // clang_analyzer_checkInlined(true) should always print TRUE, but; // clang_analyzer_checkInlined(false) should never actually print anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:17,Availability,error,error,17,// The non-fatal error node should be the same for all reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp:32,Modifiability,portab,portable,32,// Using a fixed address is not portable because that address will probably; // not be valid in all environments or platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FixedAddressChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:523,Deployability,release,released,523,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:580,Deployability,release,released,580,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:607,Deployability,release,released,607,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:644,Deployability,release,released,644,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1382,Deployability,Release,Released,1382," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1749,Deployability,release,released,1749," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1762,Deployability,release,released,1762," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1978,Deployability,Release,Release,1978," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2202,Deployability,release,release,2202,"acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2336,Deployability,Release,Released,2336,"RT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:2841,Deployability,release,release,2841,"e | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_create(; // uint32_t options,; // zx_handle_t* out0 __attribute__((acquire_handle(""Fuchsia""))) ,; // zx_handle_t* out1 __attribute__((acquire_handle(""Fuchsia""))));; // denotes a syscall which will acquire two handles and save them to 'out0' and; // 'out1' when succeeded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:3152,Deployability,release,released,3152,"e | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a function failed; // or succeeded. In those cases we use the state MaybeAllocated.; // Thus, the diagram above captures the intent, not implementation details.; //; // Due to the fact that the number of handle related syscalls in Fuchsia; // is large, we adopt the annotation attributes to descript syscalls'; // operations(acquire/release/use) on handles instead of hardcoding; // everything in the checker.; //; // We use following annotation attributes for handle related syscalls or; // functions:; // 1. __attribute__((acquire_handle(""Fuchsia""))) |handle will be acquired; // 2. __attribute__((release_handle(""Fuchsia""))) |handle will be released; // 3. __attribute__((use_handle(""Fuchsia""))) |handle will not transit to; // escaped state, it also needs to be open.; //; // For example, an annotated syscall:; // zx_status_t zx_channel_create(; // uint32_t options,; // zx_handle_t* out0 __attribute__((acquire_handle(""Fuchsia""))) ,; // zx_handle_t* out1 __attribute__((acquire_handle(""Fuchsia""))));; // denotes a syscall which will acquire two handles and save them to 'out0' and; // 'out1' when succeeded.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1072,Energy Efficiency,Allocate,Allocated,1072," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:1860,Energy Efficiency,Allocate,Allocated,1860," should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unowned handle |; // | (REPORT) |; // +----------------+; //; // acquire_func represents the functions or syscalls that may acquire a handle.; // release_func represents the functions or syscalls that may release a handle.; // use_func represents the functions or syscall that requires an open handle.; //; // If a tracked handle dies in ""Released"" or ""Not Tracked"" state, we assume it; // is properly used. Otherwise a bug and will be reported.; //; // Note that, the analyzer does not always know for sure if a fun",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:805,Modifiability,variab,variable,805,"//=== FuchsiaHandleChecker.cpp - Find handle leaks/double closes -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker checks if the handle of Fuchsia is properly used according to; // following rules.; // - If a handle is acquired, it should be released before execution; // ends.; // - If a handle is released, it should not be released again.; // - If a handle is released, it should not be used for other purposes; // such as I/O.; //; // In this checker, each tracked handle is associated with a state. When the; // handle variable is passed to different function calls or syscalls, its state; // changes. The state changes can be generally represented by following ASCII; // Art:; //; //; // +-------------+ +------------+; // acquire_func succeeded | | Escape | |; // +-----------------> Allocated +---------> Escaped <--+; // | | | | | |; // | +-----+------++ +------------+ |; // | | | |; // acquire_func | release_func | +--+ |; // failed | | | handle +--------+ |; // +---------+ | | | dies | | |; // | | | +----v-----+ +---------> Leaked | |; // | | | | | |(REPORT)| |; // | +----------+--+ | Released | Escape +--------+ |; // | | | | +---------------------------+; // +--> Not tracked | +----+---+-+; // | | | | As argument by value; // +----------+--+ release_func | +------+ in function call; // | | | or by reference in; // | | | use_func call; // unowned | +----v-----+ | +-----------+; // acquire_func | | Double | +-----> Use after |; // succeeded | | released | | released |; // | | (REPORT) | | (REPORT) |; // +---------------+ +----------+ +-----------+; // | Allocated |; // | Unowned | release_func; // | +---------+; // +---------------+ |; // |; // +-----v----------+; // | Release of |; // | unow",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:93,Availability,checkPoint,checkPointerEscape,93,"// Working around integer by-value escapes.; // The by-value escape would not be captured in checkPointerEscape.; // If the function was not analyzed (otherwise wasInlined should be; // true) and there is no annotation on the handle, we assume the handle; // is escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:46,Availability,error,error,46,// Keeping zombie handle symbols. In case the error symbol is dying later; // than the handle symbol we might produce spurious leak warnings (in case; // we find out later from the status code that the handle allocation failed; // in the first place).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:597,Deployability,release,release,597,"// Acquiring a handle is not always successful. In Fuchsia most functions; // return a status code that determines the status of the handle.; // When we split the path based on this status code we know that on one; // path we do have the handle and on the other path the acquire failed.; // This method helps avoiding false positive leak warnings on paths where; // the function failed.; // Moreover, when a handle is known to be zero (the invalid handle),; // we no longer can follow the symbol on the path, becaue the constant; // zero will be used instead of the symbol. We also do not need to release; // an invalid handle, so we remove the corresponding symbol from the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:309,Safety,avoid,avoiding,309,"// Acquiring a handle is not always successful. In Fuchsia most functions; // return a status code that determines the status of the handle.; // When we split the path based on this status code we know that on one; // path we do have the handle and on the other path the acquire failed.; // This method helps avoiding false positive leak warnings on paths where; // the function failed.; // Moreover, when a handle is known to be zero (the invalid handle),; // we no longer can follow the symbol on the path, becaue the constant; // zero will be used instead of the symbol. We also do not need to release; // an invalid handle, so we remove the corresponding symbol from the state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:950,Availability,avail,available,950,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:771,Performance,perform,performance,771,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:865,Performance,queue,queues,865,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:965,Performance,perform,perform,965,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:1056,Performance,perform,performed,1056,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:1074,Usability,simpl,simple,1074,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:102,Safety,detect,detecting,102,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:34,Testability,test,tests,34,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:112,Testability,test,tests,112,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:144,Testability,test,test,144,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:200,Testability,mock,mock,200,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:210,Testability,test,test,210,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:252,Testability,test,tests,252,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:294,Testability,test,tests,294,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:574,Availability,error,errors,574,"//== GenericTaintChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker defines the attack surface for generic taint propagation.; //; // The taint information produced by it might be useful to other checkers. For; // example, checkers should report errors which involve tainted data more; // aggressively, even if the involved symbols are under constrained.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:408,Security,attack,attack,408,"//== GenericTaintChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker defines the attack surface for generic taint propagation.; //; // The taint information produced by it might be useful to other checkers. For; // example, checkers should report errors which involve tainted data more; // aggressively, even if the involved symbols are under constrained.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:93,Availability,Failure,Failure,93,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:35,Security,Sanitiz,Sanitize,35,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:104,Security,Sanitiz,Sanitize,104,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:82,Modifiability,variab,variable,82,"// This region corresponds to a declaration, find out if it's a global/extern; // variable named stdin with the proper type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:60,Safety,detect,detection,60,/// ArgSet is used to describe arguments relevant for taint detection or; /// taint application. A discrete set of argument indexes and a variadic; /// argument list signified by a starting index are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:30,Security,sanitiz,sanitized,30,/// Arguments which should be sanitized on function return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:6,Integrability,message,message,6,/// A message that explains why the call is sensitive to taint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:21,Security,sanitiz,sanitizes,21,/// Make a rule that sanitizes all FilterArgs arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:22,Deployability,configurat,configuration,22,/// Used to parse the configuration file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:22,Modifiability,config,configuration,22,/// Used to parse the configuration file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:25,Deployability,configurat,configuration,25,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:25,Modifiability,config,configuration,25,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:4,Security,Validat,Validate,4,"/// Validate part of the configuration, which contains a list of argument; /// indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:13,Modifiability,config,config,13,// Takes the config and creates a CallDescription for it and associates a Rule; // with that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:81,Security,access,access,81,/// Default taint rules are initalized with the help of a CheckerContext to; /// access the names of built-in functions like memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:293,Testability,log,logic,293,"/// CallDescription currently cannot restrict matches to the global namespace; /// only, which is why multiple CallDescriptionMaps are used, as we want to; /// disambiguate global C functions from functions inside user-defined; /// namespaces.; // TODO: Remove separation to simplify matching logic once CallDescriptions; // are more expressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:275,Usability,simpl,simplify,275,"/// CallDescription currently cannot restrict matches to the global namespace; /// only, which is why multiple CallDescriptionMaps are used, as we want to; /// disambiguate global C functions from functions inside user-defined; /// namespaces.; // TODO: Remove separation to simplify matching logic once CallDescriptions; // are more expressive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:162,Usability,simpl,simpler,162,"// Sometimes the line between taint sources and propagators is blurry.; // _IO_getc is choosen to be a source, but could also be a propagator.; // This way it is simpler, as modeling it as a propagator would require; // to model the possible sources of _IO_FILE * values, which the _IO_getc; // function takes as parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:23,Deployability,configurat,configuration,23,// User-provided taint configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:23,Modifiability,config,configuration,23,// User-provided taint configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:32,Modifiability,config,config,32,"// We don't have external taint config, no parsing required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:30,Usability,simpl,simpler,30,// FIXME: this should be much simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:59,Security,access,accessible,59,// Set the marked values as tainted. The return value only accessible from; // checkPostStmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:3,Integrability,Depend,Depending,3,"// Depending on what was tainted at pre-visit, we determined a set of; // arguments which should be tainted after the function returns. These are; // stored in the state as TaintArgsOnPostVisit set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:3,Usability,Clear,Clear,3,// Clear up the taint info from the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:79,Modifiability,variab,variables,79,"/// Check for taint propagation sources.; /// A rule will make the destination variables tainted if PropSrcArgs; /// is empty (taints the destination; /// arguments unconditionally), or if any of its signified; /// args are tainted in context of the current CallEvent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:35,Modifiability,variab,variable,35,// Taint property gets lost if the variable is passed as a; // non-const pointer or reference to a function which is; // not inlined. For matching rules we want to preserve the taintedness.; // TODO: We should traverse all reachable memory regions via the; // escaping parameter. Instead of doing that we simply mark only the; // referred memory region as tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:305,Usability,simpl,simply,305,// Taint property gets lost if the variable is passed as a; // non-const pointer or reference to a function which is; // not inlined. For matching rules we want to preserve the taintedness.; // TODO: We should traverse all reachable memory regions via the; // escaping parameter. Instead of doing that we simply mark only the; // referred memory region as tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:32,Integrability,protocol,protocols,32,// Allow internal communication protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:455,Safety,avoid,avoid,455,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:436,Testability,test,testing,436,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:488,Testability,assert,assertions,488,"//==- GTestChecker.cpp - Model gtest API --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker models the behavior of un-inlined APIs from the gtest; // unit-testing library to avoid false positives when using assertions from; // that library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:2106,Availability,reliab,reliably,2106,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:728,Integrability,Message,Message,728,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:26,Testability,Assert,AssertionResult,26,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:78,Testability,test,testing,78,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:110,Testability,assert,assertions,110,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:220,Testability,assert,assertion,220,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:372,Testability,test,testing,372,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:381,Testability,Assert,AssertionResult,381,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:415,Testability,test,testing,415,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:424,Testability,Assert,AssertionResult,424,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:479,Testability,test,testing,479,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:498,Testability,Assert,AssertHelper,498,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:518,Testability,test,testing,518,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:527,Testability,Test,TestPartResult,527,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:608,Testability,test,testing,608,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:719,Testability,test,testing,719,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:753,Testability,Assert,AssertionResult,753,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:807,Testability,Assert,AssertionResult,807,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:841,Testability,Assert,AssertionResult,841,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:863,Testability,Assert,AssertionResult,863,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:901,Testability,Assert,AssertionResult,901,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1107,Testability,assert,assertion,1107," and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the miss",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1240,Testability,Assert,AssertionResult,1240," and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the miss",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1502,Testability,assert,assertion,1502,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:1746,Testability,ASSERT,ASSERT,1746,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:2289,Testability,assert,assertion,2289,"tch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (because it is constructed into a temporary and the analyzer; // does not inline these since it does not yet reliably call temporary; // destructors).; //; // This checker compensates for the missing inlining by propagating the; // _success value across the bool and copy constructors so the assertion behaves; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:63,Testability,Assert,AssertionResult,63,"// End anonymous namespace.; /// Model a call to an un-inlined AssertionResult(bool) or; /// AssertionResult(bool &, ...).; /// To do so, constrain the value of the newly-constructed instance's 'success_'; /// field to be equal to the passed-in boolean value.; ///; /// \param IsRef Whether the boolean parameter is a reference or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:93,Testability,Assert,AssertionResult,93,"// End anonymous namespace.; /// Model a call to an un-inlined AssertionResult(bool) or; /// AssertionResult(bool &, ...).; /// To do so, constrain the value of the newly-constructed instance's 'success_'; /// field to be equal to the passed-in boolean value.; ///; /// \param IsRef Whether the boolean parameter is a reference or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:35,Performance,load,load,35,"// The argument is a reference, so load from it to get the boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:34,Testability,Assert,AssertionResult,34,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:78,Testability,Assert,AssertionResult,78,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:101,Testability,Assert,AssertionResult,101,"/// Model a call to an un-inlined AssertionResult copy constructor:; ///; /// AssertionResult(const &AssertionResult other); ///; /// To do so, constrain the value of the newly-constructed instance's; /// 'success_' field to be equal to the value of the pass-in instance's; /// 'success_' field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:19,Testability,Assert,AssertionResult,19,/// Model calls to AssertionResult constructors that are not inlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:94,Testability,Assert,AssertionResult,94,// Call the appropriate modeling method based the parameters and their; // types.; // We have AssertionResult(const &AssertionResult),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:117,Testability,Assert,AssertionResult,117,// Call the appropriate modeling method based the parameters and their; // types.; // We have AssertionResult(const &AssertionResult),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:48,Integrability,depend,depending,48,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:133,Testability,Assert,AssertionResult,133,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:219,Testability,Assert,AssertionResult,219,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:330,Testability,Assert,AssertionResult,330,"// There are two possible boolean constructors, depending on which; // version of gtest is being used:; //; // v1.7 and earlier:; // AssertionResult(bool success); //; // v1.8 and greater:; // template <typename T>; // AssertionResult(const T& success,; // typename internal::EnableIf<; // !internal::ImplicitlyConvertible<T,; // AssertionResult>::value>::type*); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:11,Testability,Assert,AssertionResult,11,// We have AssertionResult(bool),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:11,Testability,Assert,AssertionResult,11,"// We have AssertionResult(bool &, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:75,Testability,Assert,AssertionResult,75,/// Returns the value stored in the 'success_' field of the passed-in; /// AssertionResult instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp:320,Modifiability,variab,variables,320,"//; // Special case for floating-point representation.; //; // If expressions on both sides of comparison operator are of type float,; // then for some comparison operators no warning shall be; // reported even if the expressions are identical from a symbolic point of; // view. Comparison between expressions, declared variables and literals; // are treated differently.; //; // != and == between float literals that have the same value should NOT warn.; // < > between float literals that have the same value SHOULD warn.; //; // != and == between the same float declaration should NOT warn.; // < > between the same float declaration SHOULD warn.; //; // != and == between eq. expressions that evaluates into float; // should NOT warn.; // < > between eq. expressions that evaluates into float; // should NOT warn.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IdenticalExprChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:472,Deployability,release,released,472,"//=== InnerPointerChecker.cpp -------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a check that marks a raw pointer to a C++ container's; // inner buffer released when the object is destroyed. This information can; // be used by MallocChecker to detect use-after-free problems.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:564,Safety,detect,detect,564,"//=== InnerPointerChecker.cpp -------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a check that marks a raw pointer to a C++ container's; // inner buffer released when the object is destroyed. This information can; // be used by MallocChecker to detect use-after-free problems.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:65,Deployability,release,released,65,/// Mark pointer symbols associated with the given memory region released; /// in the program state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:179,Deployability,release,released,179,/// Standard library functions that take a non-const `basic_string` argument by; /// reference may invalidate its inner pointers. Check for these cases and; /// mark the pointers released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:195,Deployability,release,released,195,/// Record the connection between raw pointers referring to a container; /// object's inner buffer and the object's memory region in the program state.; /// Mark potentially invalidated pointers released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:42,Security,access,access,42,"// NOTE: As of now, we only have one free access function: std::data.; // If we add more functions like this in the list, hardcoded; // argument index should be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h:419,Integrability,depend,dependencies,419,"//==--- InterCheckerAPI.h ---------------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file allows introduction of checker dependencies. It contains APIs for; // inter-checker communications.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h:104,Security,expose,exposed,104,"// FIXME: This file goes against how a checker should be implemented either in; // a single file, or be exposed in a header file. Let's try to get rid of it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InterCheckerAPI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:405,Security,access,access,405,"//===-- InvalidatedIteratorChecker.cpp ----------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for access of invalidated iterators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:13,Security,access,access,13,// Check for access of invalidated position,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp:25,Security,access,access,25,// Check for any kind of access of invalidated iterator positions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InvalidatedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp:310,Performance,perform,perform,310,"// This function tells the analyzer's engine that symbols produced by our; // checker, most notably iterator positions, are relatively small.; // A distance between items in the container should not be very large.; // By assuming that it is within around 1/8 of the address space,; // we can help the analyzer perform operations on these symbols; // without being afraid of integer overflows.; // FIXME: Should we provide it as an API, so that all checkers could use it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Iterator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:796,Availability,avail,available,796,"//===-- IteratorModeling.cpp --------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a modeling-checker for modeling STL iterator-like iterators.; //; //===----------------------------------------------------------------------===//; //; // In the code, iterator can be represented as a:; // * type-I: typedef-ed pointer. Operations over such iterator, such as; // comparisons or increments, are modeled straightforwardly by the; // analyzer.; // * type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:1436,Integrability,depend,depending,1436,"/; //; // In the code, iterator can be represented as a:; // * type-I: typedef-ed pointer. Operations over such iterator, such as; // comparisons or increments, are modeled straightforwardly by the; // analyzer.; // * type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot ha",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:1751,Modifiability,variab,variables,1751,"type-II: structure with its method bodies available. Operations over such; // iterator are inlined by the analyzer, and results of modeling; // these operations are exposing implementation details of the; // iterators, which is not necessarily helping.; // * type-III: completely opaque structure. Operations over such iterator are; // modeled conservatively, producing conjured symbols everywhere.; //; // To handle all these types in a common way we introduce a structure called; // IteratorPosition which is an abstraction of the position the iterator; // represents using symbolic expressions. The checker handles all the; // operations on this structure.; //; // Additionally, depending on the circumstances, operators of types II and III; // can be represented as:; // * type-IIa, type-IIIa: conjured structure symbols - when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot handle such SVals we need; // to take over its role. We post-check equality and non-equality comparisons; // and record that the two sides are equal if we are in the 'equal' branch; // (true-branch for `==` and false-bra",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:3204,Usability,Simpl,SimpleConstraintManager,3204,"when returned by value; // from conservatively evaluated methods such as; // `.begin()`.; // * type-IIb, type-IIIb: memory regions of iterator-typed objects, such as; // variables or temporaries, when the iterator object is; // currently treated as an lvalue.; // * type-IIc, type-IIIc: compound values of iterator-typed objects, when the; // iterator object is treated as an rvalue taken of a; // particular lvalue, eg. a copy of ""type-a"" iterator; // object, or an iterator that existed before the; // analysis has started.; //; // To handle any of these three different representations stored in an SVal we; // use setter and getters functions which separate the three cases. To store; // them we use a pointer union of symbol and memory region.; //; // The checker works the following way: We record the begin and the; // past-end iterator for all containers whenever their `.begin()` and `.end()`; // are called. Since the Constraint Manager cannot handle such SVals we need; // to take over its role. We post-check equality and non-equality comparisons; // and record that the two sides are equal if we are in the 'equal' branch; // (true-branch for `==` and false-branch for `!=`).; //; // In case of type-I or type-II iterators we get a concrete integer as a result; // of the comparison (1 or 0) but in case of type-III we only get a Symbol. In; // this latter case we record the symbol and reload it in evalAssume() and do; // the propagation there. We also handle (maybe double) negated comparisons; // which are represented in the form of (x == 0 or x != 0) where x is the; // comparison itself.; //; // Since `SimpleConstraintManager` cannot handle complex symbolic expressions; // we only use expressions of the format S, S+n or S-n for iterator positions; // where S is a conjured symbol and n is an unsigned concrete integer. When; // making an assumption e.g. `S1 + n == S2 + m` we store `S1 - S2 == m - n` as; // a constraint which we later retrieve when doing an actual comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:51,Availability,alive,alive,51,// Keep symbolic expressions of iterator positions alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:365,Testability,assert,assertion,365,"// FIXME: `std::advance()` should not create a new iterator position but; // change existing ones. However, in case of iterators implemented as; // pointers the handling of parameters in `std::advance()`-like; // functions is still incomplete which may result in cases where; // the new position is assigned to the wrong pointer. This causes; // crash if we use an assertion here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp:26,Security,access,access,26,// Check for out of range access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:656,Modifiability,variab,variables,656,"//===- IvarInvalidationChecker.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker implements annotation driven invalidation checking. If a class; // contains a method annotated with 'objc_instance_variable_invalidator',; // - (void) foo; // __attribute__((annotate(""objc_instance_variable_invalidator"")));; // all the ""ivalidatable"" instance variables of this class should be; // invalidated. We call an instance variable ivalidatable if it is an object of; // a class which contains an invalidation method. There could be multiple; // methods annotated with such annotations per class, either one can be used; // to invalidate the ivar. An ivar or property are considered to be; // invalidated if they are being assigned 'nil' or an invalidation method has; // been called on them. An invalidation method should either invalidate all; // the ivars or call another invalidation method (on self).; //; // Partial invalidor annotation allows to address cases when ivars are; // invalidated by other methods, which might or might not be called from; // the invalidation method. The checker checks that each invalidation; // method and all the partial methods cumulatively invalidate all ivars.; // __attribute__((annotate(""objc_instance_variable_invalidator_partial"")));; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:727,Modifiability,variab,variable,727,"//===- IvarInvalidationChecker.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker implements annotation driven invalidation checking. If a class; // contains a method annotated with 'objc_instance_variable_invalidator',; // - (void) foo; // __attribute__((annotate(""objc_instance_variable_invalidator"")));; // all the ""ivalidatable"" instance variables of this class should be; // invalidated. We call an instance variable ivalidatable if it is an object of; // a class which contains an invalidation method. There could be multiple; // methods annotated with such annotations per class, either one can be used; // to invalidate the ivar. An ivar or property are considered to be; // invalidated if they are being assigned 'nil' or an invalidation method has; // been called on them. An invalidation method should either invalidate all; // the ivars or call another invalidation method (on self).; //; // Partial invalidor annotation allows to address cases when ivars are; // invalidated by other methods, which might or might not be called from; // the invalidation method. The checker checks that each invalidation; // method and all the partial methods cumulatively invalidate all ivars.; // __attribute__((annotate(""objc_instance_variable_invalidator_partial"")));; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:35,Integrability,message,message,35,/// Flag is set as the result of a message send to another; /// invalidation method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:110,Deployability,update,update,110,"/// Check if the any of the methods inside the interface are annotated with; /// the invalidation annotation, update the IvarInfo accordingly.; /// \param LookForPartial is set when we are searching for partial; /// invalidators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:47,Integrability,interface,interface,47,"/// Check if the any of the methods inside the interface are annotated with; /// the invalidation annotation, update the IvarInfo accordingly.; /// \param LookForPartial is set when we are searching for partial; /// invalidators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:25,Performance,perform,performed,25,/// Filter on the checks performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:9,Performance,Cache,Cache,9,// TODO: Cache the results.; // Check all methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,Integrability,interface,interface,6,"// If interface, check all parent protocols and super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:34,Integrability,protocol,protocols,34,"// If interface, check all parent protocols and super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Integrability,protocol,protocols,13,// Visit all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,Integrability,protocol,protocol,6,"// If protocol, check all parent protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:33,Integrability,protocol,protocols,33,"// If protocol, check all parent protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:32,Integrability,interface,interfaces,32,// Check that the invalidatable interfaces with ivars/properties implement the; // invalidation methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:31,Security,Access,Accessor,31,// Construct Property/Property Accessor to Ivar maps to assist checking if an; // ivar which is backing a property has been reset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:42,Integrability,interface,interface,42,// Find all invalidation methods in this @interface declaration and parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Availability,error,error,13,// Report an error in case none of the invalidation methods are declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:58,Security,validat,validation,58,"// If there are no invalidation methods, there is no ivar validation work; // to be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,Availability,error,error,13,// Report an error in case none of the invalidation methods are implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:59,Integrability,message,message,59,"// If InvalidationMethod is present, we are processing the message send and; // should ensure we are invalidating with the appropriate method,; // otherwise, we are processing setting to 'nil'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:56,Modifiability,variab,variable,56,"// Do we assign/compare against zero? If yes, check the variable we are; // assigning to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:39,Integrability,rout,routine,39,// Check if we call the 'invalidation' routine on the ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:107,Integrability,rout,routines,107,//===----------------------------------------------------------------------===//; // Generic type checking routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:28,Availability,error,error,28,"// Okay, badness! Report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:140,Energy Efficiency,allocate,allocate,140,//===----------------------------------------------------------------------===//; // CHECK: Clang AST nodes should not have fields that can allocate; // memory.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:25,Security,hash,hash,25,// LLVMs equivalent of a hash function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:164,Integrability,interface,interfaces,164,"/// Returns true when, heuristically, the analyzer may be analyzing debugging; /// code. We use this to suppress localization diagnostics in un-localized user; /// interfaces that are only used for debugging and are therefore not user; /// facing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:27,Availability,error,error,27,/// Reports a localization error for the passed in method call and SVal,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,Availability,error,errors,33,// Don't warn about localization errors in classes and methods that; // may be debug code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:50,Integrability,protocol,protocols,50,// Go up each hierarchy of superclasses and their protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:113,Safety,avoid,avoid,113,// FIXME: We may be able to use PPCallbacks to check for empty context; // comments as part of preprocessing and avoid this re-lexing hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,Integrability,wrap,wrapped,33,"// If NSLocalizedString macro is wrapped in another macro, we need to; // unwrap the expansion until we get to the NSLocalizedStringMacro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:157,Modifiability,variab,variable,157,"// end anonymous namespace; // Checks the condition of the IfStmt and returns true if one; // of the following heuristics are met:; // 1) The conidtion is a variable with ""singular"" or ""plural"" in the name; // 2) The condition is a binary operator with 1 or 2 on the right-hand side",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:459,Energy Efficiency,allocate,allocated,459,"//==--- MacOSKeychainAPIChecker.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This checker flags misuses of KeyChainAPI. In particular, the password data; // allocated/returned by SecKeychainItemCopyContent,; // SecKeychainFindGenericPassword, SecKeychainFindInternetPassword functions has; // to be freed using a call to SecKeychainItemFreeContent.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:441,Security,password,password,441,"//==--- MacOSKeychainAPIChecker.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This checker flags misuses of KeyChainAPI. In particular, the password data; // allocated/returned by SecKeychainItemCopyContent,; // SecKeychainFindGenericPassword, SecKeychainFindInternetPassword functions has; // to be freed using a call to SecKeychainItemFreeContent.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:114,Energy Efficiency,allocate,allocated,114,/// AllocationState is a part of the checker specific state together with the; /// MemRegion corresponding to the allocated data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:28,Energy Efficiency,allocate,allocate,28,/// The functions which may allocate the data. These are tracked to reduce; /// the false alarm rate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:68,Energy Efficiency,reduce,reduce,68,/// The functions which may allocate the data. These are tracked to reduce; /// the false alarm rate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:35,Availability,error,error,35,"/// The value, which represents no error return value for allocator functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:7,Energy Efficiency,allocate,allocated,7,// The allocated region symbol tracked by the main analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:47,Energy Efficiency,allocate,allocated,47,/// ProgramState traits to store the currently allocated (and not yet freed); /// symbols. This is a map from the allocated content symbol to the; /// corresponding AllocationState.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:114,Energy Efficiency,allocate,allocated,114,/// ProgramState traits to store the currently allocated (and not yet freed); /// symbols. This is a map from the allocated content symbol to the; /// corresponding AllocationState.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:95,Availability,error,error,95,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:119,Availability,redundant,redundant,119,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:119,Safety,redund,redundant,119,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:50,Energy Efficiency,allocate,allocated,50,"// The call is deallocating a value we previously allocated, so remove it; // from the next state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:23,Energy Efficiency,allocate,allocated,23,"// If a value has been allocated, add it to the set for tracking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:78,Safety,avoid,avoid,78,"// If the argument entered as an enclosing function parameter, skip it to; // avoid false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:368,Availability,alive,alive,368,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:397,Energy Efficiency,allocate,allocated,397,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:443,Integrability,depend,depend,443,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:13,Energy Efficiency,allocate,allocated,13,// Track the allocated value in the checker state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:14,Testability,log,logic,14,// TODO: This logic is the same as in Malloc checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:42,Availability,error,error,42,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:60,Energy Efficiency,allocate,allocated,60,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:59,Availability,error,error,59,"// Match for a restricted set of patterns for cmparison of error codes.; // Note, the comparisons of type '0 == st' are transformed into SymIntExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:10,Energy Efficiency,allocate,allocated,10,// If the allocated symbol is null do not report.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:16,Availability,error,error,16,// Generate the error reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:615,Integrability,interface,interface,615,"// MacOSXAPIChecker.h - Checks proper use of various MacOS X APIs --*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines MacOSXAPIChecker, which is an assortment of checks on calls; // to various, widely used Apple APIs.; //; // FIXME: What's currently in BasicObjCFoundationChecks.cpp should be migrated; // to here, using the new Checker interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:45,Energy Efficiency,allocate,allocated,45,"// Check if the first argument is improperly allocated. If so, issue a; // warning because that's likely to be bad news.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:10,Modifiability,variab,variables,10,// Global variables are fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:115,Integrability,wrap,wraps,115,// Handle _dispatch_once. In some versions of the OS X SDK we have the case; // that dispatch_once is a macro that wraps a call to _dispatch_once.; // _dispatch_once is then a function which then calls the real dispatch_once.; // Users do not care; they just want the warning at the top-level call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:58,Modifiability,variab,variable,58,"// We filtered out globals earlier, so it must be a local variable; // or a block variable which is under UnknownSpaceRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:82,Modifiability,variab,variable,82,"// We filtered out globals earlier, so it must be a local variable; // or a block variable which is under UnknownSpaceRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:170,Modifiability,variab,variable,170,"// Presence of an IVar superregion has priority over this branch, because; // ObjC objects are on the heap even if the core doesn't realize this.; // Presence of a block variable base region has priority over this branch,; // because block variables are known to be either on stack or on heap; // (might actually move between the two, hence UnknownSpace).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:240,Modifiability,variab,variables,240,"// Presence of an IVar superregion has priority over this branch, because; // ObjC objects are on the heap even if the core doesn't realize this.; // Presence of a block variable base region has priority over this branch,; // because block variables are known to be either on stack or on heap; // (might actually move between the two, hence UnknownSpace).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:785,Availability,error,errors,785,"//=== MallocChecker.cpp - A malloc/free checker -------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the ma",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1472,Availability,error,errors,1472,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1779,Energy Efficiency,allocate,allocated,1779,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:1578,Integrability,Depend,Depends,1578,"Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a variety of memory management related checkers, such as; // leak, double free, and use-after-free.; //; // The following checkers are defined here:; //; // * MallocChecker; // Despite its name, it models all sorts of memory allocations and; // de- or reallocation, including but not limited to malloc, free,; // relloc, new, delete. It also reports on a variety of memory misuse; // errors.; // Many other checkers interact very closely with this checker, in fact,; // most are merely options to this one. Other checkers may register; // MallocChecker, but do not enable MallocChecker's reports (more details; // to follow around its field, ChecksEnabled).; // It also has a boolean ""Optimistic"" checker option, which if set to true; // will cause the checker to model user defined memory management related; // functions annotated via the attribute ownership_takes, ownership_holds; // and ownership_returns.; //; // * NewDeleteChecker; // Enables the modeling of new, new[], delete, delete[] in MallocChecker,; // and checks for related double-free and use-after-free errors.; //; // * NewDeleteLeaksChecker; // Checks for leaks related to new, new[], delete, delete[].; // Depends on NewDeleteChecker.; //; // * MismatchedDeallocatorChecker; // Enables checking whether memory is deallocated with the correspending; // allocation function in MallocChecker, such as malloc() allocated; // regions are only freed by free(), new by delete, new[] by delete[].; //; // InnerPointerChecker interacts very closely with MallocChecker, but unlike; // the above checkers, it has it's own file, hence the many InnerPointerChecker; // related headers and non-static functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:173,Energy Efficiency,allocate,allocated,173,"//===----------------------------------------------------------------------===//; // The types of allocation we're modeling. This is used to check whether a; // dynamically allocated object is deallocated with the correct function, like; // not using operator delete on an object created by malloc(), or alloca regions; // aren't ever deallocated manually.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:16,Energy Efficiency,allocate,allocated,16,// Reference to allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,// Reference to zero-allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:16,Deployability,release,released,16,// Reference to released/freed memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:56,Deployability,release,released,56,/// Check if the memory associated with this symbol was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Deployability,Update,Update,4,"/// Update the RefState to reflect the new memory allocation.; /// The optional \p RetVal parameter specifies the newly allocated pointer; /// value; if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:120,Energy Efficiency,allocate,allocated,120,"/// Update the RefState to reflect the new memory allocation.; /// The optional \p RetVal parameter specifies the newly allocated pointer; /// value; if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:94,Energy Efficiency,allocate,allocated,94,"// The symbol doesn't have to freed (e.g.: we aren't sure if, how and where; // 'fromPtr' was allocated:; // void Haha(int *ptr) {; // ptr = realloc(ptr, 67);; // // ...; // }; // ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:261,Availability,failure,failure,261,"/// Stores information about the 'fromPtr' symbol after reallocation.; ///; /// This is important because realloc may fail, and that needs special modeling.; /// Whether reallocation failed or not will not be known until later, so we'll; /// store whether upon failure 'fromPtr' will be freed, or needs to be freed; /// later, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:101,Performance,perform,perform,101,"/// Many checkers are essentially built into this one, so enabling them will; /// make MallocChecker perform additional modeling and reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:84,Energy Efficiency,allocate,allocates,84,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:216,Energy Efficiency,allocate,allocated,216,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:310,Energy Efficiency,allocate,allocated,310,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Performance,Perform,Perform,4,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:203,Energy Efficiency,allocate,allocated,203,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:473,Energy Efficiency,allocate,allocated,473,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:537,Energy Efficiency,allocate,allocates,537,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,Energy Efficiency,allocate,allocates,77,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:155,Energy Efficiency,allocate,allocated,155,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:202,Energy Efficiency,allocate,allocated,202,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:294,Energy Efficiency,allocate,allocated,294,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,Energy Efficiency,allocate,allocates,77,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:153,Energy Efficiency,allocate,allocated,153,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:200,Energy Efficiency,allocate,allocated,200,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:292,Energy Efficiency,allocate,allocated,292,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,Availability,failure,failure,859,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,Energy Efficiency,allocate,allocated,497,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:653,Energy Efficiency,allocate,allocated,653,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,Availability,failure,failure,859,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,Energy Efficiency,allocate,allocated,497,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:653,Energy Efficiency,allocate,allocated,653,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:66,Modifiability,variab,variable,66,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:20,Modifiability,refactor,refactoring,20,"// TODO: Needs some refactoring, as all other deallocation modeling; // functions are suffering from out parameters and messy code due to how; // realloc is handled.; //; /// Models memory reallocation.; ///; /// \param [in] Call The expression that reallocated memory; /// \param [in] ShouldFreeOnFail Whether if reallocation fails, the supplied; /// memory should be freed.; /// \param [in] State The \c ProgramState right before reallocation.; /// \param [in] SuffixWithN Whether the reallocation function we're modeling; /// has an '_n' suffix, such as g_realloc_n.; /// \returns The ProgramState right after reallocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:47,Energy Efficiency,allocate,allocated,47,/// Evaluates the buffer size that needs to be allocated.; ///; /// \param [in] Blocks The amount of blocks that needs to be allocated.; /// \param [in] BlockBytes The size of a block.; /// \returns The symbolic value of \p Blocks * \p BlockBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:125,Energy Efficiency,allocate,allocated,125,/// Evaluates the buffer size that needs to be allocated.; ///; /// \param [in] Blocks The amount of blocks that needs to be allocated.; /// \param [in] BlockBytes The size of a block.; /// \returns The symbolic value of \p Blocks * \p BlockBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:56,Energy Efficiency,allocate,allocated,56,"/// If in \p S \p Sym is used, check whether \p Sym was allocated as a zero; /// sized memory region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:26,Availability,checkPoint,checkPointerEscape,26,/// Implementation of the checkPointerEscape callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Testability,Test,Test,4,/// Test if value in ArgVal equals to value in macro `ZERO_SIZE_PTR`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:39,Energy Efficiency,allocate,allocated,39,"// Collect which entities point to the allocated memory, and could be; // responsible for deallocating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:445,Testability,test,test,445,"/// Syntactically checks whether the callee is a deallocating function. Since; /// we have no path-sensitive information on this call (we would need a; /// CallEvent instead of a CallExpr for that), its possible that a; /// deallocation function was called indirectly through a function pointer,; /// but we are not able to tell, so this is a best effort analysis.; /// See namespace `memory_passed_to_fn_call_free_through_fn_ptr` in; /// clang/test/Analysis/NewDeleteLeaks.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:61,Energy Efficiency,allocate,allocated,61,"// TODO: Ownership might change with an attempt to store the allocated; // memory, not only through deallocation. Check for attempted stores as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:80,Modifiability,variab,variable,80,"// Owners in the current set may be purged from the analyzer later on.; // If a variable is dead (is not referenced directly or indirectly after; // some point), it will be removed from the Store before the end of its; // actual lifetime.; // This means that if the ownership status didn't change, CurrOwners; // must be a superset of, but not necessarily equal to ExitOwners.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:20,Testability,log,logic,20,"// TODO: Factor the logic of ""what constitutes as an entity being passed; // into a function call"" out by reusing the code in; // NoStoreFuncVisitor::maybeEmitNoteForParameters, maybe by incorporating; // the printing technology in UninitializedObject's FieldChainInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:7,Energy Efficiency,allocate,allocated,7,// The allocated region symbol tracked by the main analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:52,Deployability,release,released,52,// A C++ destructor stack frame in which memory was released. Used for; // miscellaneous false positive suppression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:45,Deployability,release,released,45,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:58,Energy Efficiency,allocate,allocated,58,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Deployability,release,released,21,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:58,Deployability,release,released,58,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:107,Deployability,release,release,107,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,Energy Efficiency,allocate,allocated,44,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:48,Energy Efficiency,allocate,allocated,48,/// Did not track -> relinquished. Other state (allocated) -> relinquished.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:66,Deployability,release,released,66,"/// If the expression is not a call, and the state change is; /// released -> allocated, it must be the realloc return value; /// check. If we have to handle more cases here, it might be cleaner just; /// to track this extra bit in the state itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:78,Energy Efficiency,allocate,allocated,78,"/// If the expression is not a call, and the state change is; /// released -> allocated, it must be the realloc return value; /// check. If we have to handle more cases here, it might be cleaner just; /// to track this extra bit in the state itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:438,Testability,log,logic,438,"// 3-argument malloc(), as commonly used in {Free,Net,Open}BSD Kernels:; //; // void *malloc(unsigned long size, struct malloc_type *mtp, int flags);; //; // One of the possible flags is M_ZERO, which means 'give me back an; // allocation which is already zeroed', like calloc.; // 2-argument kmalloc(), as used in the Linux kernel:; //; // void *kmalloc(size_t size, gfp_t flags);; //; // Has the similar flag value __GFP_ZERO.; // This logic is largely cloned from O_CREAT in UnixAPIChecker, maybe some; // code could be shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,Availability,mask,maskedFlags,12,// Check if maskedFlags is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,Energy Efficiency,allocate,allocate,44,// Should we model this differently? We can allocate a fixed number of; // elements with zeros in the last one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:3,Performance,Perform,Performs,3,// Performs a 0-sized allocations check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:227,Energy Efficiency,allocate,allocated,227,"// Case of zero-size realloc. Historically 'realloc(ptr, 0)' is treated as; // 'free(ptr)' and the returned value from 'realloc(ptr, 0)' is not; // tracked. Add zero-reallocated Sym to the state to catch references; // to zero-allocated memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:29,Energy Efficiency,Allocate,Allocated,29,// Set the symbol's state to Allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:43,Performance,perform,performed,43,"// The explicit NULL case, no operation is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:83,Availability,error,error,83,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:399,Availability,fault,faults,399,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,Safety,detect,detected,12,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:139,Energy Efficiency,allocate,allocated,139,"// Regions returned by malloc() are represented by SymbolicRegion objects; // within HeapSpaceRegion. Of course, free() can work on memory allocated; // outside the current function, so UnknownSpaceRegion is also a; // possibility here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Energy Efficiency,allocate,allocated,21,"// If the pointer is allocated or escaped, but we are now trying to free it,; // check that the call to free is proper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:71,Energy Efficiency,allocate,allocated,71,"// Check if the memory location being freed is the actual location; // allocated, or an offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,Availability,alive,alive,38,// The reallocated symbol should stay alive for as long as the new symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:80,Availability,error,error,80,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Modifiability,variab,variables,21,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:224,Testability,assert,assert,224,// Leaks should not be reported if they are post-dominated by a sink:; // (1) Sinks are higher importance bugs.; // (2) NoReturnFunctionChecker uses sink nodes to represent paths ending; // with __noreturn functions such as assert() or exit(). We choose not; // to report leaks on such paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,Energy Efficiency,allocate,allocated,38,"// If we are returning a field of the allocated struct or an array element,; // the callee could still free the memory.; // TODO: This logic should be a part of generic symbol escape callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:135,Testability,log,logic,135,"// If we are returning a field of the allocated struct or an array element,; // the callee could still free the memory.; // TODO: This logic should be a part of generic symbol escape callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,Integrability,message,messages,21,// Check Objective-C messages by selector name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:78,Integrability,wrap,wrap,78,"// A bunch of other functions which either take ownership of a pointer or; // wrap the result up in a struct or object, meaning it can be freed later.; // (See RetainCountChecker.) Not all the parameters here are invalidated,; // but the Malloc checker cannot differentiate between them. The right way; // of doing this would be to implement a pointer escapes callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:98,Deployability,release,released,98,"// If we find an atomic fetch_add or fetch_sub within the destructor in which; // the pointer was released (before the release), this is likely a destructor; // of a shared pointer.; // Because we don't model atomics, and also because we don't know that the; // original reference count is positive, we should not report use-after-frees; // on objects deleted in such destructors. This can probably be improved; // through better shared pointer modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:119,Deployability,release,release,119,"// If we find an atomic fetch_add or fetch_sub within the destructor in which; // the pointer was released (before the release), this is likely a destructor; // of a shared pointer.; // Because we don't model atomics, and also because we don't know that the; // original reference count is positive, we should not report use-after-frees; // on objects deleted in such destructors. This can probably be improved; // through better shared pointer modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:207,Deployability,release,released,207,"// It is unlikely that releasing memory is delegated to a destructor; // inside a destructor of a shared pointer, because it's fairly hard; // to pass the information that the pointer indeed needs to be; // released into it. So we're only interested in the innermost; // destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:47,Testability,test,testing,47,// Is it possible to fail two reallocs WITHOUT testing in between?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:689,Energy Efficiency,allocate,allocate,689,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:396,Safety,detect,detects,396,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:431,Security,secur,security,431,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:559,Security,attack,attacker,559,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:908,Security,attack,attacker,908,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:205,Energy Efficiency,reduce,reduce,205,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:47,Modifiability,variab,variable,47,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:128,Modifiability,variab,variable,128,"/* Look for a linear combination with a single variable, and at least; one multiplication.; Reject anything that applies to the variable: an explicit cast,; conditional expression, an operation that could reduce the range; of the result, or anything too complicated :-). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:124,Availability,avail,available,124,"// We've found the right structure of malloc argument, now save; // the data so when the body of the function is completely available; // we can check for comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:176,Deployability,a/b,a/b,176,"// Check if the argument to malloc is assigned a value; // which cannot cause an overflow.; // e.g., malloc (mul * x) and,; // case 1: mul = <constant value>; // case 2: mul = a/b, where b > x",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:74,Availability,error,error,74,"/* We specifically ignore loop conditions, because they're typically; not error checks. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:316,Safety,detect,detect,316,"// OutputPossibleOverflows - We've found a possible overflow earlier,; // now check whether Body might contain a comparison which might be; // preventing the overflow.; // This doesn't do flow analysis, range analysis, or points-to analysis; it's; // just a dumb ""is there a comparison"" scan. The aim here is to; // detect the most blatent cases of overflow and educate the; // programmer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:13,Modifiability,variab,variables,13,// A list of variables referenced in possibly overflowing malloc operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:577,Availability,error,error,577,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:821,Availability,error,error,821,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:682,Deployability,release,release,682,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:420,Integrability,Interface,Interface,420,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:558,Integrability,rout,routine,558,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:877,Integrability,message,message,877,"//== MIGChecker.cpp - MIG calling convention checker ------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines MIGChecker, a Mach Interface Generator calling convention; // checker. Namely, in MIG callback implementation the following rules apply:; // - When a server routine returns an error code that represents success, it; // must take ownership of resources passed to it (and eventually release; // them).; // - Additionally, when returning success, all out-parameters must be; // initialized.; // - When it returns any other error code, it must not take ownership,; // because the message and its out-of-line parameters will be destroyed; // by the client that called the function.; // For now we only check the last rule, as its violations lead to dangerous; // use-after-free exploits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:267,Availability,error,error,267,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:181,Integrability,rout,routine,181,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:309,Integrability,rout,routine,309,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:97,Performance,perform,performed,97,// A set of parameters for which the check is suppressed because; // reference counting is being performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,Integrability,rout,routine,44,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:310,Integrability,rout,routine,310,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:186,Modifiability,variab,variables,186,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:264,Performance,load,loaded,264,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:134,Availability,error,error,134,"// Even though there's a Sema warning when the return type of an annotated; // function is not a kern_return_t, this warning isn't an error, so we need; // an extra check here.; // FIXME: AnyCall doesn't support blocks yet, so they remain unchecked; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:177,Deployability,release,releases,177,"// If the code is doing reference counting over the parameter,; // it opens up an opportunity for safely calling a destructor function.; // TODO: We should still check for over-releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:98,Safety,safe,safely,98,"// If the code is doing reference counting over the parameter,; // it opens up an opportunity for safely calling a destructor function.; // TODO: We should still check for over-releases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,Availability,error,error,44,"// If none of the above, it's definitely an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:140,Integrability,rout,routine,140,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:390,Integrability,rout,routine,390,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:209,Safety,safe,safe,209,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:124,Availability,error,error,124,"// We know that the function is non-void, but what if the return statement; // is not there in the code? It's not a compile error, we should not crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:329,Safety,safe,safely,329,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:121,Security,access,access,121,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp:396,Testability,test,tests,396,"// MmapWriteExecChecker.cpp - Check for the prot argument -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker tests the 3rd argument of mmap's calls to check if; // it is writable and executable in the same time. It's somehow; // an optional checker since for example in JIT libraries it is pretty common.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MmapWriteExecChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h:455,Integrability,depend,dependent,455,"//=== Move.h - Tracking moved-from objects. ------------------------*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines inter-checker API for the use-after-move checker. It allows; // dependent checkers to figure out if an object is in a moved-from state.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Move.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:30,Safety,unsafe,unsafe,30,// Warn only about known move-unsafe classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:19,Modifiability,variab,variable,19,// Is this a local variable or a local rvalue reference?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:38,Safety,safe,safe,38,"// Not all of these are entirely move-safe, but they do provide *some*; // guarantees, and it means that somebody is using them after move; // in a valid manner.; // TODO: We can still try to identify *unsafe* use after move,; // like we did with smart pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:202,Safety,unsafe,unsafe,202,"// Not all of these are entirely move-safe, but they do provide *some*; // guarantees, and it means that somebody is using them after move; // in a valid manner.; // TODO: We can still try to identify *unsafe* use after move,; // like we did with smart pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:556,Integrability,contract,contracts,556,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:64,Modifiability,variab,variables,64,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:168,Modifiability,variab,variables,168,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:675,Performance,perform,perform,675,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:450,Safety,predict,predict,450,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:37,Usability,user-friendly,user-friendly,37,// Classifies the object and dumps a user-friendly description string to; // the stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:16,Availability,error,error,16,// Creating the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:22,Integrability,message,message,22,// Creating the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:19,Availability,error,error,19,// Don't report an error inside a move related operation.; // We assume that the programmer knows what she does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:9,Modifiability,variab,variables,9,"// Local variables and local rvalue references are classified as ""Local"".; // For the purposes of this checker, we classify move-safe STL types; // as not-""STL"" types, because that's how the checker treats them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:129,Safety,safe,safe,129,"// Local variables and local rvalue references are classified as ""Local"".; // For the purposes of this checker, we classify move-safe STL types; // as not-""STL"" types, because that's how the checker treats them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:36,Performance,cache,cache,36,// namespace; /// Lazily initialize cache for required identifier information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:19,Modifiability,variab,variable,19,// Assume that the variable is non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:13,Performance,load,loaded,13,/// \param V loaded lvalue.; /// \return whether @c val is a string-like const global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:50,Performance,perform,perform,50,"// If the value is unknown or undefined, we can't perform this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:15,Availability,error,error,15,// Generate an error node. Check for a null node in case; // we cache out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:64,Performance,cache,cache,64,// Generate an error node. Check for a null node in case; // we cache out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:61,Availability,error,error,61,// Always return. Either we cached out or we just emitted an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,Performance,cache,cached,28,// Always return. Either we cached out or we just emitted an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:91,Deployability,update,updated,91,// If we reach here all of the arguments passed the nonnull check.; // If 'state' has been updated generated a new node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:440,Availability,error,error,440,"/// We want to trust developer annotations and consider all 'nonnull' parameters; /// as non-null indeed. Each marked parameter will get a corresponding; /// constraint.; ///; /// This approach will not only help us to get rid of some false positives, but; /// remove duplicates and shorten warning traces as well.; ///; /// \code; /// void foo(int *x) [[gnu::nonnull]] {; /// // . . .; /// *x = 42; // we don't want to consider this as an error...; /// // . . .; /// }; ///; /// foo(nullptr); // ...and report here instead; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:109,Integrability,interface,interfaces,109,// AnyCall helps us here to avoid checking for FunctionDecl and ObjCMethodDecl; // separately and aggregates interfaces of these classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,Safety,avoid,avoid,28,// AnyCall helps us here to avoid checking for FunctionDecl and ObjCMethodDecl; // separately and aggregates interfaces of these classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:149,Performance,cache,cache,149,"// HACK: Some functions are not marked noreturn, and don't return.; // Here are a few hardwired ones. If this takes too long, we can; // potentially cache these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:25,Integrability,wrap,wrapper,25,// FIXME: This is just a wrapper around throwing an exception.; // Eventually inter-procedural analysis should handle this easily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:44,Integrability,message,messages,44,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:339,Integrability,message,messages,339,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:390,Safety,safe,safe,390,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:35,Integrability,message,messages,35,"// If we got here, it's one of the messages we care about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:739,Integrability,interface,interface,739,"//=- NSAutoreleasePoolChecker.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a NSAutoreleasePoolChecker, a small checker that warns; // about subpar uses of NSAutoreleasePool. Note that while the check itself; // (in its current form) could be written as a flow-insensitive check, in; // can be potentially enhanced in the future with flow-sensitive information.; // It is also a good example of the CheckerVisitor interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:631,Modifiability,enhance,enhanced,631,"//=- NSAutoreleasePoolChecker.cpp --------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a NSAutoreleasePoolChecker, a small checker that warns; // about subpar uses of NSAutoreleasePool. Note that while the check itself; // (in its current form) could be written as a flow-insensitive check, in; // can be potentially enhanced in the future with flow-sensitive information.; // It is also a good example of the CheckerVisitor interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:12,Deployability,release,release,12,// Sending 'release' message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:21,Integrability,message,message,21,// Sending 'release' message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:486,Integrability,interface,interface,486,"//=- NSErrorChecker.cpp - Coding conventions for uses of NSError -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckNSError, a flow-insensitive check; // that determines if an Objective-C class interface correctly returns; // a non-void return type.; //; // File under feature request PR 2600.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:35,Integrability,wrap,wraps,35,// We tag the symbol that the SVal wraps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp:13,Performance,load,loading,13,"// If we are loading from NSError**/CFErrorRef* parameter, mark the resulting; // SVal so that we can later check it when handling the; // ImplicitNullDerefEvent event.; // FIXME: Cumbersome! Maybe add hook at construction of SVals at start of; // function ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSErrorChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:1128,Testability,assert,asserts,1128,"//===-- NullabilityChecker.cpp - Nullability checker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker tries to find nullability violations. There are several kinds of; // possible violations:; // * Null pointer is passed to a pointer which has a _Nonnull type.; // * Null pointer is returned from a function which has a _Nonnull return type.; // * Nullable pointer is passed to a pointer which has a _Nonnull type.; // * Nullable pointer is returned from a function which has a _Nonnull return; // type.; // * Nullable pointer is dereferenced.; //; // This checker propagates the nullability information of the pointers and looks; // for the patterns that are described above. Explicit casts are trusted and are; // considered a way to suppress false positives for this checker. The other way; // to suppress warnings would be to add asserts or guarding if statements to the; // code. In addition to the nullability propagation this checker also uses some; // heuristics to suppress potential false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:60,Integrability,message,message,60,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:255,Integrability,depend,depending,255,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:352,Safety,avoid,avoid,352,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:39,Availability,Error,ErrorMessages,39,// These enums are used as an index to ErrorMessages array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:111,Availability,error,errors,111,// When set to false no nullability information will be tracked in; // NullabilityMap. It is possible to catch errors like passing a null pointer; // to a callee that expects nonnull argument without the information that is; // stored in the NullabilityMap. This is an optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:269,Performance,optimiz,optimization,269,// When set to false no nullability information will be tracked in; // NullabilityMap. It is possible to catch errors like passing a null pointer; // to a callee that expects nonnull argument without the information that is; // stored in the NullabilityMap. This is an optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:15,Integrability,wrap,wraps,15,"/// If an SVal wraps a region that should be tracked, it will return a pointer; /// to the wrapped region. Otherwise it will return a nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:91,Integrability,wrap,wrapped,91,"/// If an SVal wraps a region that should be tracked, it will return a pointer; /// to the wrapped region. Otherwise it will return a nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:73,Deployability,configurat,configuration,73,/// Returns true if the call is diagnosable in the current analyzer; /// configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:73,Modifiability,config,configuration,73,/// Returns true if the call is diagnosable in the current analyzer; /// configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:83,Integrability,message,message,83,"// Source is the expression which determined the nullability. For example in a; // message like [nullable nonnull_returning] has nullable nullability, because; // the receiver is nullable. Here the receiver will be the source of the; // nullability. This is useful information when the diagnostics are generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:51,Security,access,accesses,51,"// For the purpose of tracking historical property accesses, the key for lookup; // is an object pointer (could be an instance or a class) paired with the unique; // identifier for the property being invoked on that object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:70,Security,access,access,70,// Metadata associated with the return value from a recorded property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:222,Safety,detect,detected,222,"// We say ""the nullability type invariant is violated"" when a location with a; // non-null type contains NULL or a function with a non-null return type returns; // NULL. Violations of the nullability type invariant can be detected either; // directly (for example, when NULL is passed as an argument to a nonnull; // parameter) or indirectly (for example, when, inside a function, the; // programmer defensively checks whether a nonnull parameter contains NULL and; // finds that it does).; //; // As a matter of policy, the nullability checker typically warns on direct; // violations of the nullability invariant (although it uses various; // heuristics to suppress warnings in some cases) but will not warn if the; // invariant has already been violated along the path (either directly or; // indirectly). As a practical matter, this prevents the analyzer from; // (1) warning on defensive code paths where a nullability precondition is; // determined to have been violated, (2) warning additional times after an; // initial direct violation has been discovered, and (3) warning after a direct; // violation that has been implicitly or explicitly suppressed (for; // example, with a cast of NULL to _Nonnull). In essence, once an invariant; // violation is detected on a path, this checker will be essentially turned off; // for the rest of the analysis; //; // The analyzer takes this approach (rather than generating a sink node) to; // ensure coverage of defensive paths, which may be important for backwards; // compatibility in codebases that were developed without nullability in mind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:1260,Safety,detect,detected,1260,"// We say ""the nullability type invariant is violated"" when a location with a; // non-null type contains NULL or a function with a non-null return type returns; // NULL. Violations of the nullability type invariant can be detected either; // directly (for example, when NULL is passed as an argument to a nonnull; // parameter) or indirectly (for example, when, inside a function, the; // programmer defensively checks whether a nonnull parameter contains NULL and; // finds that it does).; //; // As a matter of policy, the nullability checker typically warns on direct; // violations of the nullability invariant (although it uses various; // heuristics to suppress warnings in some cases) but will not warn if the; // invariant has already been violated along the path (either directly or; // indirectly). As a practical matter, this prevents the analyzer from; // (1) warning on defensive code paths where a nullability precondition is; // determined to have been violated, (2) warning additional times after an; // initial direct violation has been discovered, and (3) warning after a direct; // violation that has been implicitly or explicitly suppressed (for; // example, with a cast of NULL to _Nonnull). In essence, once an invariant; // violation is detected on a path, this checker will be essentially turned off; // for the rest of the analysis; //; // The analyzer takes this approach (rather than generating a sink node) to; // ensure coverage of defensive paths, which may be important for backwards; // compatibility in codebases that were developed without nullability in mind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:390,Integrability,depend,depending,390,"// If the value was constrained to null *after* it was passed through that; // location, it could not have been a concrete pointer *when* it was passed.; // In that case we would have handled the situation when the value was; // bound to that location, by emitting (or not emitting) a report.; // Therefore we are only interested in symbolic regions that can be either; // null or non-null depending on the value of their respective symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:94,Security,access,accesses,94,"// When an object goes out of scope, we can free the history associated; // with any property accesses on that object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:176,Availability,error,error,176,"// When one of the nonnull arguments are constrained to be null, nullability; // preconditions are violated. It is not enough to check this only when we; // actually report an error, because at that time interesting symbols might be; // reaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:19,Availability,error,errors,19,"// Do not suppress errors on defensive code paths, because dereferencing; // a nullable pointer is always an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:109,Availability,error,error,109,"// Do not suppress errors on defensive code paths, because dereferencing; // a nullable pointer is always an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:21,Performance,load,load,21,"// Whenever we see a load from a typed memory region that's been annotated as; // 'nonnull', we want to trust the user on that and assume that it is is indeed; // non-null.; //; // We do so even if the value is known to have been assigned to null.; // The user should be warned on assigning the null value to a non-null pointer; // as opposed to warning on the later dereference of this pointer.; //; // \code; // int * _Nonnull var = 0; // we want to warn the user here...; // // . . .; // *var = 42; // ...and not here; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:29,Performance,load,loads,29,// We should care only about loads.; // The main idea is to add a constraint whenever we're loading a value from; // an annotated pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:92,Performance,load,loading,92,// We should care only about loads.; // The main idea is to add a constraint whenever we're loading a value from; // an annotated pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:33,Safety,avoid,avoid,33,// HACK: This is a big hammer to avoid warning when there are defensive; // nil checks in -init and -copy methods. We should add more sophisticated; // logic here to suppress on common defensive idioms but still; // warn when there is a likely problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:152,Testability,log,logic,152,// HACK: This is a big hammer to avoid warning when there are defensive; // nil checks in -init and -copy methods. We should add more sophisticated; // logic here to suppress on common defensive idioms but still; // warn when there is a likely problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:8,Integrability,Message,Messages,8,// ObjC Messages handles in a different callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:34,Security,access,access,34,// The return value of a property access is typically a temporary value which; // will not be tracked in a persistent manner by the analyzer. We use; // evalAssume() in order to immediately record constraints on those temporaries; // at the time they are imposed (e.g. by a nil-check conditional).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:9,Performance,optimiz,optimization,9,// Space optimization: no point in tracking constrained-null cases,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:49,Integrability,message,message,49,"/// Calculate the nullability of the result of a message expr based on the; /// nullability of the receiver, the nullability of the return value, and the; /// constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:15,Energy Efficiency,reduce,reduce,15,"// In order to reduce the noise in the diagnostics generated by this checker,; // some framework and programming style based heuristics are used. These; // heuristics are for Cocoa APIs which have NS prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:67,Availability,avail,available,67,"// Developers rely on dynamic invariants such as an item should be available; // in a collection, or a collection is not empty often. Those invariants can; // not be inferred by any static analysis tool. To not to bother the users; // with too many false positives, every item retrieval function should be; // ignored for collections. The instance methods of dictionaries in Cocoa; // are either item retrieval related or not interesting nullability wise.; // Using this fact, to keep the code easier to read just ignore the return; // value of every instance method of dictionaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:172,Energy Efficiency,reduce,reduced,172,// Encoding related methods of string should not fail when lossless; // encodings are used. Using lossless encodings is so frequent that ignoring; // this class of methods reduced the emitted diagnostics by about 30% on; // some projects (and all of that was false positives).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:450,Energy Efficiency,reduce,reduce,450,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:572,Security,access,access,572,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:691,Security,access,access,691,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:26,Security,access,access,26,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:142,Security,access,accesses,142,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:227,Security,access,access,227,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:363,Security,access,access,363,"// If a previous property access was constrained as nonnull, we hold; // on to that constraint (effectively inferring that all subsequent; // accesses on that code path can be inferred as nonnull). If the; // previous property access was *not* constrained as nonnull, then; // let's throw it away in favor of keeping the SVal associated with; // this more recent access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:26,Performance,perform,performing,26,"/// For a given statement performing a bind, attempt to syntactically; /// match the expression resulting in the bound value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:55,Modifiability,variab,variable,55,/// Returns true if \param S is a DeclStmt for a local variable that; /// ObjC automated reference counting initialized with zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:125,Modifiability,variab,variable,125,// We suppress diagnostics for ARC zero-initialized _Nonnull locals. This; // prevents false positives when a _Nonnull local variable cannot be; // initialized with an initialization expression:; // NSString * _Nonnull s; // no-warning; // @autoreleasepool {; // s = ...; // }; //; // FIXME: We should treat implicitly zero-initialized _Nonnull locals as; // uninitialized in Sema's UninitializedValues analysis to warn when a use of; // the zero-initialized definition will unexpectedly yield nil.; // Locals are only zero-initialized when automated reference counting; // is turned on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:146,Performance,optimiz,optimization,146,// The checks are likely to be turned on by default and it is possible to do; // them without tracking any nullability related information. As an optimization; // no nullability information will be tracked when only these two checks are; // enables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:1317,Modifiability,config,config,1317,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:1124,Safety,detect,detection,1124,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:734,Usability,clear,clearly,734,"//===- NumberObjectConversionChecker.cpp -------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines NumberObjectConversionChecker, which checks for a; // particular common mistake when dealing with numbers represented as objects; // passed around by pointers. Namely, the language allows to reinterpret the; // pointer as a number directly, often without throwing any warnings,; // but in most cases the result of such conversion is clearly unexpected,; // as pointer value, rather than number value represented by the pointee object,; // becomes the result of such operation.; //; // Currently the checker supports the Objective-C NSNumber class,; // and the OSBoolean class found in macOS low-level code; the latter; // can only hold boolean values.; //; // This checker has an option ""Pedantic"" (boolean), which enables detection of; // more conversion patterns (which are most likely more harmless, and therefore; // are more likely to produce false positives) - disabled by default,; // enabled with `-analyzer-config osx.NumberObjectConversion:Pedantic=true'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:98,Safety,avoid,avoid,98,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:244,Testability,log,logic,244,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:56,Usability,clear,clearly,56,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:13,Integrability,message,message,13,// A generic message if we're not sure what API should be called.; // FIXME: Pattern-match the integer type to make a better guess?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,Availability,error,error,45,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,Integrability,message,message,51,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:85,Safety,avoid,avoid,85,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:49,Integrability,message,message,49,"// We bind ""check_if_null"" to modify the warning message; // in case it was intended to compare a pointer to 0 with a relatively-ok; // construct ""x == 0"" or ""x != 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:52,Integrability,synchroniz,synchronized,52,"//== ObjCAtSyncChecker.cpp - nil mutex checker for @synchronized -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCAtSyncChecker, a builtin check that checks for null pointers; // used as mutexes for @synchronized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:486,Integrability,synchroniz,synchronized,486,"//== ObjCAtSyncChecker.cpp - nil mutex checker for @synchronized -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCAtSyncChecker, a builtin check that checks for null pointers; // used as mutexes for @synchronized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:15,Availability,error,error,15,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:82,Integrability,synchroniz,synchronization,82,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:570,Availability,error,error,570,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:656,Availability,error,error,656,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:828,Availability,error,error,828,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:839,Availability,error,error,839,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:851,Availability,error,error,851,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:868,Availability,error,errorWithDomain,868,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:982,Availability,error,error,982,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:1080,Availability,error,error,1080,"//===- ObjCAutoreleaseWriteChecker.cpp ----------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines ObjCAutoreleaseWriteChecker which warns against writes; // into autoreleased out parameters which cause crashes.; // An example of a problematic write is a write to @c error in the example; // below:; //; // - (BOOL) mymethod:(NSError *__autoreleasing *)error list:(NSArray*) list {; // [list enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {; // NSString *myString = obj;; // if ([myString isEqualToString:@""error""] && error); // *error = [NSError errorWithDomain:@""MyDomain"" code:-1];; // }];; // return false;; // }; //; // Such code will crash on read from `*error` due to the autorelease pool; // in `enumerateObjectsUsingBlock` implementation freeing the error object; // on exit from the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:39,Availability,avail,available,39,"// Prefer to warn on write, but if not available, warn on capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp:86,Safety,avoid,avoid,86,"// If the type is a pointer to an array, check the size of the array; // elements. To avoid false positives coming from assumption that the; // values x and &x are equal when x is an array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp:27,Usability,simpl,simple,27,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp:383,Performance,Perform,Performs,383,"//== ObjCContainersChecker.cpp - Path sensitive checker for CFArray *- C++ -*=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Performs path sensitive checks of Core Foundation static containers like; // CFArray.; // 1) Check for buffer overflows:; // In CFArrayGetArrayAtIndex( myArray, index), if the index is outside the; // index space of theArray (0 to N-1 inclusive (where N is the count of; // theArray), the behavior is undefined.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp:19,Security,access,access,19,// Check the array access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:391,Availability,recover,recovered,391,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:442,Availability,recover,recovered,442,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:500,Performance,load,loadView,500,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:685,Performance,load,loadView,685,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:767,Performance,load,loadView,767,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:391,Safety,recover,recovered,391,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:442,Safety,recover,recovered,442,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1312,Availability,down,down,1312,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1286,Integrability,message,message,1286,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:783,Modifiability,variab,variable,783,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1155,Modifiability,variab,variables,1155,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:804,Performance,perform,perform,804,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:1339,Testability,log,logging,1339,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:35,Integrability,wrap,wraps,35,// We tag the symbol that the SVal wraps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:23,Integrability,message,message,23,"// When encountering a message that does initialization (init rule),; // tag the return value so that we know later on that if self has this value; // then it is properly initialized.; // FIXME: A callback should disable checkers at the start of functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:82,Availability,down,down,82,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:52,Integrability,message,message,52,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:109,Testability,log,logging,109,"// We don't check for an invalid 'self' in an obj-c message expression to cut; // down false positives where logging functions get information from self; // (like its class) or doing ""invalidation"" on self when the initialization; // fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:183,Safety,avoid,avoid,183,"// When a call receives a reference to 'self', [Pre/Post]Call pass; // the SelfFlags from the object 'self' points to before the call to the new; // object after the call. This is to avoid invalidation of 'self' by logging; // functions.; // Another common pattern in classes with multiple initializers is to put the; // subclass's common initialization bits into a static function that receives; // the value of 'self', e.g:; // @code; // if (!(self = [super init])); // return nil;; // if (!(self = _commonInit(self))); // return nil;; // @endcode; // Until we can use inter-procedural analysis, in such a call, transfer the; // SelfFlags to the result of the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:215,Testability,log,logging,215,"// When a call receives a reference to 'self', [Pre/Post]Call pass; // the SelfFlags from the object 'self' points to before the call to the new; // object after the call. This is to avoid invalidation of 'self' by logging; // functions.; // Another common pattern in classes with multiple initializers is to put the; // subclass's common initialization bits into a static function that receives; // the value of 'self', e.g:; // @code; // if (!(self = [super init])); // return nil;; // if (!(self = _commonInit(self))); // return nil;; // @endcode; // Until we can use inter-procedural analysis, in such a call, transfer the; // SelfFlags to the result of the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:133,Testability,log,log,133,"// If the address of 'self' is being passed to the call, assume that the; // 'self' after the call will have the same flags.; // EX: log(&self)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:176,Performance,perform,performMoreInitialization,176,"// If 'self' is passed to the call by value, assume that the function; // returns 'self'. So assign the flags, which were set on 'self' to the; // return value.; // EX: self = performMoreInitialization(self)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:23,Performance,load,load,23,// Tag the result of a load from 'self' so that we can easily know that the; // value is the object that 'self' points to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:57,Modifiability,variab,variable,57,"// Allow assignment of anything to self. Self is a local variable in the; // initializer, so it is legal to assign anything to it, like results of; // static functions/method calls. After self is assigned something we cannot; // reason about, stop enforcing the rules.; // (Only continue checking if the assigned value should be treated as self.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:53,Safety,avoid,avoid,53,// We add this transition in checkPostObjCMessage to avoid warning when; // we inline a call to [super dealloc] where the inlined call itself; // calls [super dealloc].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:101,Availability,error,error,101,// Climb the super regions to find the base symbol while recording; // the second-to-last region for error reporting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:92,Availability,error,error,92,"/// Report a use-after-dealloc on Sym. If not empty,; /// Desc will be used to describe the error; otherwise,; /// a default warning will be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:476,Integrability,interface,interface,476,"//==- ObjCUnusedIVarsChecker.cpp - Check for unused ivars --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCUnusedIvars, a checker that; // analyzes an Objective-C class's interface/implementation to determine if it; // has any ivars that are never accessed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:553,Security,access,accessed,553,"//==- ObjCUnusedIVarsChecker.cpp - Check for unused ivars --------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a CheckObjCUnusedIvars, a checker that; // analyzes an Objective-C class's interface/implementation to determine if it; // has any ivars that are never accessed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:36,Modifiability,variab,variable,36,// Blocks can reference an instance variable of a class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:24,Security,access,accesses,24,// Scan the methods for accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp:24,Energy Efficiency,allocate,allocates,24,"// 'allocClassWithName' allocates an object with the given type.; // The type is actually provided as a string argument (type's name).; // This makes the following pattern possible:; //; // Foo *object = (Foo *)allocClassWithName(""Foo"");; //; // While OSRequiredCast can be used here, it is still not a useful warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/OSObjectCStyleCast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:15,Usability,simpl,simplest,15,"// This is the simplest correct case: a class with no fields and one base; // class. Other cases are more complicated because of how the base classes; // & fields might interact, so we don't bother dealing with them.; // TODO: Support other combinations of base classes and fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:27,Performance,optimiz,optimize,27,// Not going to attempt to optimize unions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:3,Modifiability,Variab,Variable,3,// Variable length arrays are tricky too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:85,Safety,avoid,avoid,85,// This checker try not to assume anything about placement and overloaded; // new to avoid false positives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:132,Modifiability,Polymorphi,Polymorphic,132,"/// Checks whether a region is the part of an array.; /// In case there is a derived to base cast above the array element, the; /// Polymorphic output value is set to true. AKind output value is set to the; /// allocation kind of the inspected region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:112,Safety,avoid,avoid,112,"// When the region is symbolic and we do not have any information about it,; // assume that this is an array to avoid false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:38,Energy Efficiency,allocate,allocate,38,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:141,Energy Efficiency,allocate,allocates,141,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:57,Safety,avoid,avoid,57,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp:23,Usability,simpl,simply,23,"// FIXME: Currently we simply check if std::sort is used with pointer-like; // elements. This approach can have a big false positive rate. Using std::sort,; // std::unique and then erase is common technique for deduplicating a container; // (which in some cases might even be quicker than using, let's say std::set).; // In case a container contains arbitrary memory addresses (e.g. multiple; // things give different stuff but might give the same thing multiple times); // which we don't want to do things with more than once, we might use; // sort-unique-erase and the sort call will emit a report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerSortingChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:430,Usability,simpl,simple,430,"//===--- PthreadLockChecker.cpp - Check for locking problems ---*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines:; // * PthreadLockChecker, a simple lock -> unlock checker.; // Which also checks for XNU locks, which behave similarly enough to share; // code.; // * FuchsiaLocksChecker, which is also rather similar.; // * C11LockChecker which also closely follows Pthread semantics.; //; // TODO: Path notes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Deployability,Release,Release,3,// Release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:28,Deployability,release,released,28,// Record that the lock was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:60,Performance,perform,performed,60,"// Once the return value symbol dies, no more checks can be performed; // against it. See if the return value was checked before this point.; // This would remove the symbol from the map as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating mutex state when a known supported function is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:101,Energy Efficiency,efficient,efficiently,101,"// TODO: We need to invalidate the lock stack as well. This is tricky; // to implement correctly and efficiently though, because the effects; // of mutex escapes on lock order may be fairly varied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp:66,Modifiability,refactor,refactored,66,// FIXME: All of this out-of-bounds checking should eventually be refactored; // into a common place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnPointerRangeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp:191,Testability,test,test,191,"// ""return;"" is modeled to evaluate to an UndefinedVal. Allow UndefinedVal; // to be returned in functions returning void to support this pattern:; // void foo() {; // return;; // }; // void test() {; // return foo();; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp:88,Availability,avail,available,88,"// Not all blocks have explicitly-specified return types; if the return type; // is not available, but the return value expression has 'void' type, assume; // Sema already checked it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp:41,Availability,Error,Error,41,// These are known in the LLVM project: 'Error()',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp:4,Availability,error,error,4,// 'error()',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp:400,Safety,detect,detecting,400,"//=- RunLoopAutoreleaseLeakChecker.cpp --------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //; //===----------------------------------------------------------------------===//; //; // A checker for detecting leaks resulting from allocating temporary; // autoreleased objects before starting the main run loop.; //; // Checks for two antipatterns:; // 1. ObjCMessageExpr followed by [[NSRunLoop mainRunLoop] run] in the same; // autorelease pool.; // 2. ObjCMessageExpr followed by [[NSRunLoop mainRunLoop] run] in no; // autorelease pool.; //; // Any temporary objects autoreleased in code called in those expressions; // will not be deallocated until the program exits, and are effectively leaks.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp:40,Integrability,message,message-sent,40,// Launch of run loop occurs before the message-sent expression is seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:506,Security,access,accessed,506,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:526,Security,Access,Accessing,526,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp:8,Usability,Simpl,SimpleStreamChecker,8,"//===-- SimpleStreamChecker.cpp -----------------------------------------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for proper use of fopen/fclose APIs.; // - If a file has been closed with fclose, it should not be accessed again.; // Accessing a closed file results in undefined behavior.; // - If a file was opened with fopen, it must be closed with fclose before; // the execution ends. Failing to do so results in a resource leak.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SimpleStreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h:455,Integrability,depend,dependent,455,"//=== SmartPtr.h - Tracking smart pointer state. -------------------*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines inter-checker API for the smart pointer modeling. It allows; // dependent checkers to figure out if an smart pointer is null or not.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,Safety,avoid,avoid,44,// Helper method to pretty print region and avoid extra spacing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:9,Deployability,Update,Update,9,"// TODO: Update CallDescription to support anonymous calls?; // TODO: Handle other methods, such as .get() or .release().; // But once we do, we'd need a visitor to explain null dereferences; // that are found via such modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:111,Deployability,release,release,111,"// TODO: Update CallDescription to support anonymous calls?; // TODO: Handle other methods, such as .get() or .release().; // But once we do, we'd need a visitor to explain null dereferences; // that are found via such modeling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:269,Deployability,update,updateObjectsUnderConstruction,269,"// TODO: ExprEngine should do this for us.; // For a bit more context:; // 1) Why do we need this? Since we are modelling a ""function""; // that returns a constructed object we need to store this information in; // the program state.; //; // 2) Why does this work?; // `updateObjectsUnderConstruction` does exactly as it sounds.; //; // 3) How should it look like when moved to the Engine?; // It would be nice if we can just; // pretend we don't need to know about this - ie, completely automatic work.; // However, realistically speaking, I think we would need to ""signal"" the; // ExprEngine evalCall handler that we are constructing an object with this; // function call (constructors obviously construct, hence can be; // automatically deduced).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:109,Safety,safe,safe,109,// We don't leave a note here since it is guaranteed the; // unique_ptr from this call is non-null (hence is safe to de-reference).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,Safety,avoid,avoid,44,"// TODO: Model this case as well. At least, avoid invalidation of; // globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:27,Availability,alive,alive,27,// Marking tracked symbols alive,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:40,Availability,avail,available,40,// In case of inner pointer SVal is not available we create; // conjureSymbolVal for inner pointer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:353,Modifiability,variab,variable,353,"// There is a not-too-uncommon idiom; // where a block passed to dispatch_async captures a semaphore; // and then the thread (which called dispatch_async) is blocked on waiting; // for the completion of the execution of the block; // via dispatch_semaphore_wait. To avoid false-positives (for now); // we ignore all the blocks which have captured; // a variable of the type ""dispatch_semaphore_t"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:266,Safety,avoid,avoid,266,"// There is a not-too-uncommon idiom; // where a block passed to dispatch_async captures a semaphore; // and then the thread (which called dispatch_async) is blocked on waiting; // for the completion of the execution of the block; // via dispatch_semaphore_wait. To avoid false-positives (for now); // we ignore all the blocks which have captured; // a variable of the type ""dispatch_semaphore_t"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:120,Integrability,wrap,wrapped,120,"// Returning a record by value is fine. (In this case, the returned; // expression will be a copy-constructor, possibly wrapped in an; // ExprWithCleanups node.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:39,Modifiability,variab,variables,39,// Iterate over all bindings to global variables and see if it contains; // a memory region in the stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:19,Modifiability,variab,variables,19,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:55,Modifiability,variab,variables,55,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:121,Modifiability,variab,variables,121,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:163,Modifiability,variab,variable,163,/// Look for stack variables referring to popped stack variables.; /// Returns true only if it found some dangling stack variables; /// referred by an other stack variable from different stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:1506,Energy Efficiency,reduce,reduces,1506,"es a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:1514,Performance,perform,performance,1514,"es a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:2008,Safety,avoid,avoids,2008,"pecification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:423,Usability,simpl,simple,423,"//=== StdLibraryFunctionsChecker.cpp - Model standard functions -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker improves modeling of a few simple library functions.; //; // This checker provides a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:147,Usability,simpl,simple,147,"/// Print value X of the argument in form "" (which is X)"",; /// if the value is a fixed known value, otherwise print nothing.; /// This is used as simple explanation of values if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:56,Modifiability,polymorphi,polymorphic,56,"/// Pointer to the ValueConstraint. We need a copyable, polymorphic and; /// default initializable type (vector needs that). A raw pointer was good,; /// however, we cannot default initialize that. unique_ptr makes the Summary; /// class non-copyable, therefore not an option. Releasing the copyability; /// requirement would render the initialization of the Summary map infeasible.; /// Mind that a pointer to a new value constraint is created when the negate; /// function is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:4,Modifiability,Polymorphi,Polymorphic,4,"/// Polymorphic base class that represents a constraint on a given argument; /// (or return value) of a function. Derived classes implement different kind; /// of constraints, e.g range constraints or correlation between two; /// arguments.; /// These are used as argument constraints (preconditions) of functions, in; /// which case a bug report may be emitted if the constraint is not satisfied.; /// Another use is as conditions for summary cases, to create different; /// classes of behavior for a function. In this case no description of the; /// constraint is needed because the summary cases have an own (not generated); /// description string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:131,Safety,safe,safely,131,"// There are some descendant classes that are not used as argument; // constraints, e.g. ComparisonConstraint. In that case we can safely; // ignore the implementation of this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:432,Usability,simpl,simple,432,"/// Give a description that explains the actual argument value (where the; /// current ValueConstraint applies to) to the user. This function should be; /// called only when the current constraint is satisfied by the argument.; /// It should produce a more precise description than the constraint itself.; /// The actual value of the argument and the program state can be used to; /// make the description more precise. In the most simple case, if the; /// argument has a fixed known value this value can be printed into \p Out,; /// this is done by default.; /// The function should return true if a description was printed to \p Out,; /// otherwise false.; /// See StdLibraryFunctionsChecker::reportBug about how this function is; /// used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:37,Security,validat,validation,37,// Subclasses may further refine the validation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:27,Security,validat,validation,27,/// Do constraint-specific validation check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:452,Integrability,depend,dependent,452,"/// Check if a single argument falls into a specific ""range"".; /// A range is formed as a set of intervals.; /// E.g. \code {['A', 'Z'], ['a', 'z'], ['_', '_']} \endcode; /// The intervals are closed intervals that contain one or more values.; ///; /// The default constructed RangeConstraint has an empty range, applying; /// such constraint does not involve any assumptions, thus the State remains; /// unchanged. This is meaningful, if the range is dependent on a looked up; /// type (e.g. [0, Socklen_tMax]). If the type is not found, then the range; /// is default initialized to be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Modifiability,variab,variable,8,// This variable has a role when we negate the constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:217,Integrability,depend,depend,217,"/// Check null or non-null-ness of an argument that is of pointer type.; /// The argument is meant to be a buffer that has a size constraint, and it; /// is allowed to have a NULL value if the size is 0. The size can depend on; /// 1 or 2 additional arguments, if one of these is 0 the buffer is allowed to; /// be NULL. This is useful for functions like `fread` which have this special; /// property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Modifiability,variab,variable,8,// This variable has a role when we negate the constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:186,Availability,failure,failure,186,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:230,Availability,failure,failure,230,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:427,Availability,failure,failure,427,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:45,Modifiability,variab,variable,45,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:54,Modifiability,variab,variable,54,/// Apply specific state changes related to the errno variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:28,Availability,failure,failure,28,/// Set errno constraint at failure cases of standard functions.; /// Failure case: 'errno' becomes not equal to 0 and may or may not be checked; /// by the program. \c ErrnoChecker does not emit a bug report after such a; /// function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:70,Availability,Failure,Failure,70,/// Set errno constraint at failure cases of standard functions.; /// Failure case: 'errno' becomes not equal to 0 and may or may not be checked; /// by the program. \c ErrnoChecker does not emit a bug report after such a; /// function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:52,Availability,failure,failure,52,/// Set errno constraint at functions that indicate failure only with 'errno'.; /// In this case 'errno' is required to be observed.; /// \c ErrnoChecker can emit bug report after such a function call if errno; /// is overwritten without a read before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:515,Performance,queue,queued,515,"/// A single branch of a function summary.; ///; /// A branch is defined by a series of constraints - ""assumptions"" -; /// that together form a single possible outcome of invoking the function.; /// When static analyzer considers a branch, it tries to introduce; /// a child node in the Exploded Graph. The child node has to include; /// constraints that define the branch. If the constraints contradict; /// existing constraints in the state, the node is not created and the branch; /// is dropped; otherwise it's queued for future exploration.; /// The branch is accompanied by a note text that may be displayed; /// to the user when a bug is found on a path that takes this branch.; ///; /// For example, consider the branches in `isalpha(x)`:; /// Branch 1); /// x is in range ['A', 'Z'] or in ['a', 'z']; /// then the return value is not 0. (I.e. out-of-range [0, 0]); /// and the note may say ""Assuming the character is alphabetical""; /// Branch 2); /// x is out-of-range ['A', 'Z'] and out-of-range ['a', 'z']; /// then the return value is 0; /// and the note may say ""Assuming the character is non-alphabetical"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:307,Availability,error,error,307,"/// A summary includes information about; /// * function prototype (signature); /// * approach to invalidation,; /// * a list of branches - so, a list of list of ranges,; /// * a list of argument constraints, that must be true on every branch.; /// If these constraints are not satisfied that means a fatal error; /// usually resulting in undefined behaviour.; ///; /// Application of a summary:; /// The signature and argument constraints together contain information; /// about which functions are handled by the summary. The signature can use; /// ""wildcards"", i.e. Irrelevant types. Irrelevant type of a parameter in; /// a signature means that type is not compared to the type of the parameter; /// in the found FunctionDecl. Argument constraints may specify additional; /// rules for the given parameter's type, those rules are checked once the; /// signature is matched.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:55,Security,validat,validation,55,// Once we know the exact type of the function then do validation check on; // all the given constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:147,Availability,failure,failure,147,"/// These are the errno constraints that can be passed to summary cases.; /// One of these should fit for a single summary case.; /// Usually if a failure return value exists for function, that function; /// needs different cases for success and failure with different errno; /// constraints (and different return value constraints).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:246,Availability,failure,failure,246,"/// These are the errno constraints that can be passed to summary cases.; /// One of these should fit for a single summary case.; /// Usually if a failure return value exists for function, that function; /// needs different cases for success and failure with different errno; /// constraints (and different return value constraints).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:12,Safety,avoid,avoid,12,// Note: we avoid integral promotion for comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:111,Availability,Failure,FailureSt,111,// We will apply the constraint even if we cannot reason about the; // argument. This means both SuccessSt and FailureSt can be true. If we; // weren't applying the constraint that would mean that symbolic; // execution continues on a code whose behaviour is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:128,Performance,perform,performed,128,"// Try to omit the note if we know in advance which branch is; // taken (this means, only one branch exists).; // This check is performed inside the lambda, after other; // (or this) checkers had a chance to add other successors.; // Dereferencing the saved node object is valid because it's part; // of a bug report call sequence.; // FIXME: This check is not exact. We may be here after a state; // split that was performed by another checker (and can not find; // the successors). This is why this check is only used in the; // EvalCallAsPure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:416,Performance,perform,performed,416,"// Try to omit the note if we know in advance which branch is; // taken (this means, only one branch exists).; // This check is performed inside the lambda, after other; // (or this) checkers had a chance to add other successors.; // Dereferencing the saved node object is valid because it's part; // of a bug report call sequence.; // FIXME: This check is not exact. We may be here after a state; // split that was performed by another checker (and can not find; // the successors). This is why this check is only used in the; // EvalCallAsPure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:29,Performance,perform,performing,29,"// Summary tells us to avoid performing eval::Call. The function is possibly; // evaluated by another checker, or evaluated conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:23,Safety,avoid,avoid,23,"// Summary tells us to avoid performing eval::Call. The function is possibly; // evaluated by another checker, or evaluated conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:327,Testability,test,tested,327,"// Set UCharRangeMax to min of int or uchar maximum value.; // The C standard states that the arguments of functions like isalpha must; // be representable as an unsigned char. Their type is 'int', so the max; // value of the argument should be min(UCharMax, IntMax). This just happen; // to be true for commonly used and well tested instruction set; // architectures, but not for others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:16,Integrability,depend,dependent,16,"// Get platform dependent values of some macros.; // Try our best to parse this from the Preprocessor, otherwise fallback to a; // default value (what is found in a library header).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:66,Performance,perform,performed,66,"// Add a summary to a FunctionDecl found by lookup. The lookup is performed; // by the given Name, and in the global scope. The summary will be attached; // to the found FunctionDecl only if the signatures match.; //; // Returns true if the summary has been added, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:9,Availability,down,down,9,// Boils down to isupper() or islower() or isdigit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:58,Availability,error,error,58,// void rewind(FILE *stream);; // This function indicates error only by setting of 'errno'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:8,Usability,clear,clearerr,8,// void clearerr(FILE *stream);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:7,Security,access,access,7,"// int access(const char *pathname, int amode);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:219,Availability,failure,failure,219,"// off_t lseek(int fildes, off_t offset, int whence);; // In the first case we can not tell for sure if it failed or not.; // A return value different from of the expected offset (that is unknown; // here) may indicate failure. For this reason we do not enforce the errno; // check (can cause false positive).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:477,Integrability,protocol,protocol,477,"// In 'socket.h' of some libc implementations with C99, sockaddr parameter; // is a transparent union of the underlying sockaddr_ family of pointers; // instead of being a pointer to struct sockaddr. In these cases, the; // standardized signature will not match, thus we try to match with another; // signature that has the joker Irrelevant type. We also remove those; // constraints which require pointer types for the sockaddr param.; // int socket(int domain, int type, int protocol);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:42,Integrability,message,message,42,"// ssize_t sendto(int socket, const void *message, size_t length,; // int flags, const struct sockaddr *dest_addr,; // socklen_t dest_len);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:44,Integrability,protocol,protocol,44,"// int socketpair(int domain, int type, int protocol, int sv[2]);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:17,Testability,test,testing,17,// Functions for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test inside range constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test out of range constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test range kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:3,Testability,Test,Test,3,// Test the application of cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp:38,Modifiability,extend,extended,38,// FIXME Later this checker should be extended to handle constructors; // with multiple arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdVariantChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:24,Availability,error,error,24,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:88,Availability,error,error,88,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:187,Performance,optimiz,optimization,187,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:203,Safety,avoid,avoid,203,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:49,Availability,error,error,49,/// The stream can be in state where none of the error flags set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:41,Availability,error,error,41,/// The stream can be in state where the error indicator is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:17,Availability,error,error,17,/// State of the error flags.; /// Ignored in non-opened stream state but must be NoError.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:239,Availability,error,error,239,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:261,Availability,error,error,261,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:390,Availability,error,error,390,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:406,Availability,Error,ErrorState,406,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:215,Integrability,depend,dependent,215,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:279,Usability,clear,cleared,279,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:293,Usability,clear,clearerr,293,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,Availability,error,error,23,"// In not opened state error state should always NoError, so comparison; // here is no problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:30,Testability,test,testing,30,"/// If true, evaluate special testing stream functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:90,Availability,error,error,90,/// Check that the stream (in StreamVal) is not NULL.; /// If it can only be NULL a fatal error is emitted and nullptr returned.; /// Otherwise the return value is a new state where the stream is constrained; /// to be non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:95,Availability,error,error,95,"/// Check that the stream is the opened state.; /// If the stream is known to be not opened an error is generated; /// and nullptr returned, otherwise the original state is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:197,Availability,error,error,197,"/// Check that the stream has not an invalid (""indeterminate"") file position,; /// generate warning for it.; /// (EOF is not an invalid position.); /// The returned state can be nullptr if a fatal error was generated.; /// It can return non-null state if the stream has not an invalid position or; /// there is execution path with non-invalid position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:74,Availability,error,error,74,"/// Check the legality of the 'whence' argument of 'fseek'.; /// Generate error and return nullptr if it is found to be illegal.; /// Otherwise returns the state.; /// (State is not changed here because the ""whence"" value is already known.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:142,Availability,error,error,142,"/// Generate warning about stream in EOF state.; /// There will be always a state transition into the passed State,; /// by the new non-fatal error node or (if failed) a normal transition,; /// to ensure uniform handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,error,error,80,"/// Emit resource leak warnings for the given symbols.; /// Createn a non-fatal error node for these, and returns it (if any warnings; /// were generated). Return value is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:15,Integrability,message,message,15,/// Generate a message for BugReporterVisitor if the stored symbol is; /// marked as interesting by the actual bug report.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:168,Availability,error,error,168,"// Generate state for non-failed case.; // Return value is the passed stream pointer.; // According to the documentations, the stream is closed first; // but any close error is ignored. The state changes to (or remains) opened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:31,Availability,failure,failure,31,"// Return 0 on success, EOF on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:174,Availability,error,error,174,"// C'99 standard, §7.19.8.1.3, the return value of fread:; // The fread function returns the number of elements successfully read, which; // may be less than nmemb if a read error or end-of-file is encountered. If; // size or nmemb is zero, fread returns zero and the contents of the array and; // the state of the stream remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:95,Availability,error,error,95,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:85,Usability,clear,clear,85,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:18,Availability,error,error,18,"// If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:18,Availability,error,error,18,"// If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:96,Availability,error,error,96,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:169,Availability,failure,failure,169,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:324,Availability,error,error,324,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:398,Availability,error,error,398,"// Add the success state.; // In this context ""success"" means there is not an EOF or other read error; // before any item is matched in 'fscanf'. But there may be match failure,; // therefore return value can be 0 or greater.; // It is not specified what happens if some items (not all) are matched and; // then EOF or read error happens. Now this case is handled like a ""success""; // case, and no error flags are set on the stream. This is probably not; // accurate, and the POSIX documentation does not tell more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:44,Availability,Error,Error,44,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:116,Availability,Error,Error,116,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:143,Availability,error,error,143,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:160,Availability,error,error,160,"// Add transition for the failed state.; // Error occurs if nothing is matched yet and reading the input fails.; // Error can be EOF, or other error. At ""other error"" FERROR or 'errno' can; // be set but it is not further specified if all are required to be set.; // Documentation does not mention, but file position will be set to; // indeterminate similarly as at 'fread'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:44,Availability,Failure,Failure,44,"// Add transition for the failed state.; // Failure of 'ungetc' does not result in feof or ferror state.; // If the PutVal has value of EofVal the function should ""fail"", but this is; // the same transition as the success state.; // In this case only one state transition is added by the analyzer (the two; // new states may be similar).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:232,Availability,error,error,232,"// Upon successful completion, the getline() and getdelim() functions shall; // return the number of bytes written into the buffer.; // If the end-of-file indicator for the stream is set, the function shall; // return -1.; // If an error occurs, the function shall return -1 and set 'errno'.; // Add transition for the successful state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:59,Availability,error,error,59,"// Add transition for the failed state.; // If a (non-EOF) error occurs, the resulting value of the file position; // indicator for the stream is indeterminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:90,Availability,error,error,90,"// Bifurcate the state into failed and non-failed.; // Return zero on success, nonzero on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:37,Availability,error,error,37,// Reset the state to opened with no error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:10,Availability,error,error,10,"// We get error.; // It is possible that fseek fails but sets none of the error flags.; // If fseek failed, assume that the file position becomes indeterminate in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:74,Availability,error,error,74,"// We get error.; // It is possible that fseek fails but sets none of the error flags.; // If fseek failed, assume that the file position becomes indeterminate in any; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:60,Availability,error,error,60,// Setting the position to start of file never produces EOF error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,failure,failure,80,// This function does not affect the stream state.; // Still we add success and failure state with the appropriate return value.; // StdLibraryFunctionsChecker can change these states (set the 'errno' state).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:6,Availability,failure,failure,6,// At failure ferror could be set.; // The standards do not tell what happens with the file position at failure.; // But we can assume that it is dangerous to make a next I/O operation after; // the position was not set correctly (similar to 'fseek').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:104,Availability,failure,failure,104,// At failure ferror could be set.; // The standards do not tell what happens with the file position at failure.; // But we can assume that it is dangerous to make a next I/O operation after; // the position was not set correctly (similar to 'fseek').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,Availability,failure,failure,80,// This function does not affect the stream state.; // Still we add success and failure state with the appropriate return value.; // StdLibraryFunctionsChecker can change these states (set the 'errno' state).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:36,Usability,clear,cleared,36,// FilePositionIndeterminate is not cleared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,Availability,error,error,23,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:32,Availability,Error,ErrorKind,32,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:105,Availability,error,error,105,// Execution path with error of ErrorKind.; // Function returns true.; // From now on it is the only one error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:26,Availability,Error,ErrorKind,26,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:81,Availability,error,error,81,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:120,Availability,Error,ErrorKind,120,// Execution path(s) with ErrorKind not set.; // Function returns false.; // New error state is everything before minus ErrorKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:27,Availability,failure,failure,27,"// `fflush` returns EOF on failure, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,Availability,error,error,9,"// Clear error states if `fflush` returns 0, but retain their EOF flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:3,Usability,Clear,Clear,3,"// Clear error states if `fflush` returns 0, but retain their EOF flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:9,Availability,error,error,9,// Clear error states for all streams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:3,Usability,Clear,Clear,3,// Clear error states for all streams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:7,Availability,error,error,7,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:77,Availability,error,error,77,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:136,Availability,error,error,136,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:20,Availability,error,error,20,"// Known or unknown error state without FEOF possible.; // Stop analysis, report error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:81,Availability,error,error,81,"// Known or unknown error state without FEOF possible.; // Stop analysis, report error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:96,Availability,error,error,96,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:325,Availability,error,errors,325,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:351,Availability,redundant,redundant,351,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:351,Safety,redund,redundant,351,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:108,Deployability,update,updated,108,// Check for file-handling system call that is not handled by the checker.; // FIXME: The checker should be updated to handle all system calls that take; // 'FILE*' argument. These are now ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp:21,Performance,cache,cached,21,// See if we already cached it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp:3,Performance,Cache,Cache,3,// Cache the decl of the right overload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StringChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:116,Energy Efficiency,efficient,efficiently,116,"// If the SVal represents a structure, try to mass-taint all values within the; // structure. For now it only works efficiently on lazy compound values that; // were conjured during a conservative evaluation of a function - either as; // return values of functions that return structures or arrays by value, or as; // values of structures or arrays passed into the function by reference,; // directly or through pointer aliasing. Such lazy compound values are; // characterized by having exactly one binding in their captured store within; // their parent region, which is a conjured symbol default-bound to the base; // region of the parent region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:40,Integrability,depend,depends,40,// Traverse all the symbols this symbol depends on to see if any are tainted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp:14,Testability,log,logic,14,"// FIXME: The logic to identify tainted regions could be more; // complete. For example, this would not currently identify; // overlapping fields in a union as tainted. To identify this we can; // check for overlapping/nested byte offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Taint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp:411,Testability,test,testing,411,"//== TaintTesterChecker.cpp ----------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker can be used for testing how taint data is propagated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TaintTesterChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:442,Performance,perform,performs,442,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:5,Testability,Test,TestAfterDivZeroChecker,5,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:35,Testability,Test,Test,35,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:396,Testability,Test,TestAfterDivZeroChecker,396,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:53,Integrability,protocol,protocols,53,// Only trust annotations for system headers for non-protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:7,Testability,log,logic,7,"// The logic for ObjC instance method calls is more complicated,; // as the return value is nil when the receiver is nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:12,Integrability,protocol,protocols,12,// Distrust protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:13,Integrability,message,messages,13,// For class messages it is sufficient for the declaration to be; // annotated _Nonnull.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp:691,Availability,error,error,691,"// What's going on here: we want to highlight the subexpression of the; // condition that is the most likely source of the ""uninitialized; // branch condition."" We do a recursive walk of the condition's; // subexpressions and roughly look for the most nested subexpression; // that binds to Undefined. We then highlight that expression's range.; // Get the predecessor node and check if is a PostStmt with the Stmt; // being the terminator condition. We want to inspect the state; // of that node instead because it will contain main information about; // the subexpressions.; // Note: any predecessor will do. They should have identical state,; // since all the BlockEdge did was act as an error sink since the value; // had to already be undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefBranchChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp:396,Safety,detect,detects,396,"// UndefCapturedBlockVarChecker.cpp - Uninitialized captured vars -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects blocks that capture uninitialized values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp:467,Performance,perform,performs,467,"//===--- UndefinedArraySubscriptChecker.h ----------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefinedArraySubscriptChecker, a builtin check in ExprEngine; // that performs checks for undefined array subscripts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp:34,Modifiability,variab,variables,34,// Sema generates anonymous array variables for copying array struct fields.; // Don't warn if we're in an implicitly-generated constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp:455,Performance,perform,performs,455,"//=== UndefResultChecker.cpp ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefResultChecker, a builtin check in ExprEngine that; // performs checks for undefined results of non-assignment binary operators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:12,Availability,mask,maskedFlags,12,// Check if maskedFlags is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,Availability,error,error,16,// Only emit an error if the value of 'maskedFlags' is properly; // constrained;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:39,Availability,mask,maskedFlags,39,// Only emit an error if the value of 'maskedFlags' is properly; // constrained;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:92,Modifiability,refactor,refactored,92,// This is similar to 'CheckDispatchOnce' in the MacOSXAPIChecker.; // They can possibly be refactored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:40,Energy Efficiency,allocate,allocated,40,"// Check if the first argument is stack allocated. If so, issue a warning; // because that's likely to be bad news.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,Availability,error,error,16,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:144,Availability,error,error,144,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:88,Performance,perform,perform,88,"// Generates an error report, indicating that the function whose name is given; // will perform a zero byte allocation.; // Returns false if an error occurred, true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:135,Availability,error,errors,135,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:128,Safety,detect,detect,128,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:69,Modifiability,extend,extended,69,"// Special case for __builtin_unreachable.; // FIXME: This should be extended to include other unreachable markers,; // such as llvm_unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:2,Testability,assert,assert,2,"//assert(cond && ""CFGBlock's predecessor has a terminator condition"");; // The previous assertion is invalid in some cases (eg do/while). Leaving; // reporting of these situations on at the moment to help triage these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:88,Testability,assert,assertion,88,"//assert(cond && ""CFGBlock's predecessor has a terminator condition"");; // The previous assertion is invalid in some cases (eg do/while). Leaving; // reporting of these situations on at the moment to help triage these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp:411,Safety,detect,detect,411,"//== ValistChecker.cpp - stdarg.h macro usage checker -----------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines checkers which detect usage of uninitialized va_list values; // and va_start calls with no matching va_end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ValistChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:588,Modifiability,variab,variables,588,"//===- VforkChecker.cpp -------- Vfork usage checks --------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines vfork checker which checks for dangerous uses of vfork.; // Vforked process shares memory (including stack) with parent so it's; // range of actions is significantly limited: can't write variables,; // can't call functions not in the allowed list, etc. For more details, see; // http://man7.org/linux/man-pages/man2/vfork.2.html; //; // This checker checks for prohibited constructs in vforked process.; // The state transition diagram:; // PARENT ---(vfork() == 0)--> CHILD; // |; // --(*p = ...)--> bug; // |; // --foo()--> bug; // |; // --return--> bug; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:58,Modifiability,variab,variable,58,// end anonymous namespace; // This trait holds region of variable that is assigned with vfork's; // return value (this is the only region child is allowed to write).; // VFORK_RESULT_INVALID means that we are in parent process.; // VFORK_RESULT_NONE means that vfork's return value hasn't been assigned.; // Other values point to valid regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:3,Safety,Detect,Detect,3,// Detect calls to vfork and split execution appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:16,Modifiability,variab,variable,16,// Get assigned variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp:14,Security,access,access,14,"// The member access is fully qualified (i.e., X::F).; // Treat this as a non-virtual call and do not warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:451,Performance,perform,performs,451,"//=== VLASizeChecker.cpp - Undefined dereference checker --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines VLASizeChecker, a builtin check in ExprEngine that; // performs checks for declaration of VLA of undefined or zero size.; // In addition, VLASizeChecker is responsible for defining the extent; // of the MemRegion that represents a VLA.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:159,Security,validat,validated,159,/// Check a VLA for validity.; /// Every dimension of the array and the total size is checked for validity.; /// Returns null or a new state where the size is validated.; /// 'ArraySize' will contain SVal that refers to the total size (in char); /// of the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:83,Modifiability,Variab,VariableArrayType,83,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:131,Modifiability,variab,variable,131,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:180,Modifiability,variab,variably,180,"// Walk over the VLAs for every dimension until a non-VLA is found.; // There is a VariableArrayType for every dimension (fixed or variable) until; // the most inner array that is variably modified.; // Dimension sizes are collected into 'VLASizes'. 'VLALast' is set to the; // innermost VLA that was encountered.; // In ""int vla[x][2][y][3]"" this will be the array for index ""y"" (with type; // int[3]). 'VLASizes' contains 'x', '2', and 'y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:150,Safety,detect,detected,150,// Check if the array size will overflow.; // Size overflow check does not work with symbolic expressions because a; // overflow situation can not be detected easily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:441,Deployability,configurat,configuration,441,"//== Yaml.h ---------------------------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines convenience functions for handling YAML configuration files; // for checkers/packages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:441,Modifiability,config,configuration,441,"//== Yaml.h ---------------------------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines convenience functions for handling YAML configuration files; // for checkers/packages.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:154,Availability,error,error,154,/// Read the given file from the filesystem and parse it as a yaml file. The; /// template parameter must have a yaml MappingTraits.; /// Emit diagnostic error in case of any failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:175,Availability,failure,failure,175,/// Read the given file from the filesystem and parse it as a yaml file. The; /// template parameter must have a yaml MappingTraits.; /// Emit diagnostic error in case of any failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:112,Modifiability,variab,variable,112,"// SEI CERT ENV31-C; // If set to true, consider getenv calls as invalidating operations on the; // environment variable buffer. This is implied in the standard, but in; // practice does not cause problems (in the commonly used environments).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:79,Safety,avoid,avoid,79,// Mark all regions that were interesting before as NOT interesting now; // to avoid extra notes coming from invalidation points higher up the; // bugpath. This ensures that only the last invalidation point is marked; // with a note tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:17,Integrability,message,message,17,// Emit note tag message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:33,Usability,Simpl,Simplify,33,// TODO: This seems really ugly. Simplify this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp:483,Modifiability,variab,variable,483,"//== PutenvWithAutoChecker.cpp --------------------------------- -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines PutenvWithAutoChecker which finds calls of ``putenv``; // function with automatic variable as the argument.; // https://wiki.sei.cmu.edu/confluence/x/6NYxBQ; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/PutenvWithAutoChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp:488,Safety,detect,detected,488,"//===-- MPIBugReporter.cpp - bug reporter -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines prefabricated reports which are emitted in; /// case of MPI related bugs, detected by path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h:486,Safety,detect,detected,486,"//===-- MPIBugReporter.h - bug reporter -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines prefabricated reports which are emitted in; /// case of MPI related bugs, detected by path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIBugReporter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:22,Safety,detect,detected,22,// double nonblocking detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:6,Availability,error,error,6,// no error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:17,Deployability,update,update,17,// Transition to update the state regarding removed requests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h:89,Availability,alive,alive,89,"/// Check if a nonblocking call is not matched by a wait.; /// If a memory region is not alive and the last function using the; /// request was a nonblocking call, this is rated as a missing wait.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h:491,Integrability,wrap,wrapper,491,"//===-- MPITypes.h - Functionality to model MPI concepts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides definitions to model concepts of MPI. The mpi::Request; /// class defines a wrapper class, in order to make MPI requests trackable for; /// path-sensitive analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h:234,Availability,avail,available,234,"// The RequestMap stores MPI requests which are identified by their memory; // region. Requests are used in MPI to complete nonblocking operations with wait; // operations. A custom map implementation is used, in order to make it; // available in an arbitrary amount of translation units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:94,Modifiability,variab,variables,94,"// FIXME: For now we invalidate the tracking of all symbols passed to blocks; // via captured variables, even though captured variables result in a copy; // and in implicit increment/decrement of a retain count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:126,Modifiability,variab,variables,126,"// FIXME: For now we invalidate the tracking of all symbols passed to blocks; // via captured variables, even though captured variables result in a copy; // and in implicit increment/decrement of a retain count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:23,Availability,error,error,23,"// FIXME: If we get an error during a bridge cast, should we report it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:38,Integrability,bridg,bridge,38,"// FIXME: If we get an error during a bridge cast, should we report it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Security,Access,Accessing,3,"// Accessing an ivar directly is unusual. If we've done that, be more; // forgiving about what the surrounding code is allowed to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:33,Performance,load,loaded,33,// Note that this value has been loaded from an ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Security,access,accessor,20,"// In a synthesized accessor, the effective retain count is +0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:16,Integrability,message,message,16,"// Check if the message is not consumed, we know it will not be used in; // an assignment, ex: ""self = [super init]"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:53,Integrability,message,message,53,"/// GetReturnType - Used to get the return type of a message expression or; /// function call with the intention of affixing that type to a tracked symbol.; /// While the return type can be queried directly from RetEx, when; /// invoking class methods we augment to the return type to be that of; /// a pointer to the class (as opposed it just being id).; // FIXME: We may be able to do this with related result types instead.; // This function is probably overestimating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Integrability,message,message,20,"// If RetE is not a message expression just return its type.; // If RetE is a message expression, return its types if it is something; /// more specific than id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:78,Integrability,message,message,78,"// If RetE is not a message expression just return its type.; // If RetE is a message expression, return its types if it is something; /// more specific than id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:48,Integrability,message,message,48,"// At this point we know the return type of the message expression is; // id, id<...>, or Class. If we have an ObjCInterfaceDecl, we know this; // is a call to a class method whose type we can resolve. In such; // cases, promote the return type to XXX* (where XXX is the class).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:30,Integrability,message,message,30,// Evaluate the effect on the message receiver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:190,Modifiability,variab,variable,190,"/// A value escapes in these possible cases:; ///; /// - binding to something that is not a memory region.; /// - binding to a memregion that does not have stack storage; /// - binding to a variable that has a destructor attached using CleanupAttr; ///; /// We do not currently model what happens when a symbol is; /// assigned to a struct field, unless it is a known smart pointer; /// implementation, about which we know that it is inlined.; /// FIXME: This could definitely be improved upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:136,Safety,avoid,avoid,136,"// Splitting is required to support out parameters,; // as out parameters might be created only on the ""success"" branch.; // We want to avoid eagerly splitting unless out parameters are actually; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:30,Integrability,message,message,30,// Evaluate the effect on the message receiver / `this` argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:15,Availability,error,errors,15,// Process any errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:24,Deployability,release,releases,24,// Handle all use-after-releases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:43,Availability,error,error,43,// NB. we only need to add a note in a non-error case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:45,Deployability,release,released,45,// The object immediately transitions to the released state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the autorelease counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:17,Deployability,Release,Released,17,// case 'RefVal::Released' handled above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:28,Modifiability,variab,variable,28,"// Assume that the instance variable was holding on the object at; // +1, and we just didn't know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:18,Availability,down,down,18,// We need to dig down to the symbolic base here because various; // custom allocators do sometimes return the symbol with an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:25,Deployability,update,updated,25,// At this point we have updated the state properly.; // Everything after this is merely checking to see if the return value has; // been over- or under-retained.; // Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:174,Performance,cache,cache,174,// At this point we have updated the state properly.; // Everything after this is merely checking to see if the return value has; // been over- or under-retained.; // Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update the autorelease counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:11,Deployability,update,updated,11,// Get the updated binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:22,Availability,error,errors,22,// Any leaks or other errors?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:15,Availability,error,error,15,// Generate an error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:28,Integrability,interface,interface,28,// FIXME: We may add to the interface of evalAssume the list of symbols; // whose assumptions have changed. For now we just iterate through the; // bindings and check if any of the tracked symbols are NULL. This isn't; // too bad since the number of symbols we will track in practice are; // probably small and evalAssume is only called at branches and a few; // other places.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:50,Deployability,release,released,50,// FIXME: Handle sending 'autorelease' to already released object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,Deployability,release,release,20,"// If we would over-release here, but we know the value came from an ivar,; // assume it was a strong ivar that's just been relinquished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:72,Availability,error,error,72,// Woah! More autorelease counts then retain counts left.; // Emit hard error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:245,Deployability,release,release,245,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:46,Security,access,accessed,46,"// HACK: Ignore retain-count issues on values accessed through ivars,; // because of cases like this:; // [_contentView retain];; // [_contentView removeFromSuperview];; // [self addSubview:_contentView]; // invalidates 'self'; // [_contentView release];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:17,Performance,cache,cached,17,// Created state cached out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:162,Deployability,release,releases,162,"// If the current LocationContext has a parent, don't check for leaks.; // We will do that later.; // FIXME: we should instead check for imbalances of the retain/releases,; // and suggest annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:3,Deployability,Update,Update,3,// Update counts from autorelease pools,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:10,Performance,cache,cache,10,// Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:273,Integrability,depend,depends,273,"// FIXME: We want bug reports to always have the same checker name associated; // with them, yet here, if RetainCountChecker is disabled but; // OSObjectRetainCountChecker is enabled, the checker names will be different.; // This hack will make it so that the checker name depends on which checker is; // enabled rather than on the registration order.; // For the most part, we want **non-hidden checkers** to be associated with; // diagnostics, and **hidden checker options** with the fine-tuning of; // modeling. Following this logic, OSObjectRetainCountChecker should be the; // latter, but we can't just remove it for backward compatibility reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:530,Testability,log,logic,530,"// FIXME: We want bug reports to always have the same checker name associated; // with them, yet here, if RetainCountChecker is disabled but; // OSObjectRetainCountChecker is enabled, the checker names will be different.; // This hack will make it so that the checker name depends on which checker is; // enabled rather than on the registration order.; // For the most part, we want **non-hidden checkers** to be associated with; // diagnostics, and **hidden checker options** with the fine-tuning of; // modeling. Following this logic, OSObjectRetainCountChecker should be the; // latter, but we can't just remove it for backward compatibility reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:19,Deployability,release,released,19,// Object has been released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:21,Deployability,release,released,21,// Object used after released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:3,Deployability,Release,Release,3,// Release of an object that was not owned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:88,Modifiability,variab,variable,88,"/// Returns what the analyzer knows about direct accesses to a particular; /// instance variable.; ///; /// If the object with this refcount wasn't originally from an Objective-C; /// ivar region, this should always return IvarAccessHistory::None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:49,Security,access,accesses,49,"/// Returns what the analyzer knows about direct accesses to a particular; /// instance variable.; ///; /// If the object with this refcount wasn't originally from an Objective-C; /// ivar region, this should always return IvarAccessHistory::None.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:4,Performance,Perform,Perform,4,"/// Perform the necessary checks and state adjustments at the end of the; /// function.; /// \p S Return statement, may be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:58,Availability,error,error,58,// We may not have transitioned to 'release' if we hit an error.; // This case is handled elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:36,Deployability,release,release,36,// We may not have transitioned to 'release' if we hit an error.; // This case is handled elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:22,Integrability,message,message,22,// Did an autorelease message get sent?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:40,Availability,avail,available,40,// Get the name of the callee (if it is available); // from the tracked SVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,Integrability,interface,interface,53,"// We should always be able to find the boxing class interface,; // but consider this future-proofing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:35,Performance,perform,performed,35,// Gather up the effects that were performed on the object at this; // program point,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:79,Availability,avail,available,79,"// The location context of the init method called on the leaked object, if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:80,Availability,error,error,80,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:21,Modifiability,variab,variables,21,// Do not show local variables belonging to a function other than; // where the error is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:53,Energy Efficiency,allocate,allocated,53,"// If we are reporting a leak of the object that was allocated with alloc,; // mark its init method as interesting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:100,Modifiability,variab,variables,100,"// Tell the BugReporterContext to report cases when the tracked symbol is; // assigned to different variables, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:143,Energy Efficiency,allocate,allocated,143,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path. To do this, we need to find; // the allocation site of a piece of tracked memory, which we do via a; // call to GetAllocationSite. This will walk the ExplodedGraph backwards.; // Note that this is *not* the trimmed graph; we are guaranteed, however,; // that all ancestor nodes that represent the allocation site have the; // same SourceLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:24,Performance,cache,cached,24,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path. To do this, we need to find; // the allocation site of a piece of tracked memory, which we do via a; // call to GetAllocationSite. This will walk the ExplodedGraph backwards.; // Note that this is *not* the trimmed graph; we are guaranteed, however,; // that all ancestor nodes that represent the allocation site have the; // same SourceLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:360,Deployability,release,release,360,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:505,Deployability,release,released,505,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:273,Energy Efficiency,allocate,allocate,273,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:331,Energy Efficiency,allocate,allocate,331,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:195,Integrability,message,message,195,"// At this point, we know that the original region doesn't contain the leaking; // when the actual leak happens. It means that it can be confusing for the; // user to see such description in the message.; //; // Let's consider the following example:; // Object *Original = allocate(...);; // Object *New = Original;; // Original = allocate(...);; // Original->release();; //; // Complaining about a leaking object ""stored into Original"" might cause a; // rightful confusion because 'Original' is actually released.; // We should complain about 'New' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h:50,Energy Efficiency,allocate,allocated,50,// Finds the location where the leaking object is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1267,Availability,CheckPoint,CheckPointeeInitialization,1267,"xception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1550,Availability,CheckPoint,CheckPointeeInitialization,1550,"ted after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2684,Energy Efficiency,reduce,reduce,2684,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:835,Modifiability,config,config,835,"//===----- UninitializedObject.h ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1184,Modifiability,config,config,1184,"llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:1501,Modifiability,config,config,1501,"The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2104,Modifiability,config,config,2104,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2421,Modifiability,config,config,2421,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:479,Testability,log,logic,479,"//===----- UninitializedObject.h ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper classes for UninitializedObjectChecker and; // documentation about the logic of it.; //; // The checker reports uninitialized fields in objects created after a; // constructor call.; //; // This checker has several options:; // - ""Pedantic"" (boolean). If its not set or is set to false, the checker; // won't emit warnings for objects that don't have at least one initialized; // field. This may be set with; //; // `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2370,Testability,assert,assert,2370,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:30,Integrability,wrap,wrapper,30,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:80,Integrability,interface,interface,80,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:259,Integrability,message,messages,259,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:18,Modifiability,polymorphi,polymorphic,18,"/// A lightweight polymorphic wrapper around FieldRegion *. We'll use this; /// interface to store addinitional information about fields. As described; /// later, a list of these objects (i.e. ""fieldchain"") will be constructed and; /// used for printing note messages should an uninitialized value be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:85,Integrability,interface,interface,85,// We'll delete all of these special member functions to force the users of; // this interface to only store references to FieldNode objects in containers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:37,Integrability,wrap,wrap,37,// Special FieldNode descendants may wrap nullpointers (for example if they; // describe a special relationship between two elements of the fieldchain); // -- we wouldn't like to unique these objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:353,Integrability,message,message,353,"// When a fieldchain is printed, it will have the following format (without; // newline, indices are in order of insertion, from 1 to n):; //; // <note_message_n>'<prefix_n><prefix_n-1>...<prefix_1>; // this-><node_1><separator_1><node_2><separator_2>...<node_n>'; /// If this is the last element of the fieldchain, this method will print the; /// note message associated with it.; /// The note message should state something like ""uninitialized field"" or; /// ""uninitialized pointee"" etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:395,Integrability,message,message,395,"// When a fieldchain is printed, it will have the following format (without; // newline, indices are in order of insertion, from 1 to n):; //; // <note_message_n>'<prefix_n><prefix_n-1>...<prefix_1>; // this-><node_1><separator_1><node_2><separator_2>...<node_n>'; /// If this is the last element of the fieldchain, this method will print the; /// note message associated with it.; /// The note message should state something like ""uninitialized field"" or; /// ""uninitialized pointee"" etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:121,Modifiability,variab,variable,121,/// Returns with Field's name. This is a helper function to get the correct name; /// even if Field is a captured lambda variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:319,Integrability,wrap,wrapper,319,"/// Represents a field chain. A field chain is a list of fields where the first; /// element of the chain is the object under checking (not stored), and every; /// other element is a field, and the element that precedes it is the object; /// that contains it.; ///; /// Note that this class is immutable (essentially a wrapper around an; /// ImmutableList), new FieldChainInfo objects may be created by member; /// functions such as add() and replaceHead().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:54,Integrability,message,messages,54,"/// A map for assigning uninitialized regions to note messages. For example,; ///; /// struct A {; /// int x;; /// };; ///; /// A a;; ///; /// After analyzing `a`, the map will contain a pair for `a.x`'s region and; /// the note message ""uninitialized field 'this->x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:229,Integrability,message,message,229,"/// A map for assigning uninitialized regions to note messages. For example,; ///; /// struct A {; /// int x;; /// };; ///; /// A a;; ///; /// After analyzing `a`, the map will contain a pair for `a.x`'s region and; /// the note message ""uninitialized field 'this->x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:82,Integrability,message,message,82,"/// Returns with the modified state and a map of (uninitialized region,; /// note message) pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:225,Availability,CheckPoint,CheckPointeeInitialization,225,"/// Returns whether the analyzed region contains at least one initialized; /// field. Note that this includes subfields as well, not just direct ones,; /// and will return false if an uninitialized pointee is found with; /// CheckPointeeInitialization enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:716,Energy Efficiency,reduce,reduce,716,"//===----- UninitializedObjectChecker.cpp ------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a checker that reports uninitialized fields in objects; // created after a constructor call.; //; // To read about command line options and how the checker works, refer to the; // top of the file and inline comments in UninitializedObject.h.; //; // Some of the logic is implemented in UninitializedPointee.cpp, to reduce the; // complexity of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:663,Testability,log,logic,663,"//===----- UninitializedObjectChecker.cpp ------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a checker that reports uninitialized fields in objects; // created after a constructor call.; //; // To read about command line options and how the checker works, refer to the; // top of the file and inline comments in UninitializedObject.h.; //; // Some of the logic is implemented in UninitializedPointee.cpp, to reduce the; // complexity of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:143,Integrability,wrap,wrap,143,"/// Represents that the FieldNode that comes after this is declared in a base; /// of the previous FieldNode. As such, this descendant doesn't wrap a; /// FieldRegion, and is purely a tool to describe a relation between two other; /// FieldRegion wrapping descendants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:247,Integrability,wrap,wrapping,247,"/// Represents that the FieldNode that comes after this is declared in a base; /// of the previous FieldNode. As such, this descendant doesn't wrap a; /// FieldRegion, and is purely a tool to describe a relation between two other; /// FieldRegion wrapping descendants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:53,Security,access,access,53,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:142,Security,access,access,142,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:121,Testability,assert,assert,121,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:368,Testability,assert,asserts,368,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:36,Availability,error,error,36,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:8,Safety,avoid,avoids,8,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:43,Modifiability,inherit,inherited,43,// Checking bases. The checker will regard inherited data members as direct; // fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:85,Integrability,message,messages,85,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:70,Safety,avoid,avoid,70,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:33,Modifiability,variab,variable,33,"// If Field is a captured lambda variable, Field->getName() will return with; // an empty string. We can however acquire it's name from the lambda's; // captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp:467,Energy Efficiency,reduce,reduce,467,"//===----- UninitializedPointee.cpp ------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines functions and methods for handling pointers and references; // to reduce the size and complexity of UninitializedObjectChecker.cpp.; //; // To read about command line options and documentation about how the checker; // works, refer to UninitializedObjectChecker.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp:149,Integrability,message,message,149,"/// Represents a nonloc::LocAsInteger or void* field, that point to objects, but; /// needs to be casted back to its dynamic type for a correct note message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedPointee.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:771,Modifiability,variab,variable,771,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:82,Safety,safe,safe,82,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:144,Safety,safe,safe,144,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:189,Safety,safe,safe,189,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:228,Safety,safe,safe,228,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:99,Safety,safe,safe,99,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:291,Safety,safe,safe,291,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:174,Testability,log,logic,174,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:77,Testability,assert,assert,77,"// In case F is for example ""operator|"" the getName() method below would; // assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp:43,Safety,Safe,SafeRefCntblRawPtrAttr,43,// TODO: attributes.; // if ((*P)->hasAttr<SafeRefCntblRawPtrAttr>()); // continue;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:119,Modifiability,variab,variable,119,// We need to skip the first CompoundStmt to avoid situation when guardian is; // defined in the same scope as guarded variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:45,Safety,avoid,avoid,45,// We need to skip the first CompoundStmt to avoid situation when guardian is; // defined in the same scope as guarded variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:35,Safety,safe,safe,35,// Parameters are guaranteed to be safe for the duration of the call; // by another checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:433,Deployability,configurat,configuration,433,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:433,Modifiability,config,configuration,433,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp:410,Security,access,accessors,410,"//===- AnalyzerOptions.cpp - Analysis Engine Options ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains special accessors for analyzer configuration options; // with string representations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/AnalyzerOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp:26,Usability,Simpl,Simple,26,"//===--- APSIntType.cpp - Simple record of the type of APSInts ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/APSIntType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:174,Energy Efficiency,allocate,allocated,174,"// Note that the dstor for the contents of APSIntSet will never be called,; // so we iterate over the set and invoke the dstor for each APSInt. This; // frees an aux. memory allocated to represent very large constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:3,Safety,Avoid,Avoid,3,// Avoid division by zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:3,Safety,Avoid,Avoid,3,// Avoid division by zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:15,Testability,log,logic,15,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:68,Testability,test,test,68,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:15,Testability,log,logic,15,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:68,Testability,test,test,68,"// FIXME: This logic should probably go higher up, where we can; // test these conditions symbolically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:64,Testability,log,logic,64,"// Note: LAnd, LOr, Comma are handled specially by higher-level logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:126,Integrability,rout,routines,126,//===----------------------------------------------------------------------===//; // PathDiagnosticBuilder and its associated routines and helper objects.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:193,Security,secur,security,193,/// A helper class that contains everything needed to construct a; /// PathDiagnostic object. It does no much more then providing convenient; /// getters and some well placed asserts for extra security.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:175,Testability,assert,asserts,175,/// A helper class that contains everything needed to construct a; /// PathDiagnostic object. It does no much more then providing convenient; /// getters and some well placed asserts for extra security.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:27,Availability,error,error,27,/// A linear path from the error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:69,Availability,error,error,69,"/// The leaf of the bug path. This isn't the same as the bug reports error; /// node, which refers to the *original* graph, not the bug path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:153,Integrability,depend,depending,153,"/// This function is responsible for generating diagnostic pieces that are; /// *not* provided by bug report visitors.; /// These diagnostics may differ depending on the consumer's settings,; /// and are therefore constructed separately for each consumer.; ///; /// There are two path diagnostics generation modes: with adding edges (used; /// for plists) and without (used for HTML and text). When edges are added,; /// the path is modified to insert artificially generated edges.; /// Otherwise, more detailed diagnostics is emitted for block edges,; /// explaining the transitions in words.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:16,Modifiability,variab,variable,16,// Check if the variable corresponding to the symbol is passed by value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:54,Availability,redundant,redundant,54,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:326,Availability,redundant,redundant,326,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:7,Performance,optimiz,optimization,7,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:54,Safety,redund,redundant,54,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:326,Safety,redund,redundant,326,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:9,Testability,log,logic,9,/// Same logic as above to remove extra pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:340,Energy Efficiency,allocate,allocated,340,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:463,Energy Efficiency,allocate,allocated,463,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:706,Energy Efficiency,allocate,allocated,706,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:252,Integrability,message,message,252,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:529,Integrability,message,message,529,"//===----------------------------------------------------------------------===//; // ""Minimal"" path diagnostic generation algorithm.; //===----------------------------------------------------------------------===//; /// If the piece contains a special message, add it to all the call pieces on; /// the active stack. For example, my_malloc allocated memory, so MallocChecker; /// will construct an event at the call to malloc(), and add a stack hint that; /// an allocated memory was returned. We'll use this hint to construct a message; /// when returning from the call to my_malloc; ///; /// void *my_malloc() { return malloc(sizeof(int)); }; /// void fishy() {; /// void *ptr = my_malloc(); // returned allocated memory; /// } // leak",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Integrability,message,message,12,"// The last message on the path to final bug is the most important; // one. Since we traverse the path backwards, do not add the message; // if one has been previously added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:129,Integrability,message,message,129,"// The last message on the path to final bug is the most important; // one. Since we traverse the path backwards, do not add the message; // if one has been previously added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:34,Testability,assert,assertion,34,// FIXME: Maybe this should be an assertion. Are there cases; // were it is not an EnumConstantDecl?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:11,Security,sanitiz,sanitized,11,/// Adds a sanitized control-flow diagnostic edge to a path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:17,Integrability,wrap,wrapper,17,/// A customized wrapper for CFGBlock::getTerminatorCondition(); /// which returns the element for ObjCForCollectionStmts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:200,Security,access,accessors,200,"// Add the edge only when the callee has body. We jump to the beginning; // of the *declaration*, however we expect it to be followed by the; // body. This isn't the case for autosynthesized property accessors in; // Objective-C. No need for a similar extra check for CallExit points; // because the exit edge comes from a statement (i.e. return),; // not from declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the previous location in the active path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:91,Safety,avoid,avoids,91,"/// Adds synthetic edges from top-level statements to their subexpressions.; ///; /// This avoids a ""swoosh"" effect, where an edge from a top-level statement A; /// points to a sub-expression B.1 that's not at the start of B. In these cases,; /// we'd like to see an edge from A to B, then another one from B to B.1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:76,Testability,log,logical,76,"// Repeatedly split the edge as necessary.; // This is important for nested logical expressions (||, &&, ?:) where we; // want to show all the levels of context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the subexpression node to point to the context edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:10,Modifiability,extend,extend,10,// Try to extend the previous edge if it's at the same level as the source; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:85,Usability,simpl,simple,85,"/// Move edges from a branch condition to a branch target; /// when the condition is simple.; ///; /// This restructures some of the work of addContextEdges. That function; /// creates edges this may destroy, but they work together to create a more; /// aesthetically set of edges around branches. After the call to; /// addContextEdges, we may have (1) an edge to the branch, (2) an edge from; /// the branch to the branch condition, and (3) an edge from the branch; /// condition to the branch target. We keep (1), but may wish to remove (2); /// and move the source of (3) to the branch if the branch condition is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:617,Usability,simpl,simple,617,"/// Move edges from a branch condition to a branch target; /// when the condition is simple.; ///; /// This restructures some of the work of addContextEdges. That function; /// creates edges this may destroy, but they work together to create a more; /// aesthetically set of edges around branches. After the call to; /// addContextEdges, we may have (1) an edge to the branch, (2) an edge from; /// the branch to the branch condition, and (3) an edge from the branch; /// condition to the branch target. We keep (1), but may wish to remove (2); /// and move the source of (3) to the branch if the branch condition is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:11,Performance,perform,perform,11,"// We only perform this transformation for specific branch kinds.; // We don't want to do this for do..while, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Perform,Perform,3,// Perform the hoisting by eliminating (2) and changing the start; // location of (3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:337,Usability,simpl,simple,337,"/// Eliminate two-edge cycles created by addContextEdges().; ///; /// Once all the context edges are in place, there are plenty of cases where; /// there's a single edge from a top-level statement to a subexpression,; /// followed by a single path note, and then a reverse edge to get back out to; /// the top level. If the statement is simple enough, the subexpression edges; /// just add noise and make it harder to understand what's going on.; ///; /// This function only removes edges in pairs, because removing only one edge; /// might leave other edges dangling.; ///; /// This will not remove edges in more complicated situations:; /// - if there is more than one ""hop"" leading to or from a subexpression.; /// - if there is an inlined call between the edges instead of a single event.; /// - if the whole statement is large enough that having subexpression arrows; /// might be helpful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:51,Integrability,message,message,51,// Erase the second piece if it has the same exact message text.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Optimiz,Optimize,3,// Optimize subpaths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:40,Performance,optimiz,optimized,40,// Record the fact that a call has been optimized so we only do the; // effort once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:566,Performance,optimiz,optimization,566,"// Rule I.; //; // If we have two consecutive control edges whose end/begin locations; // are at the same level (e.g. statements or top-level expressions within; // a compound statement, or siblings share a single ancestor expression),; // then merge them if they have no interesting intermediate event.; //; // For example:; //; // (1.1 -> 1.2) -> (1.2 -> 1.3) becomes (1.1 -> 1.3) because the common; // parent is '1'. Here 'x.y.z' represents the hierarchy of statements.; //; // NOTE: this will be limited later in cases where we add barriers; // to prevent this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:214,Performance,optimiz,optimization,214,// Rule II.; //; // Eliminate edges between subexpressions and parent expressions; // when the subexpression is consumed.; //; // NOTE: this will be limited later in cases where we add barriers; // to prevent this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Optimiz,Optimize,3,// Optimize edges for ObjC fast-enumeration loops.; //; // (X -> collection) -> (collection -> element); //; // becomes:; //; // (X -> element),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:70,Usability,simpl,simple,70,// Hoist edges originating from branch conditions to branches; // for simple branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:49,Performance,optimiz,optimization,49,// Remove any puny edges left over after primary optimization pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:305,Performance,optimiz,optimizer,305,"/// Drop the very first edge in a path, which should be a function entry edge.; ///; /// If the first edge is not a function entry edge (say, because the first; /// statement had an invalid source location), this function does nothing.; // FIXME: We should just generate invalid edges anyway and have the optimizer; // deal with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Availability,error,error,12,"// From the error node to the root, ascend the bug path and construct the bug; // report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of edges from a very conservative set; // to an aesthetically pleasing subset that conveys the; // necessary information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:10,Integrability,message,messages,10,"// Remove messages that are basically the same, and edges that may not; // make sense.; // We have to do this after edge optimization in the Extensive mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:121,Performance,optimiz,optimization,121,"// Remove messages that are basically the same, and edges that may not; // make sense.; // We have to do this after edge optimization in the Extensive mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:306,Availability,down,downplay,306,"// Even if this symbol/region was already marked as interesting as a; // condition, if we later mark it as interesting again but with; // thorough tracking, overwrite it. Entities marked with thorough; // interestiness are the most important (or most interesting, if you will),; // and we wouldn't like to downplay their importance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:13,Testability,test,tests,13,// FIXME: No tests exist for this code and it is questionable:; // How to handle multiple metadata for the same region?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:85,Availability,down,downplay,85,"// If either is marked with throrough tracking, return that, we wouldn't like; // to downplay a note's importance by 'only' mentioning it as a condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:80,Availability,error,error,80,"// If no custom ranges, add the range of the statement corresponding to; // the error node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:92,Availability,error,error,92,/// A wrapper around an ExplodedGraph that contains a single path from the root; /// to the error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around an ExplodedGraph that contains a single path from the root; /// to the error node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:58,Availability,error,error,58,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:126,Availability,error,error,126,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around an ExplodedGraph whose leafs are all error nodes. Can; /// conveniently retrieve bug paths from a single error node to the root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:111,Availability,error,error,111,"/// Since the getErrorNode() or BugReport refers to the original ExplodedGraph,; /// we need to pair it to the error node of the constructed trimmed graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:20,Availability,error,error,20,// Find the (first) error node in the trimmed graph. We just need to consult; // the node map which maps from nodes in the original graph to nodes; // in the new graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Performance,Perform,Perform,3,// Perform a forward BFS to find all the shortest paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,Availability,error,error,12,// Sort the error paths from longest to shortest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:21,Availability,error,error,21,"// Now walk from the error node up the BFS path, always taking the; // predeccessor with the lowest number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:68,Availability,Error,ErrorNode,68,"/// Generate notes from all visitors.; /// Notes associated with @c ErrorNode are generated using; /// @c getEndPath, and the rest are generated with @c VisitNode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:22,Deployability,release,release,22,"// If we mess up in a release build, we'd still prefer to just drop the bug; // instead of trying to go on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:28,Security,hash,hash,28,// Compute the bug report's hash to determine its equivalence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:6,Availability,error,error,6,"// An error node must either be a sink or have a tag, otherwise; // it could get reclaimed before the path diagnostic is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:96,Usability,simpl,simply,96,"// If we don't need to suppress any of the nodes because they are; // post-dominated by a sink, simply add all the nodes in the equivalence class; // to 'Nodes'. Any of the reports will serve as a ""representative"" report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:360,Safety,risk,risk,360,"// For bug reports that should be suppressed when all paths are post-dominated; // by a sink node, iterate through the reports in the equivalence class; // until we find one that isn't post-dominated (if one exists). We use a; // DFS traversal of the ExplodedGraph to find a non-sink node. We could write; // this as a recursive function, but we don't want to risk blowing out the; // stack for very long paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,Usability,clear,cleared,30,// The worklist may have been cleared at this point. First; // check if it is empty before checking the last item.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Deployability,Update,Update,3,// Update the path diagnostic message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,Integrability,message,message,30,// Update the path diagnostic message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Safety,Avoid,Avoid,3,// Avoid copying the whole array because there may be a lot of reports.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:458,Modifiability,enhance,enhance,458,"//===- BugReporterVisitors.cpp - Helpers for reporting bugs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a set of BugReporter ""visitors"" which can be used to; // enhance the diagnostics reported for a bug.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:176,Availability,down,down,176,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:665,Performance,load,loaded,665,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:618,Usability,clear,clearly,618,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:28,Performance,load,load,28,// This cast represents the load we're looking for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:317,Modifiability,variab,variable,317,"// This handles the case when the dereferencing of a member reference; // happens. This is needed, because the AST for dereferencing a; // member reference looks like the following:; // |-MemberExpr; // `-DeclRefExpr; // Without this special case the notes would refer to the whole object; // (struct, class or union variable) instead of just the relevant member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:180,Performance,load,loaded,180,"// Special case: remove the final lvalue-to-rvalue cast, but do not recurse; // deeper into the sub-expression. This way we return the lvalue from which; // our pointer rvalue was loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:75,Integrability,Wrap,Wrapper,75,"// This handles null references from FieldRegions, for example:; // struct Wrapper { int &ref; };; // Wrapper w = { *(int *)0 };; // w.ref = 1;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:102,Integrability,Wrap,Wrapper,102,"// This handles null references from FieldRegions, for example:; // struct Wrapper { int &ref; };; // Wrapper w = { *(int *)0 };; // w.ref = 1;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:129,Deployability,update,updated,129,"/// Comparing internal representations of symbolic values (via; /// SVal::operator==()) is a valid way to check if the value was updated,; /// unless it's a LazyCompoundVal that may have a different internal; /// representation every time it is loaded from the state. In this function we; /// do an approximate comparison for lazy compound values, checking that they; /// are the immediate snapshots of the tracked region's bindings within the; /// node's respective states but not really checking that these snapshots; /// actually contain the same set of bindings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:245,Performance,load,loaded,245,"/// Comparing internal representations of symbolic values (via; /// SVal::operator==()) is a valid way to check if the value was updated,; /// unless it's a LazyCompoundVal that may have a different internal; /// representation every time it is loaded from the state. In this function we; /// do an approximate comparison for lazy compound values, checking that they; /// are the immediate snapshots of the tracked region's bindings within the; /// node's respective states but not really checking that these snapshots; /// actually contain the same set of bindings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:233,Modifiability,variab,variable,233,"// The declaration of the value may rely on a pointer so take its l-value.; // FIXME: As seen in VisitCommonDeclRefExpr, sometimes DeclRefExpr may; // evaluate to a FieldRegion when it refers to a declaration of a lambda; // capture variable. We most likely need to duplicate that logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:281,Testability,log,logic,281,"// The declaration of the value may rely on a pointer so take its l-value.; // FIXME: As seen in VisitCommonDeclRefExpr, sometimes DeclRefExpr may; // evaluate to a FieldRegion when it refers to a declaration of a lambda; // capture variable. We most likely need to duplicate that logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:94,Safety,avoid,avoid,94,"// Stop calculating at the current function, but always regard it as; // modifying, so we can avoid notes like this:; // void f(Foo &F) {; // F.field = 0; // note: 0 assigned to 'F.field'; // // note: returning without writing to 'F.field'; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:190,Availability,fault,fault,190,"// Optimistically suppress uninitialized value bugs that result; // from system headers having a chance to initialize the value; // but failing to do so. It's too unlikely a system header's fault.; // It's much more likely a situation in which the function has a failure; // mode that the user decided not to check. If we want to hunt such; // omitted checks, we should provide an explicit function-specific note; // describing the precondition under which the function isn't supposed to; // initialize its out-parameter, and additionally check that such; // precondition can actually be fulfilled on the current path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:263,Availability,failure,failure,263,"// Optimistically suppress uninitialized value bugs that result; // from system headers having a chance to initialize the value; // but failing to do so. It's too unlikely a system header's fault.; // It's much more likely a situation in which the function has a failure; // mode that the user decided not to check. If we want to hunt such; // omitted checks, we should provide an explicit function-specific note; // describing the precondition under which the function isn't supposed to; // initialize its out-parameter, and additionally check that such; // precondition can actually be fulfilled on the current path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:133,Modifiability,variab,variable,133,"// We make an exception for system header functions that have no branches.; // Such functions unconditionally fail to initialize the variable.; // If they call other functions that have more paths within them,; // this suppression would still apply when we visit these inner functions.; // One common example of a standard function that doesn't ever initialize; // its out parameter is operator placement new; it's up to the follow-up; // constructor (if any) to initialize the memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:16,Integrability,message,message,16,// Only print a message at the interesting return statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,Availability,avail,available,82,"// Okay, we're at the right return statement, but do we have the return; // value available?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:24,Integrability,message,message,24,// Build an appropriate message based on the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:195,Modifiability,variab,variable,195,"// If we ever directly evaluate global DeclStmts, this assertion will be; // invalid, but this still seems preferable to silently accepting an; // initialization that may be for a path-sensitive variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:55,Testability,assert,assertion,55,"// If we ever directly evaluate global DeclStmts, this assertion will be; // invalid, but this still seems preferable to silently accepting an; // initialization that may be for a path-sensitive variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:136,Modifiability,evolve,evolve,136,// Pop the stored field regions and apply them to the origin; // object in the same order we had them on the copy.; // OriginField will evolve like 'b' -> 'b.y' -> 'b.y.e'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:32,Modifiability,variab,variable,32,"// If this is a call entry, the variable should be a parameter.; // FIXME: Handle CXXThisRegion as well. (This is not a priority because; // 'this' should never be NULL, but this visitor isn't just for NULL and; // UndefinedVal.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,Integrability,wrap,wrapped,82,"// If this is a CXXTempObjectRegion, the Expr responsible for its creation; // is wrapped inside of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:71,Modifiability,variab,variable,71,"// If we have init expression, it might be simply a reference; // to a variable, so we can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:43,Usability,simpl,simply,43,"// If we have init expression, it might be simply a reference; // to a variable, so we can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:347,Usability,simpl,simple,347,"// Otherwise, if the current region does indeed contain the value; // we are looking for, we can look for a region where this value; // was before.; //; // It can be useful for situations like:; // new = identity(old); // where the analyzer knows that 'identity' returns the value of its; // first argument.; //; // NOTE: If the region R is not a simple var region, it can contain; // V in one of its subregions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Integrability,message,message,54,"// Okay, we've found the binding. Emit an appropriate message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:191,Availability,error,error,191,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:46,Integrability,depend,dependency,46,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:285,Integrability,depend,dependency,285,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:135,Testability,assert,assert,135,"// For the following condition the following CFG would be built:; //; // ------------->; // / \; // [B1] -> [B2] -> [B3] -> [sink]; // assert(A && B || C); \ \; // -----------> [go on with the execution]; //; // It so happens that CFGBlock::getTerminatorCondition returns 'A' for block; // B1, 'A && B' for B2, and 'A && B || C' for B3. Let's check whether we; // reached the end of the condition!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:36,Integrability,depend,dependencies,36,// We can only reason about control dependencies within the same stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:9,Performance,Cache,Cache,9,// TODO: Cache CFGBlocks for each ExplodedNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:178,Security,access,accesses,178,"// FIXME: There's a hack in our Store implementation that always computes; // field offsets around null pointers as if they are always equal to 0.; // The idea here is to report accesses to fields as null dereferences; // even though the pointer value that's being dereferenced is actually; // the offset of the field rather than exactly 0.; // See the FIXME in StoreManager's getLValueFieldOrIvar() method.; // This code interacts heavily with this hack; otherwise the value; // would not be null at all for most fields, so we'd be unable to track it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Integrability,message,message,54,"// Okay, we've found the binding. Emit an appropriate message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:102,Integrability,depend,dependencies,102,"// We only track expressions if we believe that they are important. Chances; // are good that control dependencies to the tracking point are also; // important because of this, let's explain why we believe control reached; // this point.; // TODO: Shouldn't we track control dependencies of every bug location,; // rather than only tracked expressions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:275,Integrability,depend,dependencies,275,"// We only track expressions if we believe that they are important. Chances; // are good that control dependencies to the tracking point are also; // important because of this, let's explain why we believe control reached; // this point.; // TODO: Shouldn't we track control dependencies of every bug location,; // rather than only tracked expressions?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:7,Integrability,message,message,7,"// The message send could be nil due to the receiver being nil.; // At this point in the path, the receiver should be live since we are at; // the message send expr. If it is nil, start tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:147,Integrability,message,message,147,"// The message send could be nil due to the receiver being nil.; // At this point in the path, the receiver should be live since we are at; // the message send expr. If it is nil, start tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,Modifiability,variab,variable,54,"// See if the expression we're interested refers to a variable.; // If so, we can track both its contents and constraints on its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:17,Modifiability,variab,variable,17,// Mark both the variable region and its contents as interesting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:104,Integrability,message,message,104,"// The receiver was nil, and hence the method was skipped.; // Register a BugReporterVisitor to issue a message telling us how; // the receiver was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:11,Integrability,message,message,11,// Issue a message saying that the method was skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:23,Testability,log,logical,23,"// When we encounter a logical operator (&& or ||) as a CFG terminator,; // then the condition is actually its LHS; otherwise, we'd encounter; // the parent, such as if-statement, as a terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:32,Testability,log,logical,32,"// However, when we encounter a logical operator as a branch condition,; // then the condition is actually its RHS, because LHS would be; // the condition for the logical operator terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:163,Testability,log,logical,163,"// However, when we encounter a logical operator as a branch condition,; // then the condition is actually its RHS, because LHS would be; // the condition for the logical operator terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:126,Integrability,message,message,126,"// These will be modified in code below, but we need to preserve the original; // values in case we want to throw the generic message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:105,Testability,test,test,105,"// Check if the field name of the MemberExprs is ambiguous. Example:; // "" 'a.d' is equal to 'h.d' "" in 'test/Analysis/null-deref-path-notes.cpp'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:52,Modifiability,variab,variable,52,// Should we invert the strings if the LHS is not a variable name?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:59,Modifiability,variab,variable,59,"// FIXME: If there's already a constraint tracker for this variable,; // we shouldn't emit anything here (c.f. the double note in; // test/Analysis/inlining/path-notes.c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:134,Testability,test,test,134,"// FIXME: If there's already a constraint tracker for this variable,; // we shouldn't emit anything here (c.f. the double note in; // test/Analysis/inlining/path-notes.c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:91,Availability,fault,fault,91,"// Skip reports within the 'std' namespace. Although these can sometimes be; // the user's fault, we currently don't report them very well, and; // Note that this will not help for any other data structure libraries, like; // TR1, Boost, or llvm/ADT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:31,Performance,queue,queue,31,// Skip reports within the sys/queue.h macros as we do not have the ability to; // reason about data structure shapes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:40,Integrability,interface,interface,40,"//===- BugSuppression.cpp - Suppression interface -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:73,Security,hash,hashtags,73,"// FIXME: Implement diagnostic identifier arguments; // (checker names, ""hashtags"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:73,Security,hash,hashtags,73,"// FIXME: Implement diagnostic identifier arguments; // (checker names, ""hashtags"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:44,Testability,test,tests,44,"// SourceManager::isBeforeInTranslationUnit tests for strict; // inequality, when we need a non-strict comparison (bug; // can be reported directly on the annotated note).; // For this reason, we use the following equivalence:; //; // A <= B <==> !(B < A); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:79,Modifiability,variab,variable,79,"// Bug location could be somewhere in the init value of; // a freshly declared variable. Even though it looks like the; // user applied attribute to a statement, it will apply to a; // variable declaration, and this is where we check for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:185,Modifiability,variab,variable,185,"// Bug location could be somewhere in the init value of; // a freshly declared variable. Even though it looks like the; // user applied attribute to a statement, it will apply to a; // variable declaration, and this is where we check for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:69,Integrability,wrap,wrapper,69,"// When we apply attributes to statements, it actually creates; // a wrapper statement that only contains attributes and the wrapped; // statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:125,Integrability,wrap,wrapped,125,"// When we apply attributes to statements, it actually creates; // a wrapper statement that only contains attributes and the wrapped; // statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:551,Performance,perform,performance,551,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:604,Performance,cache,cache,604,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:580,Safety,avoid,avoid,580,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:96,Usability,simpl,simply,96,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:341,Usability,simpl,simply,341,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp:19,Integrability,Message,Message,19,// FIXME: Add ObjC Message support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallDescription.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Integrability,Wrap,Wrapper,23,"//===- CallEvent.cpp - Wrapper for all function and method calls ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file defines CallEvent and its subclasses, which represent path-; /// sensitive instances of different kinds of function and method calls; /// (C, C++, and Objective-C).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Availability,Recover,Recover,3,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Safety,Recover,Recover,3,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:8,Availability,recover,recover,8,// Also recover CFG index by scanning the CFG block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:8,Safety,recover,recover,8,// Also recover CFG index by scanning the CFG block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:109,Modifiability,extend,extended,109,"// If a function accepts an object by argument (which would of course be a; // temporary that isn't lifetime-extended), invalidate the object itself,; // not only other objects reachable from it. This is necessary because the; // destructor has access to the temporary object after the call.; // TODO: Support placement arguments once we start; // constructing them directly.; // TODO: This is unnecessary when there's no destructor, but that's; // currently hard to figure out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:245,Security,access,access,245,"// If a function accepts an object by argument (which would of course be a; // temporary that isn't lifetime-extended), invalidate the object itself,; // not only other objects reachable from it. This is necessary because the; // destructor has access to the temporary object after the call.; // TODO: Support placement arguments once we start; // constructing them directly.; // TODO: This is unnecessary when there's no destructor, but that's; // currently hard to figure out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:150,Modifiability,variab,variables,150,"// Invalidate designated regions using the batch invalidation API.; // NOTE: Even if RegionsToInvalidate is empty, we may still invalidate; // global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:453,Integrability,depend,dependent,453,"// Blocks are difficult because the return type may not be stored in the; // BlockDecl itself. The AST should probably be enhanced, but for now we; // just do what we can.; // If the block is declared without an explicit argument list, the; // signature-as-written just includes the return type, not the entire; // function type.; // FIXME: All blocks should have signatures-as-written, even if the return; // type is inferred. (That's signified with a dependent result type.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:122,Modifiability,enhance,enhanced,122,"// Blocks are difficult because the return type may not be stored in the; // BlockDecl itself. The AST should probably be enhanced, but for now we; // just do what we can.; // If the block is declared without an explicit argument list, the; // signature-as-written just includes the return type, not the entire; // function type.; // FIXME: All blocks should have signatures-as-written, even if the return; // type is inferred. (That's signified with a dependent result type.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Integrability,Wrap,Wrap,3,// Wrap it with compound value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:72,Usability,simpl,simply,72,"// If the function has fewer parameters than the call has arguments, we simply; // do not bind any values to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:42,Availability,error,error,42,"// A newly created definition, but we had error(s) during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:197,Availability,down,down,197,"// We might not even get the original statically-resolved method due to; // some particularly nasty casting (e.g. casts to sister classes).; // However, we should at least be able to search up and down our own class; // hierarchy, and some real bugs have been caught by checking this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:132,Deployability,update,update,132,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:253,Testability,assert,assert,253,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:313,Testability,assert,assert,313,"// FIXME: This is checking that our DynamicTypeInfo is at least as good as; // the static type. However, because we currently don't update; // DynamicTypeInfo when an object is cast, we can't actually be sure the; // DynamicTypeInfo is up to date. This assert should be re-enabled once; // this is fixed.; //; // assert(!MD->getParent()->isDerivedFrom(RD) && ""Bad DynamicTypeInfo"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:48,Security,access,accessing,48,// FIXME: CallEvent maybe shouldn't be directly accessing StoreManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:116,Security,access,access,116,"// C++11 [expr.call]p1: ...If the selected function is non-virtual, or if the; // id-expression in the class member access expression is a qualified-id,; // that function is called. Otherwise, its final overrider in the dynamic type; // of the object expression is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:97,Testability,log,logic,97,// Base destructors are always called non-virtually.; // Skip CXXInstanceCall's devirtualization logic in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:85,Modifiability,variab,variable,85,"// If the method call is a setter for property known to be backed by; // an instance variable, don't invalidate the entire receiver, just; // the storage for that instance variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:172,Modifiability,variab,variable,172,"// If the method call is a setter for property known to be backed by; // an instance variable, don't invalidate the entire receiver, just; // the storage for that instance variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:15,Integrability,message,message,15,// An instance message with no expression means we are sending to super.; // In this case the object reference is the same as 'self'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Security,access,accessed,23,// Look for properties accessed with property syntax (foo.bar = ...),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,Security,access,accessed,23,// Look for properties accessed with method syntax ([foo setBar:...]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:16,Integrability,interface,interface,16,"// If the class interface is declared inside the main file, assume it is not; // subcassed.; // TODO: It could actually be subclassed if the subclass is private as well.; // This is probably very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:24,Security,access,accessors,24,// Assume that property accessors are not overridden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:787,Deployability,release,release,787,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:366,Modifiability,variab,variable,366,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:112,Performance,cache,cache,112,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:334,Performance,cache,cache,334,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:451,Performance,cache,cache,451,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:584,Performance,concurren,concurrency,584,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:609,Performance,load,loading,609,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:240,Testability,test,test,240,"// Repeatedly calling lookupPrivateMethod() is expensive, especially; // when in many cases it returns null. We cache the results so; // that repeated queries on the same ObjCIntefaceDecl and Selector; // don't incur the same cost. On some test cases, we can see the; // same query being issued thousands of times.; //; // NOTE: This cache is essentially a ""global"" variable, but it; // only gets lazily created when we get here. The value of the; // cache probably comes from it being global across ExprEngines,; // where the same queries may get issued. If we are worried about; // concurrency, or possibly loading/unloading ASTs, etc., we may; // need to revisit this someday. In terms of memory, this table; // stays around until clang quits, which also may be bad if we; // need to release memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:38,Performance,cache,cache,38,// Query lookupPrivateMethod() if the cache does not hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:93,Integrability,message,messages,93,// It can be actually class methods called with Class object as a; // receiver. This type of messages is treated by the compiler as; // instance (not class).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp:94,Performance,perform,perform,94,"// To avoid false positives (Ex: finding user defined functions with; // similar names), only perform fuzzy name matching when it's a builtin.; // Using a string compare is slow, we might want to switch on BuiltinID here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp:6,Safety,avoid,avoid,6,"// To avoid false positives (Ex: finding user defined functions with; // similar names), only perform fuzzy name matching when it's a builtin.; // Using a string compare is slow, we might want to switch on BuiltinID here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:55,Performance,cache,cache,55,// Find the checkers that should run for this Decl and cache them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Deployability,Update,Update,3,// Update which NodeSet is the current one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:50,Integrability,message,messages,50,// namespace; /// Run checkers for visiting obj-c messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:35,Performance,load,load,35,// namespace; /// Run checkers for load/store of a location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:6,Deployability,release,release,6,// on release don't check that no other checker also evals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:56,Integrability,message,message,56,// Create a temporary stream to see whether we have any message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Integrability,Inject,Inject,3,// Inject the ending and a new line,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Security,Inject,Inject,3,// Inject the ending and a new line,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:23,Integrability,message,message,23,// then begin the next message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:41,Integrability,message,message,41,// See whether the current checker has a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:41,Integrability,message,message,41,// See whether the current checker has a message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:55,Performance,cache,cache,55,// Find the checkers that should run for this Stmt and cache them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp:41,Availability,avail,available,41,"//===- CheckerRegistry.h - Maintains all available checkers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp:16,Availability,avail,available,16,// FIXME: Print available packages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerRegistryData.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:405,Integrability,interface,interface,405,"//===- ConstraintManager.cpp - Constraints on symbolic values. ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defined the interface to manage constraints on symbolic values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:176,Safety,avoid,avoid,176,"// Assume functions might recurse (see `reAssume` or `tryRearrange`). During; // the recursion the State might not change anymore, that means we reached a; // fixpoint.; // We avoid infinite recursion of assume calls by checking already visited; // States on the stack of assume function calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:34,Integrability,contract,contract,34,"// Checkers might rely on the API contract that both returned states; // cannot be null. Thus, we return StInfeasible for both branches because; // it might happen that a Checker uncoditionally uses one of them if the; // other is a nullptr. This may also happen with the non-dual and; // adjacent `assume(true)` and `assume(false)` calls. By implementing; // assume in therms of assumeDual, we can keep our API contract there as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:412,Integrability,contract,contract,412,"// Checkers might rely on the API contract that both returned states; // cannot be null. Thus, we return StInfeasible for both branches because; // it might happen that a Checker uncoditionally uses one of them if the; // other is a nullptr. This may also happen with the non-dual and; // adjacent `assume(true)` and `assume(false)` calls. By implementing; // assume in therms of assumeDual, we can keep our API contract there as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:3,Performance,Perform,Perform,3,// Perform the transition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:54,Usability,simpl,simplify,54,// FIXME: Use constant-folding in CFG construction to simplify this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:55,Testability,log,logic,55,// Generate a node for each of the successors.; // Our logic for EH analysis can certainly be improved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:152,Modifiability,variab,variable,152,"// In the case of ObjCForCollectionStmt, it appears twice in a CFG:; //; // (1) inside a basic block, which represents the binding of the; // 'element' variable to a value.; // (2) in a terminator, which represents the branch.; //; // For (1), ExprEngine will bind a value (i.e., 0 or 1) indicating; // whether or not collection contains any more elements. We cannot; // just test to see if the element is nil because a container can; // contain nil elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp:376,Testability,test,test,376,"// In the case of ObjCForCollectionStmt, it appears twice in a CFG:; //; // (1) inside a basic block, which represents the binding of the; // 'element' variable to a value.; // (2) in a terminator, which represents the branch.; //; // For (1), ExprEngine will bind a value (i.e., 0 or 1) indicating; // whether or not collection contains any more elements. We cannot; // just test to see if the element is nil because a container can; // contain nil elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CoreEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:1176,Safety,safe,safe,1176,"// First, we only consider nodes for reclamation of the following; // conditions apply:; //; // (1) 1 predecessor (that has one successor); // (2) 1 successor (that has one predecessor); //; // If a node has no successor it is on the ""frontier"", while a node; // with no predecessor is a root.; //; // After these prerequisites, we discard all ""filler"" nodes that; // are used only for intermediate processing, and are not essential; // for analyzer history:; //; // (a) PreStmtPurgeDeadSymbols; //; // We then discard all other nodes where *all* of the following conditions; // apply:; //; // (3) The ProgramPoint is for a PostStmt, but not a PostStore.; // (4) There is no 'tag' for the ProgramPoint.; // (5) The 'store' is the same as the predecessor.; // (6) The 'GDM' is the same as the predecessor.; // (7) The LocationContext is the same as the predecessor.; // (8) Expressions that are *not* lvalue expressions.; // (9) The PostStmt isn't for a non-consumed Stmt or Expr.; // (10) The successor is neither a CallExpr StmtPoint nor a CallEnter or; // PreImplicitCall (so that we would be able to find it when retrying a; // call with no inlining).; // FIXME: It may be safe to reclaim PreCall and PostCall nodes as well.; // Conditions 1 and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:347,Energy Efficiency,allocate,allocated,347,"//===----------------------------------------------------------------------===//; // ExplodedNode.; //===----------------------------------------------------------------------===//; // An NodeGroup's storage type is actually very much like a TinyPtrVector:; // it can be either a pointer to a single ExplodedNode, or a pointer to a; // BumpVector allocated with the ExplodedGraph's allocator. This allows the; // common case of single-node NodeGroups to be implemented with no extra memory.; //; // Consequently, each of the NodeGroup methods have up to four cases to handle:; // 1. The flag is set and this group does not actually contain any nodes.; // 2. The group is empty, in which case the storage value is null.; // 3. The group contains a single node.; // 4. The group contains more than one node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:89,Modifiability,Refactor,Refactor,89,"// Otherwise, see if the node's program point directly points to a statement.; // FIXME: Refactor into a ProgramPoint method?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:616,Security,access,access,616,"// When modeling a C++ constructor, for a variety of reasons we need to track; // the location of the object for the duration of its ConstructionContext.; // ObjectsUnderConstruction maps statements within the construction context; // to the object's location, so that on every such statement the location; // could have been retrieved.; /// ConstructedObjectKey is used for being able to find the path-sensitive; /// memory region of a freshly constructed object while modeling the AST node; /// that syntactically represents the object that is being constructed.; /// Semantics of such nodes may sometimes require access to the region that's; /// not otherwise present in the program state, or to the very fact that; /// the construction context was present and contained references to these; /// AST nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:225,Deployability,continuous,continuous,225,"// This trait is responsible for storing the index of the element that is to be; // constructed in the next iteration. As a result a CXXConstructExpr is only; // stored if it is array type. Also the index is the index of the continuous; // memory region, which is important for multi-dimensional arrays. E.g:: int; // arr[2][2]; assume arr[1][1] will be the next element under construction, so; // the index is 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:715,Integrability,rout,route,715,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:217,Modifiability,extend,extended,217,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:90,Security,access,accesses,90,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Availability,recover,recover,10,// Try to recover some path sensitivity in case we couldn't; // compute the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Safety,recover,recover,10,// Try to recover some path sensitivity in case we couldn't; // compute the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:113,Testability,log,logic,113,//===----------------------------------------------------------------------===//; // Top-level transfer function logic (Dispatcher).; //===----------------------------------------------------------------------===//; /// evalAssume - Called by ConstraintManager. Used to call checker-specific; /// logic for handling assumptions on symbolic values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:297,Testability,log,logic,297,//===----------------------------------------------------------------------===//; // Top-level transfer function logic (Dispatcher).; //===----------------------------------------------------------------------===//; /// evalAssume - Called by ConstraintManager. Used to call checker-specific; /// logic for handling assumptions on symbolic values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:77,Performance,load,load,77,// Handle arrays of trivial type. We can represent this with a; // primitive load/copy from the base array region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:192,Modifiability,variab,variables,192,"// FIXME: This should not happen. The language guarantees a presence; // of a valid initializer here, so the reference shall not be undefined.; // It seems that we're calling destructors over variables that; // were not initialized yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:43,Testability,assert,assertions,43,// Still handle this case if we don't have assertions enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:43,Testability,assert,assertions,43,// Still handle this case if we don't have assertions enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:65,Safety,avoid,avoid,65,"// FIXME: If we have no MR, we still need to unwrap the array to avoid; // destroying the whole array at once.; //; // For this case there is no universal solution as there is no way to; // directly create an array of temporary objects. There are some expressions; // however which can create temporary objects and have an array type.; //; // E.g.: std::initializer_list<S>{S(), S()};; //; // The expression above has a type of 'const struct S[2]' but it's a single; // 'std::initializer_list<>'. The destructors of the 2 temporary 'S()'; // objects will be called anyway, because they are 2 separate objects in 2; // separate clusters, i.e.: not an array.; //; // Now the 'std::initializer_list<>' is not an array either even though it; // has the type of an array. The point is, we only want to invoke the; // destructor for the initializer list once not twice or so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:40,Usability,simpl,simply,40,// Cases that should never be evaluated simply because they shouldn't; // appear in the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Performance,cache,cache,10,// Did we cache out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:68,Safety,abort,abort,68,// FIXME: This is not complete. We basically treat @throw as; // an abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:130,Performance,cache,cache,130,"// Add the special flag to GDM to signal retrying with no inlining.; // Note, changing the state ensures that we are not going to cache out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:6,Performance,cache,cached,6,"// We cached out at this point. Caching out is common due to us backtracking; // from the inlined function, which might spawn several paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:21,Deployability,Update,Update,21,/// Block entrance. (Update counters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Modifiability,Refactor,Refactor,10,// FIXME: Refactor this into a checker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Availability,Recover,RecoverCastedSymbol,191,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:277,Availability,recover,recover,277,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:513,Modifiability,extend,extend,513,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Safety,Recover,RecoverCastedSymbol,191,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:277,Safety,recover,recover,277,//===----------------------------------------------------------------------===//; // Branch processing.; //===----------------------------------------------------------------------===//; /// RecoverCastedSymbol - A helper function for ProcessBranch that is used; /// to try to recover some path-sensitivity for casts of symbolic; /// integers that promote their values (which are currently not tracked well).; /// This function returns the SVal bound to Condition->IgnoreCasts if all the; // cast(s) did was sign-extend the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:54,Integrability,depend,depends,54,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:379,Performance,optimiz,optimized,379,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:811,Performance,cache,cache,811,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:334,Testability,log,logical,334,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:480,Testability,log,logical,480,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:7,Testability,log,logical,7,"// For logical operations, we still have the case where some branches; // use the traditional ""merge"" approach and others sink the branch; // directly into the basic blocks representing the logical operation.; // We need to distinguish between those two cases here.; // The invariants are still shifting, but it is possible that the; // last element in a CFGBlock is not a CFGStmt. Look for the last; // CFGStmt as the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Testability,log,logical,190,"// For logical operations, we still have the case where some branches; // use the traditional ""merge"" approach and others sink the branch; // directly into the basic blocks representing the logical operation.; // We need to distinguish between those two cases here.; // The invariants are still shifting, but it is possible that the; // last element in a CFGBlock is not a CFGStmt. Look for the last; // CFGStmt as the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,Availability,recover,recover,23,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,Safety,recover,recover,23,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Availability,recover,recover,10,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Availability,recover,recover,190,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,Safety,recover,recover,10,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:190,Safety,recover,recover,190,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:51,Modifiability,variab,variables,51,/// The GDM component containing the set of global variables which have been; /// previously initialized with explicit initializers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:86,Modifiability,extend,extended,86,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:30,Testability,assert,assert,30,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:385,Testability,assert,asserting,385,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:58,Usability,clear,clear,58,"// FIXME: We currently cannot assert that temporaries are clear, because; // lifetime extended temporaries are not always modelled correctly. In some; // cases when we materialize the temporary, we do; // createTemporaryRegionIfNeeded(), and the region changes, and also the; // respective destructor becomes automatic from temporary. So for now clean up; // the state manually before asserting. Ideally, this braced block of code; // should go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:3,Performance,Perform,Perform,3,// Perform the transition with cleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:105,Performance,Load,Loads,105,//===----------------------------------------------------------------------===//; // Transfer functions: Loads and stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:114,Usability,simpl,simply,114,"// C permits ""extern void v"", and if you cast the address to a valid type,; // you can even do things with it. We simply pretend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:73,Modifiability,variab,variable,73,// Sema follows a sequence of complex rules to determine whether the; // variable should be captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:58,Security,access,accesses,58,/// VisitArraySubscriptExpr - Transfer function for array accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:24,Modifiability,variab,variables,24,// Handle static member variables and enum constants accessed via; // member syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:53,Security,access,accessed,53,// Handle static member variables and enum constants accessed via; // member syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:41,Modifiability,variab,variables,41,// Handle regular struct fields / member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:126,Integrability,wrap,wrapped,126,"// We special-case rvalues of array type because the analyzer cannot; // reason about them, since we expect all regions to be wrapped in Locs.; // We instead treat these as lvalues and assume that they will decay to; // pointers as soon as they are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:25,Testability,test,test,25,"// Case (4): in order to test that, generate a new state with the binding; // added. If it is the same state, then it escapes (since the store cannot; // represent the binding).; // Do this only if we know that the store is not supposed to generate the; // same state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:20,Performance,load,load,20,// Proceed with the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:20,Performance,perform,performance,20,// Early checks for performance reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:262,Modifiability,Variab,Variable,262,"// Associate this new state with an ExplodedNode.; // FIXME: If I pass null tag, the graph is incorrect, e.g for; // int *p;; // p = 0;; // *p = 0xDEADBEEF;; // ""p = 0"" is not noted as ""Null pointer value stored to 'p'"" but; // instead ""int *p"" is noted as; // ""Variable 'p' initialized to a null pointer value""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:153,Performance,optimiz,optimization,153,// Test if the previous node was as the same expression. This can happen; // when the expression fails to evaluate to anything meaningful and; // (as an optimization) we don't generate a node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:3,Testability,Test,Test,3,// Test if the previous node was as the same expression. This can happen; // when the expression fails to evaluate to anything meaningful and; // (as an optimization) we don't generate a node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:191,Modifiability,plug-in,plug-in,191,"// We have processed both the inputs and the outputs. All of the outputs; // should evaluate to Locs. Nuke all of their values.; // FIXME: Some day in the future it would be nice to allow a ""plug-in""; // which interprets the inline asm and stores proper results in the; // outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:64,Testability,log,logical,64,// Process non-assignments except commas or short-circuited; // logical expressions (LAnd and LOr).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:13,Performance,load,load,13,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:34,Performance,perform,performs,34,"// Perform a load (the LHS). This performs the checks for; // null dereferences, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:91,Modifiability,variab,variables,91,"// If we created a new MemRegion for the block, we should explicitly bind; // the captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:191,Modifiability,variab,variables,191,"// If the capture had a copy expression, use the result of evaluating; // that expression, otherwise use the original value.; // We rely on the invariant that the block declaration's capture variables; // are a prefix of the BlockDataRegion's referenced vars (which may include; // referenced globals, etc.) to enable fast lookup of the capture for a; // given referenced var.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:94,Deployability,release,release,94,"// The analyzer doesn't do anything special with these casts,; // since it understands retain/release semantics already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:57,Modifiability,variab,variable,57,"// C99 6.7.7 ""Any array size expressions associated with variable length; // array declarators are evaluated each time the declaration of the typedef; // name is reached in the order of execution.""; // The checkers should know about typedef to be able to handle VLA size; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:43,Modifiability,refactor,refactoring,43,//TODO:AZ: remove explicit insertion after refactoring is done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:45,Modifiability,variab,variable,45,// We constructed the object directly in the variable.; // No need to bind anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Availability,Recover,Recover,3,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Safety,Recover,Recover,3,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:822,Availability,reliab,reliable,822,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:42,Testability,log,logical,42,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:959,Testability,log,logical,959,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:151,Testability,log,logical,151,"// FIXME: We do not model vector arithmetic yet. When adding support for; // that, note that the CFG-based reasoning below does not apply, because; // logical operators on vectors are not short-circuit. Currently they are; // modeled as short-circuit in Clang CFG but this is incorrect.; // Do not set the value for the expression. It'd be UnknownVal by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:63,Testability,log,logical,63,// The only terminator (if there is one) that makes sense is a logical op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:251,Availability,robust,robust,251,"// If the state N has multiple predecessors P, it means that successors; // of P are all equivalent.; // In turn, that means that all nodes at P are equivalent in terms; // of observable behavior at N, and we can follow any of them.; // FIXME: a more robust solution which does not walk up the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:108,Modifiability,refactor,refactor,108,"// FIXME: Add support for VLA type arguments and VLA expressions.; // When that happens, we should probably refactor VLASizeChecker's code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,// Perform a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:13,Performance,load,load,13,// Perform a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,"// Perform the store, so that the uninitialized value detection happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:54,Safety,detect,detection,54,"// Perform the store, so that the uninitialized value detection happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,Availability,recover,recover,40,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,Safety,recover,recover,40,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Performance,Perform,Perform,3,// Perform the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:3,Security,Validat,Validate,3,// Validate the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:155,Safety,safe,safe,155,"// Unfortunately, Objective-C does not enforce that overridden methods have; // covariant return types, so we can't assert that that never happens.; // Be safe and return UnknownVal().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:116,Testability,assert,assert,116,"// Unfortunately, Objective-C does not enforce that overridden methods have; // covariant return types, so we can't assert that that never happens.; // Be safe and return UnknownVal().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:88,Modifiability,variab,variable,88,"// Step 2: generate node with bound return value: CEBNode -> BindedRetNode.; // If this variable is set to 'true' the analyzer will evaluate the call; // statement we are about to exit again, instead of continuing the execution; // from the statement after the call. This is useful for non-POD type array; // construction where the CXXConstructExpr is referenced only once in the CFG,; // but we want to evaluate it as many times as many elements the array has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:11,Performance,Perform,Perform,11,// Step 5: Perform the post-condition check of the CallExpr and enqueue the; // result onto the work list.; // CEENode -> Dst -> WorkList,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:3,Performance,Perform,Perform,3,// Perform the previsit of the CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:67,Performance,perform,perform,67,// Get the call in its initial state. We use this as a template to perform; // all the checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:12,Performance,perform,perform,12,"// Finally, perform the post-condition check of the CallExpr and store; // the created nodes in 'Dst'.; // Note that if the call was inlined, dstCallEvaluated will be empty.; // The post-CallExpr check will occur in processCallExit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:164,Deployability,update,updated,164,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:293,Deployability,update,updated,293,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:489,Integrability,interface,interface,489,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:114,Performance,optimiz,optimization,114,"// WARNING: At this time, the state attached to 'Call' may be older than the; // state in 'Pred'. This is a minor optimization since CheckerManager will; // use an updated CallEvent instance when calling checkers, but if 'Call' is; // ever used directly in this function all callers should be updated to pass; // the most recent state. (It is probably not worth doing the work here since; // for some callers this will not be necessary.); // Run any pre-call checks using the generic call interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:27,Energy Efficiency,allocate,allocated,27,// Store the extent of the allocated object(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:45,Safety,safe,safe,45,"// If the destructor is trivial, it's always safe to inline the constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:116,Usability,simpl,simply,116,"// If we did not find the correct this-region, it would be pointless; // to inline the constructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:32,Modifiability,extend,extended,32,"// If the temporary is lifetime-extended by binding it to a reference-type; // field within an aggregate, automatic destructors don't work properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:94,Modifiability,inherit,inherited,94,"// This doesn't really increase the cost of inlining ever, because; // the stack frame of the inherited constructor is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:115,Usability,simpl,simply,115,"// If we did not find the correct this-region, it would be pointless; // to inline the destructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:61,Safety,safe,safe,61,"// It is possible that the CFG cannot be constructed.; // Be safe, and check if the CalleeCFG is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:32,Modifiability,variab,variables,32,"// It is possible that the live variables analysis cannot be; // run. If so, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:184,Performance,cache,cached,184,"// Check if we should inline a call based on its kind.; // FIXME: this checks both static and dynamic properties of the call, which; // means we're redoing a bit of work that could be cached in the function; // summary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:124,Integrability,depend,depends,124,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:248,Safety,avoid,avoid,248,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:510,Safety,safe,safe,510,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:26,Usability,intuit,intuitive,26,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:119,Safety,safe,safe,119,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:84,Security,checksum,checksum,84,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:18,Performance,perform,performed,18,"// Check if we've performed the split already - note, we only want; // to split the path once per memory region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:55,Integrability,message,message,55,"// If we got here, this is the first time we process a message to this; // region, so split the path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:3,Performance,Load,Load,3,// Load the source value only for non-empty classes.; // Otherwise it'd retrieve an UnknownVal; // and bind it and RegionStore would think that the actual value; // in this region at this offset is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:45,Performance,load,load,45,"// If the value being copied is not unknown, load from its location to get; // an aggregate rvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:78,Usability,Simpl,SimpleReturnedValueKind,78,"// In case when the prvalue is returned from the function (kind is one of; // SimpleReturnedValueKind, CXX17ElidedCopyReturnedValueKind), then; // it's materialization happens in context of the caller.; // We pass BldrCtx explicitly, as currBldrCtx always refers to callee's context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:9,Safety,Detect,Detect,9,// TODO: Detect when the allocator returns a null pointer.; // Constructor shall not be called in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:374,Safety,avoid,avoid,374,"// We are on the top frame of the analysis. We do not know where is the; // object returned to. Conjure a symbolic region for the return value.; // TODO: We probably need a new MemRegion kind to represent the storage; // of that SymbolicRegion, so that we cound produce a fancy symbol; // instead of an anonymous conjured symbol.; // TODO: Do we need to track the region to avoid having it dead; // too early? It does die too early, at least in C++17, but because; // putting anything into a SymbolicRegion causes an immediate escape,; // it doesn't cause any leak false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:75,Usability,simpl,simple,75,// Copy elision failed. Revert the changes and proceed as if we have; // a simple temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:18,Modifiability,extend,extended,18,// We're lifetime-extended by a surrounding aggregate.; // Automatic destructors aren't quite working in this case; // on the CFG side. We should warn the caller about that.; // FIXME: Is there a better way to retrieve this information from; // the MaterializeTemporaryExpr?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:36,Availability,reliab,reliably,36,// Return early if we are unable to reliably foresee; // the future stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:129,Availability,failure,failure,129,"// If we couldn't find an existing region to construct into, assume we're; // constructing a temporary. Notify the caller of our failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:72,Usability,simpl,simple,72,"// If we decided not to elide the constructor, proceed as if; // it's a simple temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:94,Availability,error,error,94,"// The ctor in this case is guaranteed to be a copy ctor, otherwise we hit a; // compile time error.; //; // -ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-CXXConstructExpr; // `-ImplicitCastExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression might look like the one below in an implicit; // copy/move ctor.; //; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-MemberExpr <-- match this; // | (`-CXXStaticCastExpr) <-- move ctor only; // | `-DeclRefExpr; // `-CXXConstructExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-MemberExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression for a multidimensional array.; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-ArrayInitLoopExpr; // |-OpaqueValueExpr; // | `-ArraySubscriptExpr; // | |-ImplicitCastExpr; // | | `-OpaqueValueExpr; // | | `-DeclRefExpr; // | `-ArrayInitIndexExpr; // `-CXXConstructExpr <-- extract this; // ` ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:3,Modifiability,Inherit,Inherited,3,// Inherited constructors are always base class constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:659,Availability,down,down,659,"// In C++17, classes with non-virtual bases may be aggregates, so they would; // be initialized as aggregates without a constructor call, so we may have; // a base class constructed directly into an initializer list without; // having the derived-class constructor call on the previous stack frame.; // Initializer lists may be nested into more initializer lists that; // correspond to surrounding aggregate initializations.; // FIXME: For now this code essentially bails out. We need to find the; // correct target region and set it.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) passed down from CFG or; // otherwise always available during construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:697,Availability,avail,available,697,"// In C++17, classes with non-virtual bases may be aggregates, so they would; // be initialized as aggregates without a constructor call, so we may have; // a base class constructed directly into an initializer list without; // having the derived-class constructor call on the previous stack frame.; // Initializer lists may be nested into more initializer lists that; // correspond to surrounding aggregate initializations.; // FIXME: For now this code essentially bails out. We need to find the; // correct target region and set it.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) passed down from CFG or; // otherwise always available during construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:378,Modifiability,extend,extended,378,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:407,Safety,avoid,avoids,407,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:485,Testability,assert,assertions,485,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:320,Modifiability,config,config,320,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:260,Safety,avoid,avoid,260,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:234,Testability,assert,assertion,234,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:42,Usability,simpl,simply,42,// Skip the invalid destructor. We cannot simply return because; // it would interrupt the analysis instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:219,Availability,recover,recover,219,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:272,Availability,recover,recover,272,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:219,Safety,recover,recover,219,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:272,Safety,recover,recover,272,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:144,Energy Efficiency,allocate,allocated,144,"// [basic.stc.dynamic.allocation] (on the return value of an allocation; // function):; // ""The order, contiguity, and initial value of storage allocated by; // successive calls to an allocation function are unspecified.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:64,Availability,failure,failures,64,"// If this allocation function is not declared as non-throwing, failures; // /must/ be signalled by exceptions, and thus the return value will never; // be NULL. -fno-exceptions does not influence this semantics.; // FIXME: GCC has a -fcheck-new option, which forces it to consider the case; // where new can return NULL. If we end up supporting that option, we can; // consider adding a check for it here.; // C++11 [basic.stc.dynamic.allocation]p3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:58,Energy Efficiency,allocate,allocate,58,// We assume all standard global 'operator new' functions allocate memory in; // heap. We realize this is an approximation that might not correctly model; // a custom global allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:64,Availability,failure,failures,64,"// If this allocation function is not declared as non-throwing, failures; // /must/ be signalled by exceptions, and thus the return value will never; // be NULL. -fno-exceptions does not influence this semantics.; // FIXME: GCC has a -fcheck-new option, which forces it to consider the case; // where new can return NULL. If we end up supporting that option, we can; // consider adding a check for it here.; // C++11 [basic.stc.dynamic.allocation]p3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:59,Performance,cache,cached,59,"// Bind the address of the object, then check to see if we cached out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:207,Safety,detect,detecting,207,"// Capturing a 0 length array is a no-op, so we ignore it to get a more; // accurate analysis. If it's not ignored, it would set the default; // binding of the lambda to 'Unknown', which can lead to falsely detecting; // 'Uninitialized' values as 'Unknown' and not reporting a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:106,Usability,simpl,simple,106,"// With C++17 copy elision the InitExpr can be anything, so instead of; // pattern matching all cases, we simple check if the current field is; // under construction or not, regardless what it's InitExpr is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:45,Modifiability,variab,variable-length,45,// The field stores the length of a captured variable-length array.; // These captures don't have initialization expressions; instead we; // get the length from the VLAType size expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:3,Performance,Perform,Perform,3,// Perform the post-condition check of the ObjCIvarRefExpr and store; // the created nodes in 'Dst'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:108,Testability,log,logic,108,"// FIXME: The proper thing to do is to really iterate over the; // container. We will do this with dispatch logic to the store.; // For now, just 'conjure' up a symbolic value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:984,Integrability,depend,depending,984,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:463,Testability,test,tested,463,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:523,Testability,log,logic,523,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:933,Testability,test,test,933,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1209,Integrability,message,message,1209,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:976,Performance,perform,performing,976,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1571,Testability,log,logical,1571,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1682,Usability,simpl,simpler,1682,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:29,Integrability,message,message,29,// Proceed with evaluate the message expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:12,Performance,perform,perform,12,"// Finally, perform the post-condition check of the ObjCMessageExpr and store; // the created nodes in 'Dst'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the file specified by FID with HTML formatting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:335,Modifiability,config,config-compatibility-mode,335,"// FIXME: HTML is currently our default output type, but if the output; // directory isn't specified, it acts like if it was in the minimal text; // output mode. This doesn't make much sense, we should have the minimal text; // as our default. In the case of backward compatibility concerns, this could; // be preserved with -analyzer-config-compatibility-mode=true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:16,Modifiability,rewrite,rewriter,16,// Create a new rewriter to generate HTML.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:142,Modifiability,rewrite,rewrites,142,// FIXME: This causes each file to be re-parsed and syntax-highlighted; // and macro-expanded separately for each report. We could cache such rewrites; // across all reports and only re-do the part that's actually different:; // the warning/note bubbles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:131,Performance,cache,cache,131,// FIXME: This causes each file to be re-parsed and syntax-highlighted; // and macro-expanded separately for each report. We could cache such rewrites; // across all reports and only re-do the part that's actually different:; // the warning/note bubbles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:65,Security,hash,hash,65,// FIXME: This code relies on knowing what constitutes the issue hash.; // Otherwise deduplication won't work correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:136,Security,hash,hash,136,"// Existence of the file corresponds to the situation where a different; // Clang instance has emitted a bug report with the same issue hash.; // This is an entirely normal situation that does not deserve a warning,; // as apart from hash collisions this can happen because the reports; // are in fact similar enough to be considered duplicates of each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:234,Security,hash,hash,234,"// Existence of the file corresponds to the situation where a different; // Clang instance has emitted a bug report with the same issue hash.; // This is an entirely normal situation that does not deserve a warning,; // as apart from hash collisions this can happen because the reports; // are in fact similar enough to be considered duplicates of each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite source files as HTML for every new file the path crosses,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:109,Deployability,toggle,toggleHelp,109,"R""<<<(; </table>; <!-- REPORTSUMMARYEXTRA -->; <h3>Annotated Source Code</h3>; <p>Press <a href=""#"" onclick=""toggleHelp(); return false;"">'?'</a>; to see keyboard shortcuts</p>; <input type=""checkbox"" class=""spoilerhider"" id=""showinvocation"" />; <label for=""showinvocation"" >Show analyzer invocation</label>; <div class=""spoiler"">clang -cc1 )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:205,Deployability,toggle,toggle,205,"R""<<<(; </div>; <div id='tooltiphint' hidden=""true"">; <p>Keyboard shortcuts: </p>; <ul>; <li>Use 'j/k' keys for keyboard navigation</li>; <li>Use 'Shift+S' to show/hide relevant lines</li>; <li>Use '?' to toggle this window</li>; </ul>; <a href=""#"" onclick=""toggleHelp(); return false;"">Close</a>; </div>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:258,Deployability,toggle,toggleHelp,258,"R""<<<(; </div>; <div id='tooltiphint' hidden=""true"">; <p>Keyboard shortcuts: </p>; <ul>; <li>Use 'j/k' keys for keyboard navigation</li>; <li>Use 'Shift+S' to show/hide relevant lines</li>; <li>Use '?' to toggle this window</li>; </ul>; <a href=""#"" onclick=""toggleHelp(); return false;"">Close</a>; </div>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:45,Deployability,toggle,toggleHelp,45,"R""<<<(; <script type='text/javascript'>. var toggleHelp = function() {; var hint = document.querySelector(""#tooltiphint"");; var attributeName = ""hidden"";; if (hint.hasAttribute(attributeName)) {; hint.removeAttribute(attributeName);; } else {; hint.setAttribute(""hidden"", ""true"");; }; };; window.addEventListener(""keydown"", function (event) {; if (event.defaultPrevented) {; return;; }; if (event.key == ""?"") {; toggleHelp();; } else {; return;; }; event.preventDefault();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:412,Deployability,toggle,toggleHelp,412,"R""<<<(; <script type='text/javascript'>. var toggleHelp = function() {; var hint = document.querySelector(""#tooltiphint"");; var attributeName = ""hidden"";; if (hint.hasAttribute(attributeName)) {; hint.removeAttribute(attributeName);; } else {; hint.setAttribute(""hidden"", ""true"");; }; };; window.addEventListener(""keydown"", function (event) {; if (event.defaultPrevented) {; return;; }; if (event.key == ""?"") {; toggleHelp();; } else {; return;; }; event.preventDefault();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:57,Integrability,message,message,57,// Write out the path indices with a right arrow and the message as a row.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:44,Modifiability,variab,variable,44,// If no report made at this range mark the variable and add the end tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,Integrability,inject,inject,13,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,Security,inject,inject,13,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:8,Testability,assert,assertion,8,// This assertion also guarantees that all indices in are <= NumberOfArrows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:212,Integrability,message,message,212,"// Pop-up pieces needs the index of the last reported piece and its count; // how many times we report to handle multiple reports on the same range.; // This marks the variable, adds the </table> end tag and the message; // (list element) as a row. The <table> start tag will be added after the; // rows has been written out. Note: It stores every different range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:168,Modifiability,variab,variable,168,"// Pop-up pieces needs the index of the last reported piece and its count; // how many times we report to handle multiple reports on the same range.; // This marks the variable, adds the </table> end tag and the message; // (list element) as a row. The <table> start tag will be added after the; // rows has been written out. Note: It stores every different range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:27,Integrability,message,message,27,// Create the html for the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:41,Integrability,message,message,41,// Determine the approximate size of the message bubble in em.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:419,Availability,error,error,419,"R""<<<(; <script type='text/javascript'>; // Return range of numbers from a range [lower, upper).; function range(lower, upper) {; var array = [];; for (var i = lower; i <= upper; ++i) {; array.push(i);; }; return array;; }. var getRelatedArrowIndices = function(pathId) {; // HTML numeration of events is a bit different than it is in the path.; // Everything is rotated one step to the right, so the last element; // (error diagnostic) has index 0.; if (pathId == 0) {; // arrowIndices has at least 2 elements; pathId = arrowIndices.length - 1;; }. return range(arrowIndices[pathId], arrowIndices[pathId - 1]);; }. var highlightArrowsForSelectedEvent = function() {; const selectedNum = findNum();; const arrowIndicesToHighlight = getRelatedArrowIndices(selectedNum);; arrowIndicesToHighlight.forEach((index) => {; var arrow = document.querySelector(""#arrow"" + index);; if(arrow) {; classListAdd(arrow, ""selected""); }; });; }. var getAbsoluteBoundingRect = function(element) {; const relative = element.getBoundingClientRect();; return {; left: relative.left + window.pageXOffset,; right: relative.right + window.pageXOffset,; top: relative.top + window.pageYOffset,; bottom: relative.bottom + window.pageYOffset,; height: relative.height,; width: relative.width; };; }. var drawArrow = function(index) {; // This function is based on the great answer from SO:; // https://stackoverflow.com/a/39575674/11582326; var start = document.querySelector(""#start"" + index);; var end = document.querySelector(""#end"" + index);; var arrow = document.querySelector(""#arrow"" + index);. var startRect = getAbsoluteBoundingRect(start);; var endRect = getAbsoluteBoundingRect(end);. // It is an arrow from a token to itself, no need to visualize it.; if (startRect.top == endRect.top &&; startRect.left == endRect.left); return;. // Each arrow is a very simple Bézier curve, with two nodes and; // two handles. So, we need to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:2941,Availability,down,downwards,2941,"eed to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // * end node; var posEnd = { x: 0, y: 0 };; // * handle for the start node; var startHandle = { x: 0, y: 0 };; // * handle for the end node; var endHandle = { x: 0, y: 0 };; // One can visualize it as follows:; //; // start handle; // /; // X""""""_.-""""""""X; // .' \; // / start node; // |; // |; // | end node; // \ /; // `->X; // X-'; // \; // end handle; //; // NOTE: (0, 0) is the top left corner of the window. // We have 3 similar, but still different scenarios to cover:; //; // 1. Two tokens on different lines.; // -xxx; // /; // \; // -> xxx; // In this situation, we draw arrow on the left curving to the left.; // 2. Two tokens on the same line, and the destination is on the right.; // ____; // / \; // / V; // xxx xxx; // In this situation, we draw arrow above curving upwards.; // 3. Two tokens on the same line, and the destination is on the left.; // xxx xxx; // ^ /; // \____/; // In this situation, we draw arrow below curving downwards.; const onDifferentLines = startRect.top <= endRect.top - 5 ||; startRect.top >= endRect.top + 5;; const leftToRight = startRect.left < endRect.left;. // NOTE: various magic constants are chosen empirically for; // better positioning and look; if (onDifferentLines) {; // Case #1; const topToBottom = startRect.top < endRect.top;; posStart.x = startRect.left - 1;; // We don't want to start it at the top left corner of the token,; // it doesn't feel like this is where the arrow comes from.; // For this reason, we start it in the middle of the left side; // of the token.; posStart.y = startRect.top + startRect.height / 2;. // End node has arrow head and we give it a bit more space.; posEnd.x = endRect.left - 4;; posEnd.y = endRect.top;. // Utility object with x and y offsets for handles.; var curvature = {; // We want bottom-to-top arrow to curve a bit more, so it doesn't; // overlap much with top-to-bottom curves (much more frequent).; x: topT",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:4368,Availability,down,downwards,4368,"ken,; // it doesn't feel like this is where the arrow comes from.; // For this reason, we start it in the middle of the left side; // of the token.; posStart.y = startRect.top + startRect.height / 2;. // End node has arrow head and we give it a bit more space.; posEnd.x = endRect.left - 4;; posEnd.y = endRect.top;. // Utility object with x and y offsets for handles.; var curvature = {; // We want bottom-to-top arrow to curve a bit more, so it doesn't; // overlap much with top-to-bottom curves (much more frequent).; x: topToBottom ? 15 : 25,; y: Math.min((posEnd.y - posStart.y) / 3, 10); }. // When destination is on the different line, we can make a; // curvier arrow because we have space for it.; // So, instead of using; //; // startHandle.x = posStart.x - curvature.x; // endHandle.x = posEnd.x - curvature.x; //; // We use the leftmost of these two values for both handles.; startHandle.x = Math.min(posStart.x, posEnd.x) - curvature.x;; endHandle.x = startHandle.x;. // Curving downwards from the start node...; startHandle.y = posStart.y + curvature.y;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else if (leftToRight) {; // Case #2; // Starting from the top right corner...; posStart.x = startRect.right - 1;; posStart.y = startRect.top;. // ...and ending at the top left corner of the end token.; posEnd.x = endRect.left + 1;; posEnd.y = endRect.top - 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom ri",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:5684,Availability,down,downwards,5684,"left corner of the end token.; posEnd.x = endRect.left + 1;; posEnd.y = endRect.top - 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawA",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:5833,Availability,down,downwards,5833,"urvature = {; x: Math.min((posEnd.x - posStart.x) / 3, 15),; y: 5; }. // Curving to the right...; startHandle.x = posStart.x + curvature.x;; // ... and upwards from the start node.; startHandle.y = posStart.y - curvature.y;. // And to the left...; endHandle.x = posEnd.x - curvature.x;; // ... and upwards from the end node.; endHandle.y = posEnd.y - curvature.y;. } else {; // Case #3; // Starting from the bottom right corner...; posStart.x = startRect.right;; posStart.y = startRect.bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw ar",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:6435,Deployability,toggle,toggleArrows,6435,"bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw arrows.; document; .querySelector('input[id=""showinvocation""]'); .addEventListener(""click"", drawArrows);; // Hiding irrelevant lines also should cause arrow rerender.; document; .querySelector('input[name=""showCounterexample""]'); .addEventListener(""change"", drawArrows);; document; .querySelector('input[name=""showArrows""]'); .addEventListener(""change"", toggleArrows);; drawArrows();; // Default highlighting for the last event.; highlightArrowsForSelectedEvent();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:7197,Deployability,toggle,toggleArrows,7197,"bottom;. // ...and ending also at the bottom right corner, but of the end token.; posEnd.x = endRect.right - 1;; posEnd.y = endRect.bottom + 1;. // Utility object with x and y offsets for handles.; var curvature = {; x: Math.min((posStart.x - posEnd.x) / 3, 15),; y: 5; }. // Curving to the left...; startHandle.x = posStart.x - curvature.x;; // ... and downwards from the start node.; startHandle.y = posStart.y + curvature.y;. // And to the right...; endHandle.x = posEnd.x + curvature.x;; // ... and downwards from the end node.; endHandle.y = posEnd.y + curvature.y;; }. // Put it all together into a path.; // More information on the format:; // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths; var pathStr = ""M"" + posStart.x + "","" + posStart.y + "" "" +; ""C"" + startHandle.x + "","" + startHandle.y + "" "" +; endHandle.x + "","" + endHandle.y + "" "" +; posEnd.x + "","" + posEnd.y;. arrow.setAttribute(""d"", pathStr);; };. var drawArrows = function() {; const numOfArrows = document.querySelectorAll(""path[id^=arrow]"").length;; for (var i = 0; i < numOfArrows; ++i) {; drawArrow(i);; }; }. var toggleArrows = function(event) {; const arrows = document.querySelector(""#arrows"");; if (event.target.checked) {; arrows.setAttribute(""visibility"", ""visible"");; } else {; arrows.setAttribute(""visibility"", ""hidden"");; }; }. window.addEventListener(""resize"", drawArrows);; document.addEventListener(""DOMContentLoaded"", function() {; // Whenever we show invocation, locations change, i.e. we; // need to redraw arrows.; document; .querySelector('input[id=""showinvocation""]'); .addEventListener(""click"", drawArrows);; // Hiding irrelevant lines also should cause arrow rerender.; document; .querySelector('input[name=""showCounterexample""]'); .addEventListener(""change"", drawArrows);; document; .querySelector('input[name=""showArrows""]'); .addEventListener(""change"", toggleArrows);; drawArrows();; // Default highlighting for the last event.; highlightArrowsForSelectedEvent();; });; </script>; )<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:1839,Usability,simpl,simple,1839,"rrow"" + index);; if(arrow) {; classListAdd(arrow, ""selected""); }; });; }. var getAbsoluteBoundingRect = function(element) {; const relative = element.getBoundingClientRect();; return {; left: relative.left + window.pageXOffset,; right: relative.right + window.pageXOffset,; top: relative.top + window.pageYOffset,; bottom: relative.bottom + window.pageYOffset,; height: relative.height,; width: relative.width; };; }. var drawArrow = function(index) {; // This function is based on the great answer from SO:; // https://stackoverflow.com/a/39575674/11582326; var start = document.querySelector(""#start"" + index);; var end = document.querySelector(""#end"" + index);; var arrow = document.querySelector(""#arrow"" + index);. var startRect = getAbsoluteBoundingRect(start);; var endRect = getAbsoluteBoundingRect(end);. // It is an arrow from a token to itself, no need to visualize it.; if (startRect.top == endRect.top &&; startRect.left == endRect.left); return;. // Each arrow is a very simple Bézier curve, with two nodes and; // two handles. So, we need to calculate four points in the window:; // * start node; var posStart = { x: 0, y: 0 };; // * end node; var posEnd = { x: 0, y: 0 };; // * handle for the start node; var startHandle = { x: 0, y: 0 };; // * handle for the end node; var endHandle = { x: 0, y: 0 };; // One can visualize it as follows:; //; // start handle; // /; // X""""""_.-""""""""X; // .' \; // / start node; // |; // |; // | end node; // \ /; // `->X; // X-'; // \; // end handle; //; // NOTE: (0, 0) is the top left corner of the window. // We have 3 similar, but still different scenarios to cover:; //; // 1. Two tokens on different lines.; // -xxx; // /; // \; // -> xxx; // In this situation, we draw arrow on the left curving to the left.; // 2. Two tokens on the same line, and the destination is on the right.; // ____; // / \; // / V; // xxx xxx; // In this situation, we draw arrow above curving upwards.; // 3. Two tokens on the same line, and the destination is on the le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:143,Integrability,depend,depending,143,"// namespace; // The tracked stack of loops. The stack indicates that which loops the; // simulated element contained by. The loops are marked depending if we decided; // to unroll them.; // TODO: The loop stack should not need to be in the program state since it is; // lexical in nature. Instead, the stack of loops should be tracked in the; // LocationContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:30,Usability,simpl,simple,30,// Incrementation should be a simple increment or decrement; // operator call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:71,Modifiability,variab,variable,71,// A loop counter is considered escaped if:; // case 1: It is a global variable.; // case 2: It is a reference parameter or a reference capture.; // case 3: It is assigned to a non-const reference variable or parameter.; // case 4: Has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:197,Modifiability,variab,variable,197,// A loop counter is considered escaped if:; // case 1: It is a global variable.; // case 2: It is a reference parameter or a reference capture.; // case 3: It is assigned to a non-const reference variable or parameter.; // case 4: Has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:3,Deployability,update,updateLoopStack,3,"// updateLoopStack is called on every basic block, therefore it needs to be fast",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Modifiability,variab,variable,43,// Obtain array indices to add them to the variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Modifiability,variab,variable,43,"// If not a ConcreteInt, try to obtain the variable; // name by calling 'getDescriptiveName' recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:7,Modifiability,variab,variable,7,// Get variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:28,Modifiability,flexible,flexible,28,"// We currently don't model flexible array members (FAMs), which are:; // - int array[]; of IncompleteArrayType; // - int array[0]; of ConstantArrayType with size 0; // - int array[1]; of ConstantArrayType with size 1; // https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:43,Usability,Simpl,SimpleSValBuilder,43,// FIXME: The following are being used in 'SimpleSValBuilder' and in; // 'ArrayBoundChecker::checkLocation' because there is no symbol to; // represent the regions more appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:146,Modifiability,variab,variable,146,"/// Look through a chain of LocationContexts to either find the; /// StackFrameContext that matches a DeclContext, or find a VarRegion; /// for a variable captured by a block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:32,Energy Efficiency,efficient,efficient,32,// FIXME: This can be made more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:74,Integrability,depend,depending,74,// ARC managed blocks can be initialized on stack or directly in heap; // depending on the implementations. So we initialize them with; // UnknownRegion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:3,Deployability,Update,Update,3,// Update the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:118,Availability,down,down,118,"// Note that we do NOT canonicalize the base class here, because; // ASTRecordLayout doesn't either. If that leads us down the wrong path,; // so be it; at least we won't crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:8,Modifiability,layers,layers,8,"// Base layers on symbolic regions may not be type-correct.; // Double-check the inheritance here, and revert to a symbolic offset; // if it's invalid (e.g. due to a reinterpret_cast).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:81,Modifiability,inherit,inheritance,81,"// Base layers on symbolic regions may not be type-correct.; // Double-check the inheritance here, and revert to a symbolic offset; // if it's invalid (e.g. due to a reinterpret_cast).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:219,Integrability,depend,depend,219,"// We cannot compute offset for incomplete type.; // For unions, we could treat everything as offset 0, but we'd rather; // treat each field as a symbolic offset so they aren't stored on top; // of each other, since we depend on things in typed regions actually; // matching their types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:168,Testability,log,logic,168,// Make the ranges of the start and end point self-consistent with adjacent edges; // by forcing to use only the beginning of the range. This simplifies the layout; // logic for clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:142,Usability,simpl,simplifies,142,// Make the ranges of the start and end point self-consistent with adjacent edges; // by forcing to use only the beginning of the range. This simplifies the layout; // logic for clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:18,Security,hash,hash,18,"// Output the bug hash for issue unique-ing. Currently, it's just an; // offset from the beginning of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:56,Security,hash,hash,56,"// If the bug uniqueing location exists, use it for the hash.; // For example, this ensures that two leaks reported on the same line; // will have different issue_hashes and that the hash will identify; // the leak location even after code is added between the allocation; // site and the end of scope (leak report location).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:183,Security,hash,hash,183,"// If the bug uniqueing location exists, use it for the hash.; // For example, this ensures that two leaks reported on the same line; // will have different issue_hashes and that the hash will identify; // the leak location even after code is added between the allocation; // site and the end of scope (leak report location).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:10,Availability,alive,alive,10,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:269,Availability,Error,Error,269,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:235,Testability,test,test,235,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:60,Modifiability,Variab,VariableBindings,60,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:25,Performance,perform,performs,25,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp:393,Performance,perform,performance,393,"// This code essentially performs a ""mark-and-sweep"" of the VariableBindings.; // The roots are any Block-level exprs and Decls that our liveness algorithm; // tells us are live. We then see what Decls they may reference, and keep; // those around. This code more than likely can be made faster, and the; // frequency of which this method is called should be experimented with; // for optimum performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ProgramState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:445,Usability,simpl,simple,445,"//== RangeConstraintManager.cpp - Manage range constraints.------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines RangeConstraintManager, a class that tracks simple; // equality and inequality constraints on symbolic values of ProgramState.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:21,Modifiability,extend,extended,21,// This class can be extended with other tables which will help to reason; // about ranges more precisely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:85,Safety,avoid,avoid,85,"// Handle a corner case first when both range sets start from MIN.; // This helps to avoid complicated conditions below. Specifically, this; // particular check for `MIN` is not needed in the loop below every time; // when we do `Second->From() - One` operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:96,Energy Efficiency,allocate,allocated,96,// It is cheaper to fully construct the resulting range on stack; // and move it to the freshly allocated buffer if we don't have; // a set like this already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:64,Testability,test,testing,64,"// This function has nine cases, the cartesian product of range-testing; // both the upper and lower bounds against the symbol's type.; // Each case requires a different pinning operation.; // The function returns false if the described range is entirely outside; // the range of values for the associated symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:25,Integrability,wrap,wraps,25,"// However, if the range wraps around, it spans all possible values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Integrability,wrap,wraps,13,"// The range wraps around, but all lower values are not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,Integrability,wrap,wrap,28,"// The range may or may not wrap around, but both limits are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Integrability,wrap,wraps,13,// The range wraps but is outside the symbol's set of possible values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:62,Integrability,wrap,wrap,62,// The range starts above what's possible but ends within it (wrap).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:25,Integrability,wrap,wraps,25,"// However, if the range wraps around, it spans all possible values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:14,Performance,optimiz,optimization,14,// This is an optimization for a specific case when this Range covers; // the whole range of the target type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:437,Energy Efficiency,efficient,efficiently,437,"/// This class encapsulates a set of symbols equal to each other.; ///; /// The main idea of the approach requiring such classes is in narrowing; /// and sharing constraints between symbols within the class. Also we can; /// conclude that there is no practical need in storing constraints for; /// every member of the class separately.; ///; /// Main terminology:; ///; /// * ""Equivalence class"" is an object of this class, which can be efficiently; /// compared to other classes. It represents the whole class without; /// storing the actual in it. The members of the class however can be; /// retrieved from the state.; ///; /// * ""Class members"" are the symbols corresponding to the class. This means; /// that A == B for every member symbols A and B from the class. Members of; /// each class are stored in the state.; ///; /// * ""Trivial class"" is a class that has and ever had only one same symbol.; ///; /// * ""Merge operation"" merges two classes into one. It is the main operation; /// to produce non-trivial classes.; /// If, at some point, we can assume that two symbols from two distinct; /// classes are equal, we can merge these classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:426,Performance,perform,performance,426,"/// Return true if the current class is trivial in the given state.; /// A class is trivial if and only if there is not any member relations stored; /// to it in State/ClassMembers.; /// An equivalence class with one member might seem as it does not hold any; /// meaningful information, i.e. that is a tautology. However, during the; /// removal of dead symbols we do not remove classes with one member for; /// resource and performance reasons. Consequently, a class with one member is; /// not necessarily trivial. It could happen that we have a class with two; /// members and then during the removal of dead symbols we remove one of its; /// members. In this case, the class is still non-trivial (it still has the; /// mappings in ClassMembers), even though it has only one member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:40,Usability,simpl,simplify,40,/// Iterate over all symbols and try to simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:233,Safety,detect,detecting,233,//===----------------------------------------------------------------------===//; // Equality/diseqiality abstraction; //===----------------------------------------------------------------------===//; /// A small helper function for detecting symbolic (dis)equality.; ///; /// Equality check can have different forms (like a == b or a - b) and this; /// class encapsulates those away if the only thing the user wants to check -; /// whether it's equality/diseqiality or not.; ///; /// \returns true if assuming this Sym to be true means equality of operands; /// false if it means disequality of operands; /// std::nullopt otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:66,Usability,simpl,simply,66,"// If the list contains only RangeSet or std::optional<RangeSet>, simply; // return that range set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:215,Availability,Avail,Available,215,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:558,Integrability,depend,depends,558,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:701,Usability,simpl,simply,701,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:104,Testability,log,logic,104,"//===----------------------------------------------------------------------===//; // Symbolic reasoning logic; //===----------------------------------------------------------------------===//; /// A little component aggregating all of the reasoning we have about; /// the ranges of symbolic expressions.; ///; /// Even when we don't know the exact values of the operands, we still; /// can get a pretty good estimate of the result's range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:140,Usability,simpl,simply,140,"// If we've reached this line, the actual type of the symbolic; // expression is not supported for advanced inference.; // In this case, we simply backoff to the default ""let's simply; // infer the range from the expression's type"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:177,Usability,simpl,simply,177,"// If we've reached this line, the actual type of the symbolic; // expression is not supported for advanced inference.; // In this case, we simply backoff to the default ""let's simply; // infer the range from the expression's type"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:162,Modifiability,polymorphi,polymorphic,162,"/// Infer range information from the given integer constant.; ///; /// It's not a real ""inference"", but is here for operating with; /// sub-expressions in a more polymorphic manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:20,Usability,simpl,simply,20,"// Otherwise, let's simply infer from the destination type.; // We couldn't figure out nothing else about that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:489,Deployability,continuous,continuously,489,"// TODO #1: VisitBinaryOperator implementation might not make a good; // use of the inferred ranges. In this case, we might be calculating; // everything for nothing. This being said, we should introduce some; // sort of laziness mechanism here.; //; // TODO #2: We didn't go into the nested expressions before, so it; // might cause us spending much more time doing the inference.; // This can be a problem for deeply nested expressions that are; // involved in conditions and get tested continuously. We definitely; // need to address this issue and introduce some sort of caching; // in here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:482,Testability,test,tested,482,"// TODO #1: VisitBinaryOperator implementation might not make a good; // use of the inferred ranges. In this case, we might be calculating; // everything for nothing. This being said, we should introduce some; // sort of laziness mechanism here.; //; // TODO #2: We didn't go into the nested expressions before, so it; // might cause us spending much more time doing the inference.; // This can be a problem for deeply nested expressions that are; // involved in conditions and get tested continuously. We definitely; // need to address this issue and introduce some sort of caching; // in here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:117,Safety,avoid,avoid,117,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:151,Usability,simpl,simply,151,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:65,Safety,safe,safely,65,"// At this point, we are sure that the type is signed and we can safely; // use unary - operator.; //; // While calculating absolute maximum, we can use the following formula; // because of these reasons:; // * If From >= 0 then To >= From and To >= -From.; // AbsMax == To == max(To, -From); // * If To <= 0 then -From >= -To and -From >= From.; // AbsMax == -From == max(-From, To); // * Otherwise, From <= 0, To >= 0, and; // AbsMax == max(abs(From), abs(To))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:190,Testability,log,logical,190,"// Returns ranges only for binary comparison operators (except <=>); // when left and right operands are symbolic values.; // Finds any other comparisons with the same operands.; // Then do logical calculations and refuse impossible branches.; // E.g. (x < y) and (x > y) at the same time are impossible.; // E.g. (x >= y) and (x != y) at the same time makes (x > y) true only.; // E.g. (x == y) and (y == x) are just reversed but the same.; // It covers all possible combinations (see CmpOpTable description).; // Note that `x` and `y` can also stand for subexpressions,; // not only for actual symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:15,Modifiability,variab,variable,15,"// We use this variable to store the last queried operator (`QueriedOP`); // for which the `getCmpOpState` returned with `Unknown`. If there are two; // different OPs that returned `Unknown` then we have to query the special; // `UnknownX2` column. We assume that `getCmpOpState(CurrentOP, CurrentOP)`; // never returns `Unknown`, so `CurrentOP` is a good initial value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:40,Usability,guid,guided,40,"// If it is a false branch, we shall be guided by opposite operator,; // because the table is made assuming we are in the true branch.; // E.g. when (x <= y) is false, then (x > y) is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:324,Safety,avoid,avoid,324,"// We can only lose information if we are casting smaller signed type to; // bigger unsigned type. For e.g.,; // LHS (unsigned short): [2, USHRT_MAX]; // RHS (signed short): [SHRT_MIN, 0]; //; // Casting RHS to LHS type will leave us with overlapping values; // CastedRHS : [0, 0] U [SHRT_MAX + 1, USHRT_MAX]; //; // We can avoid this by checking if signed type's maximum value is lesser; // than unsigned type's minimum value.; // If both have different signs then only we can get more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:122,Usability,simpl,simply,122,"// It is pretty hard to reason about operands with different signs; // (and especially with possibly different signs). We simply check if it; // can be zero. In order to conclude that the result could not be zero,; // at least one of the operands should be definitely not zero itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:142,Usability,simpl,simply,142,// It's an undefined behaviour to divide by 0 and it seems like we know; // for sure that RHS is 0. Let's say that the resulting range is; // simply infeasible for that matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:100,Integrability,interface,interface,100,//===------------------------------------------------------------------===//; // Implementation for interface from ConstraintManager.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:29,Usability,simpl,simple,29,"// NOTE: ClassMembers are as simple as back pointers for ClassMap,; // so comparing constraint ranges and class maps should be; // sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:100,Integrability,interface,interface,100,//===------------------------------------------------------------------===//; // Implementation for interface from RangedConstraintManager.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:107,Testability,log,logic,107,"//===----------------------------------------------------------------------===//; // Constraint assignment logic; //===----------------------------------------------------------------------===//; /// ConstraintAssignorBase is a small utility class that unifies visitor; /// for ranges with a visitor for constraints (rangeset/range/constant).; ///; /// It is designed to have one derived class, but generally it can have more.; /// Derived class can control which types we handle by defining methods of the; /// following form:; ///; /// bool handle${SYMBOL}To${CONSTRAINT}(const SYMBOL *Sym,; /// CONSTRAINT Constraint);; ///; /// where SYMBOL is the type of the symbol (e.g. SymSymExpr, SymbolCast, etc.); /// CONSTRAINT is the type of constraint (RangeSet/Range/Const); /// return value signifies whether we should try other handle methods; /// (i.e. false would mean to stop right after calling this method)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:43,Deployability,update,update,43,"// There is a chance that we might need to update constraints for the; // classes that are known to be disequal to Class.; //; // In order for this to be even possible, the new constraint should; // be simply a constant because we can't reason about range disequalities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:202,Usability,simpl,simply,202,"// There is a chance that we might need to update constraints for the; // classes that are known to be disequal to Class.; //; // In order for this to be even possible, the new constraint should; // be simply a constant because we can't reason about range disequalities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:51,Usability,simpl,simplify,51,// Iterate over all equivalence classes and try to simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:175,Usability,simpl,simplify,175,"// Trivial equivalence classes (those that have only one symbol member) are; // not stored in the State. Thus, we must skim through the constraints as; // well. And we try to simplify symbols in the constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:11,Usability,simpl,simplified,11,// Already simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:95,Usability,simpl,simplify,95,"// We may have trivial equivalence classes in the disequality info as; // well, and we need to simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 4. Update disequality relations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 5. Update the state,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:201,Testability,log,logic,201,"// 3. If Second is known to be a constant, we can delete this point; // from the constraint asociated with First.; //; // So, if Second == 10, it means that First != 10.; // At the same time, the same logic does not apply to ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,Usability,clear,clear,13,// It is not clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:54,Testability,log,logic,54,// Re-evaluate an SVal with top-level `State->assume` logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,Usability,simpl,simply,28,"// If the SVal is 0, we can simply interpret that as `false`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:39,Usability,simpl,simplify,39,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:75,Usability,simpl,simplified,75,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:120,Usability,simpl,simplified,120,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:190,Usability,simpl,simplify,190,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:7,Usability,simpl,simplified,7,"// The simplified symbol should be the member of the original Class,; // however, it might be in another existing class at the moment. We; // have to merge these classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:436,Availability,alive,alive,436,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:556,Availability,alive,alive,556,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:635,Availability,alive,alive,635,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:451,Testability,assert,assert,451,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:18,Usability,Simpl,SimplifiedMemberSym,18,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:270,Usability,Simpl,SimplifiedMemberSym,270,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:412,Usability,Simpl,SimplifiedMemberSym,412,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:496,Usability,Simpl,SimplifiedMemberSym,496,"// Be aware that `SimplifiedMemberSym` might refer to an already dead; // symbol. In that case, the eqclass of that might not be the same as the; // eqclass of `MemberSym`. This is because the dead symbols are not; // preserved in the `ClassMap`, hence; // `find(State, SimplifiedMemberSym)` will result in a trivial eqclass; // compared to the eqclass of `MemberSym`.; // These eqclasses should be the same if `SimplifiedMemberSym` is alive.; // --> assert(find(State, MemberSym) == find(State, SimplifiedMemberSym)); //; // Note that `MemberSym` must be alive here since that is from the; // `ClassMembers` where all the symbols are alive.; // Remove the old and more complex symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:950,Energy Efficiency,reduce,reduced,950,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:827,Modifiability,extend,extended,827,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:136,Performance,perform,performance,136,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:355,Usability,simpl,simplify,355,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:506,Usability,simpl,simplified,506,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:287,Availability,alive,alive,287,"//===----------------------------------------------------------------------===//; // Remove dead symbols from existing constraints; //===----------------------------------------------------------------------===//; /// Scan all symbols referenced by the constraints. If the symbol is not alive; /// as marked in LSymbols, mark it as dead in DSymbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:3,Deployability,Update,Update,3,// Update disequality information to not hold any information on the; // removed class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:6,Deployability,Update,Update,6,// 4. Update the state with new maps.; //; // Here we try to be humble and update a map only if it really changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:75,Deployability,update,update,75,// 4. Update the state with new maps.; //; // Here we try to be humble and update a map only if it really changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:115,Integrability,interface,interface,115,"//===------------------------------------------------------------------------===; // assumeSymX methods: protected interface for RangeConstraintManager.; //===------------------------------------------------------------------------===/; // The syntax for ranges below is mathematical, using [x, y] for closed ranges; // and (x, y) for open ranges. These ranges are modular, corresponding with; // a common treatment of C integer overflow. This means that these methods; // do not have to worry about overflow; RangeSet::Intersect can handle such a; // ""wraparound"" range.; // As an example, the range [UINT_MAX-1, 3) contains five values: UINT_MAX-1,; // UINT_MAX, 0, 1, and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:553,Integrability,wrap,wraparound,553,"//===------------------------------------------------------------------------===; // assumeSymX methods: protected interface for RangeConstraintManager.; //===------------------------------------------------------------------------===/; // The syntax for ranges below is mathematical, using [x, y] for closed ranges; // and (x, y) for open ranges. These ranges are modular, corresponding with; // a common treatment of C integer overflow. This means that these methods; // do not have to worry about overflow; RangeSet::Intersect can handle such a; // ""wraparound"" range.; // As an example, the range [UINT_MAX-1, 3) contains five values: UINT_MAX-1,; // UINT_MAX, 0, 1, and 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:485,Integrability,interface,interface,485,"//== RangedConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines RangedConstraintManager, a class that provides a; // range-based constraint manager interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:15,Usability,simpl,simplify,15,// We can only simplify expressions whose RHS is an integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:37,Integrability,wrap,wraparound,37,// Get the type used for calculating wraparound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:3,Usability,Simpl,Simplification,3,"// Simplification: translate an assume of a constraint of the form; // ""(exp comparison_op expr) != 0"" to true into an assume of; // ""exp comparison_op expr"" to true. (And similarly, an assume of the form; // ""(exp comparison_op expr) == 0"" to true into an assume of; // ""exp comparison_op expr"" to false.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:37,Integrability,wrap,wraparound,37,// Get the type used for calculating wraparound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:18,Usability,simpl,simple,18,"// We only handle simple comparisons of the form ""$sym == constant""; // or ""($sym+constant1) == constant2"".; // The adjustment is ""constant1"" in the above expression. It's used to; // ""slide"" the solution range around for modular arithmetic. For example,; // x < 4 has the solution [0, 3]. x+2 < 4 has the solution [0-2, 3-2], which; // in modular arithmetic is [0, 1] U [UINT_MAX-1, UINT_MAX]. It's up to; // the subclasses of SimpleConstraintManager to handle the adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:428,Usability,Simpl,SimpleConstraintManager,428,"// We only handle simple comparisons of the form ""$sym == constant""; // or ""($sym+constant1) == constant2"".; // The adjustment is ""constant1"" in the above expression. It's used to; // ""slide"" the solution range around for modular arithmetic. For example,; // x < 4 has the solution [0, 3]. x+2 < 4 has the solution [0-2, 3-2], which; // in modular arithmetic is [0, 1] U [UINT_MAX-1, UINT_MAX]. It's up to; // the subclasses of SimpleConstraintManager to handle the adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:439,Deployability,update,updated,439,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:158,Modifiability,variab,variables,158,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:276,Modifiability,variab,variables,276,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:128,Performance,perform,perform,128,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:136,Performance,load,loads,136,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:555,Performance,load,loading,555,"// This flag indicates whether the current bindings are within the analysis; // that has started from main(). It affects how we perform loads from; // global variables that have initializers: if we have observed the; // program execution from the start and we know that these variables; // have not been overwritten yet, we can be sure that their initializers; // are still relevant. This flag never gets changed when the bindings are; // updated, so it could potentially be moved into RegionStoreManager; // (as if it's the same bindings but a different loading procedure); // however that would have made the manager needlessly stateful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:102,Testability,log,logic,102,//===----------------------------------------------------------------------===//; // Main RegionStore logic.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:308,Integrability,depend,dependent,308,"/// The largest number of fields a struct can have and still be; /// considered ""small"".; ///; /// This is currently used to decide whether or not it is worth ""forcing"" a; /// LazyCompoundVal on bind.; ///; /// This is controlled by 'region-store-small-struct-limit' option.; /// To disable all small-struct-dependent behavior, set the option to ""0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:309,Integrability,depend,dependent,309,"/// The largest number of element an array can have and still be; /// considered ""small"".; ///; /// This is currently used to decide whether or not it is worth ""forcing"" a; /// LazyCompoundVal on bind.; ///; /// This is controlled by 'region-store-small-struct-limit' option.; /// To disable all small-struct-dependent behavior, set the option to ""0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:18,Integrability,interface,interface,18,// Part of public interface to class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:396,Availability,error,error-prone,396,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:101,Performance,optimiz,optimization,101,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:145,Performance,optimiz,optimized,145,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:280,Security,expose,expose,280,"// FIXME: The offsets of empty bases can be tricky because of; // of the so called ""empty base class optimization"".; // If a base class has been optimized out; // we should not try to create a binding, otherwise we should.; // Unfortunately, at the moment ASTRecordLayout doesn't expose; // the actual sizes of the empty bases; // and trying to infer them from offsets/alignments; // seems to be error-prone and non-trivial because of the trailing padding.; // As a temporary mitigation we don't create bindings for empty bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:431,Deployability,update,updated,431,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:156,Performance,load,loading,156,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:360,Safety,avoid,avoid,360,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:4,Usability,Clear,Clears,4,/// Clears out all bindings in the given region and assigns a new value; /// as a Default binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:92,Testability,log,logic,92,/// Return the value bound to specified location in a given state.; ///; /// The high level logic for this method is this:; /// getBinding (L); /// if L has binding; /// return L's binding; /// else if L is in killset; /// return unknown; /// else; /// if L is on stack or heap; /// return undefined; /// else; /// return symbolic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:16,Performance,cache,cached,16,"/// Returns the cached set of interesting SVals contained within a lazy; /// binding.; ///; /// The precise value of ""interesting"" is determined for the purposes of; /// RegionStore's internal analysis. It must always contain all regions and; /// symbols, but may omit constants and other kinds of SVal.; ///; /// In contrast to compound values, LazyCompoundVals are also added; /// to the 'interesting values' list in addition to the child interesting; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:323,Modifiability,extend,extend,323,"/// Collects all bindings in \p Cluster that may refer to bindings within; /// \p Top.; ///; /// Each binding is a pair whose \c first is the key (a BindingKey) and whose; /// \c second is the value (an SVal).; ///; /// The \p IncludeAllDefaultBindings parameter specifies whether to include; /// default bindings that may extend beyond \p Top itself, e.g. if \p Top is; /// an aggregate within a larger aggregate with a default binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:39,Modifiability,variab,variables,39,// Lambdas can affect all static local variables without explicitly; // capturing those.; // We invalidate all static locals referenced inside the lambda body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:47,Modifiability,variab,variables,47,"// BlockDataRegion? If so, invalidate captured variables that are passed; // by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:69,Safety,detect,detection,69,// Bound symbolic regions need to be invalidated for dead symbol; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:85,Performance,Load,Loading,85,//===----------------------------------------------------------------------===//; // Loading values from regions.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:102,Availability,error,errors,102,"// For access to concrete addresses, return UnknownVal. Checks; // for null dereferences (and similar errors) are done by checkers, not; // the Store.; // FIXME: We can consider lazily symbolicating such memory, but we really; // should defer this when we can reason easily about symbolicating arrays; // of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:7,Security,access,access,7,"// For access to concrete addresses, return UnknownVal. Checks; // for null dereferences (and similar errors) are done by checkers, not; // the Store.; // FIXME: We can consider lazily symbolicating such memory, but we really; // should defer this when we can reason easily about symbolicating arrays; // of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:8,Safety,detect,detect,8,// Auto-detect the binding type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the element type. Eventually we want to compose these values; // more intelligently. For example, an 'element' can encompass multiple; // bound regions (e.g., several bound bytes), or could be a subset of; // a larger value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the element type. Eventually we want to compose these values; // more intelligently. For example, an 'element' can encompass multiple; // bound regions (e.g., several bound bytes), or could be a subset of; // a larger value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the ivar type. What we should model is stores to ivars; // that blow past the extent of the ivar. If the address of the ivar is; // reinterpretted, it is possible we stored a different value that could; // fit within the ivar. Either we need to cast these when storing them; // or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the ivar type. What we should model is stores to ivars; // that blow past the extent of the ivar. If the address of the ivar is; // reinterpretted, it is possible we stored a different value that could; // fit within the ivar. Either we need to cast these when storing them; // or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:91,Modifiability,variab,variable,91,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Modifiability,variab,variables,140,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:187,Modifiability,variab,variable,187,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:223,Modifiability,variab,variable,223,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:324,Modifiability,variab,variable,324,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:27,Performance,perform,perform,27,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:67,Performance,load,loaded,67,"// FIXME: Here we actually perform an implicit conversion from the loaded; // value to the variable type. What we should model is stores to variables; // that blow past the extent of the variable. If the address of the; // variable is reinterpretted, it is possible we stored a different value; // that could fit within the variable. Either we need to cast these when; // storing them or reinterpret them lazily (as we do here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:91,Energy Efficiency,allocate,allocated,91,// All stack variables are considered to have undefined values; // upon creation. All heap allocated blocks are considered to; // have undefined values as well unless they are explicitly bound; // to specific values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Modifiability,variab,variables,13,// All stack variables are considered to have undefined values; // upon creation. All heap allocated blocks are considered to; // have undefined values as well unless they are explicitly bound; // to specific values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:662,Performance,perform,performance,662,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Return an array of offsets from nested ElementRegions and a root base; /// region. The array is never empty and a base region is never null.; ///; /// E.g. for `Element{Element{Element{VarRegion},1},2},3}` returns { 3, 2, 1 }.; /// This represents an access through indirection: `arr[1][2][3];`; ///; /// \param ER The given (possibly nested) ElementRegion.; ///; /// \note The result array is in the reverse order of indirection expression:; /// arr[1][2][3] -> { 3, 2, 1 }. This helps to provide complexity O(n), where n; /// is a number of indirections. It may not affect performance in real-life; /// code, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:338,Security,access,access,338,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Return an array of offsets from nested ElementRegions and a root base; /// region. The array is never empty and a base region is never null.; ///; /// E.g. for `Element{Element{Element{VarRegion},1},2},3}` returns { 3, 2, 1 }.; /// This represents an access through indirection: `arr[1][2][3];`; ///; /// \param ER The given (possibly nested) ElementRegion.; ///; /// \note The result array is in the reverse order of indirection expression:; /// arr[1][2][3] -> { 3, 2, 1 }. This helps to provide complexity O(n), where n; /// is a number of indirections. It may not affect performance in real-life; /// code, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:651,Security,access,access,651,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Convert array of offsets from `SVal` to `uint64_t` in consideration of; /// respective array extents.; /// \param SrcOffsets [in] The array of offsets of type `SVal` in reversed; /// order (expectedly received from `getElementRegionOffsetsWithBase`).; /// \param ArrayExtents [in] The array of extents.; /// \param DstOffsets [out] The array of offsets of type `uint64_t`.; /// \returns:; /// - `std::nullopt` for successful convertion.; /// - `UndefinedVal` or `UnknownVal` otherwise. It's expected that this SVal; /// will be returned as a suitable value of the access operation.; /// which should be returned as a correct; ///; /// \example:; /// const int arr[10][20][30] = {}; // ArrayExtents { 10, 20, 30 }; /// int x1 = arr[4][5][6]; // SrcOffsets { NonLoc(6), NonLoc(5), NonLoc(4) }; /// // DstOffsets { 4, 5, 6 }; /// // returns std::nullopt; /// int x2 = arr[42][5][-6]; // returns UndefinedVal; /// int x3 = arr[4][5][x2]; // returns UnknownVal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:859,Testability,assert,assertion,859,"/// Returns an SVal, if possible, for the specified position of an; /// initialization list.; ///; /// \param ILE The given initialization list.; /// \param Offsets The array of unsigned offsets. E.g. for the expression; /// `int x = arr[1][2][3];` an array should be { 1, 2, 3 }.; /// \param ElemT The type of the result SVal expression.; /// \return Optional SVal for the particular position in the initialization; /// list. E.g. for the list `{{1, 2},[3, 4],{5, 6}, {}}` offsets:; /// - {1, 1} returns SVal{4}, because it's the second position in the second; /// sublist;; /// - {3, 0} returns SVal{0}, because there's no explicit value at this; /// position in the sublist.; ///; /// NOTE: Inorder to get a valid SVal, a caller shall guarantee valid offsets; /// for the given initialization list. Otherwise SVal can be an equivalent to 0; /// or lead to assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:17,Performance,load,loads,17,"// FIXME: Handle loads from strings where the literal is treated as; // an integer, e.g., *((unsigned int*)""hello""). Such loads are UB according; // to C++20 7.2.1.11 [basic.lval].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:122,Performance,load,loads,122,"// FIXME: Handle loads from strings where the literal is treated as; // an integer, e.g., *((unsigned int*)""hello""). Such loads are UB according; // to C++20 7.2.1.11 [basic.lval].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Performance,load,loads,13,"// Check for loads from a code text region. For such loads, just give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:53,Performance,load,loads,53,"// Check for loads from a code text region. For such loads, just give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:21,Modifiability,variab,variable,21,"// Either the record variable or the field has an initializer that we can; // trust. We trust initializers of constants and, additionally, respect; // initializers of globals when analyzing main().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:32,Security,access,accessing,32,"// Handle the case where we are accessing into a larger scalar object.; // For example, this handles:; // struct header {; // unsigned a : 1;; // unsigned b : 1;; // };; // struct parse_t {; // unsigned bits0 : 1;; // unsigned bits2 : 2; // <-- header; // unsigned bits4 : 4;; // };; // int parse(parse_t *p) {; // unsigned copy = p->bits2;; // header *bits = (header *)&copy;; // return bits->b; <-- here; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:307,Modifiability,variab,variable,307,"// FIXME: This is a hack to deal with RegionStore's inability to distinguish a; // default value for /part/ of an aggregate from a default value for the; // /entire/ aggregate. The most common case of this is when struct Outer; // has as its first member a struct Inner, which is copied in from a stack; // variable. In this case, even if the Outer's default value is symbolic, 0,; // or unknown, it gets overridden by the Inner's default value of undefined.; //; // This is a general problem -- if the Inner is zero-initialized, the Outer; // will now look zero-initialized. The proper way to solve this is with a; // new version of RegionStore that tracks the extent of a binding as well; // as the offset.; //; // This hack only takes care of the undefined case because that can very; // quickly result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:307,Modifiability,variab,variable,307,"// FIXME: This is a hack to deal with RegionStore's inability to distinguish a; // default value for /part/ of an aggregate from a default value for the; // /entire/ aggregate. The most common case of this is when struct Outer; // has as its first member a struct Inner, which is copied in from a stack; // variable. In this case, even if the Outer's default value is symbolic, 0,; // or unknown, it gets overridden by the Inner's default value of undefined.; //; // This is a general problem -- if the Inner is zero-initialized, the Outer; // will now look zero-initialized. The proper way to solve this is with a; // new version of RegionStore that tracks the extent of a binding as well; // as the offset.; //; // This hack only takes care of the undefined case because that can very; // quickly result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:121,Deployability,install,installed,121,"// If our super region is a field or element itself, walk up the region; // hierarchy to see if there is a default value installed in an ancestor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:118,Security,access,accessing,118,"// FIXME: We also need to take ElementRegions with symbolic indexes into; // account. This case handles both directly accessing an ElementRegion; // with a symbolic offset, but also fields within an element with; // a symbolic offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:10,Modifiability,variab,variable,10,"// If the variable is const qualified and has an initializer but; // we couldn't evaluate initializer to a value, treat the value as; // unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:86,Modifiability,variab,variables,86,// This must come after the check for constants because closure-captured; // constant variables may appear in UnknownSpaceRegion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:26,Modifiability,variab,variables,26,"// Function-scoped static variables are default-initialized to 0; if they; // have an initializer, it would have been processed by now.; // FIXME: This is only true when we're starting analysis from main().; // We're losing a lot of coverage here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:20,Performance,cache,cache,20,"// First, check the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:37,Performance,cache,cached,37,"// If we don't have a list of values cached, start constructing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:3,Usability,Clear,Clear,3,// Clear out bindings that may overlap with this binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Testability,assert,assertion,140,"// We can't represent values of this type, but we still need to set a value; // to record that the region has been initialized.; // If this assertion ever fires, a new case should be added above -- we; // should know how to default-initialize any value we can symbolicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:75,Modifiability,variab,variable,75,"// If the init list is shorter than the array length (or the array has; // variable length), set the array default value. Values that are already set; // are not overwritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:65,Testability,log,logic,65,"// We may get non-CompoundVal accidentally due to imprecise cast logic or; // that we are binding symbolic struct value. Kill the field values, and if; // the value is symbolic go and bind it as a ""default"" binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:65,Testability,log,logic,65,"// We may get non-CompoundVal accidentally due to imprecise cast logic or; // that we are binding symbolic struct value. Kill the field values, and if; // the value is symbolic go and bind it as a ""default"" binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:1032,Safety,safe,safer,1032,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:798,Usability,simpl,simply,798,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:243,Integrability,message,message,243,"// If the object was constructed with a constructor, its value is a; // LazyCompoundVal. If it's a raw CompoundVal, it means that we're; // performing aggregate initialization. The only exception from this; // rule is sending an Objective-C++ message that returns a C++ object; // to a nil receiver; in this case the semantics is to return a; // zero-initialized object even if it's a C++ object that doesn't have; // this sort of constructor; the CompoundVal is empty in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:140,Performance,perform,performing,140,"// If the object was constructed with a constructor, its value is a; // LazyCompoundVal. If it's a raw CompoundVal, it means that we're; // performing aggregate initialization. The only exception from this; // rule is sending an Objective-C++ message that returns a C++ object; // to a nil receiver; in this case the semantics is to return a; // zero-initialized object even if it's a C++ object that doesn't have; // this sort of constructor; the CompoundVal is empty in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:13,Modifiability,inherit,inheritance,13,// (Multiple inheritance is fine though.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:3,Deployability,Update,Update,3,// Update the set of live symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:159,Deployability,update,update,159,"// We have now scanned the store, marking reachable regions and symbols; // as live. We now remove all the regions that are dead from the store; // as well as update DSymbols with the set symbols that are now dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp:17,Availability,error,error,17,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SarifDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:484,Integrability,interface,interface,484,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:5,Usability,Simpl,SimpleConstraintManager,5,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:401,Usability,Simpl,SimpleConstraintManager,401,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:454,Usability,simpl,simplified,454,"//== SimpleConstraintManager.cpp --------------------------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleConstraintManager, a class that provides a; // simplified constraint manager interface, compared to ConstraintManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:63,Usability,simpl,simplify,63,// Just add the constraint to the expression without trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:63,Usability,simpl,simplify,63,// Just add the constraint to the expression without trying to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,SimpleSValBuilder,3,"// SimpleSValBuilder.cpp - A basic SValBuilder -----------------------*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleSValBuilder, a basic implementation of SValBuilder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:401,Usability,Simpl,SimpleSValBuilder,401,"// SimpleSValBuilder.cpp - A basic SValBuilder -----------------------*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleSValBuilder, a basic implementation of SValBuilder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Usability,simpl,simplifySValOnce,13,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:78,Usability,simpl,simpler,78,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:132,Usability,simpl,simplify,132,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:162,Usability,simpl,simplification,162,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:217,Usability,simpl,simplest,217,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:62,Usability,simpl,simplifying,62,"/// Evaluates a given SVal by recursively evaluating and; /// simplifying the children SVals. If the SVal has only one possible; /// (integer) value, that value is returned. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:57,Usability,simpl,simplifying,57,"/// Evaluates a given SVal by recursively evaluating and simplifying the; /// children SVals, then returns its minimal possible (integer) value. If the; /// constraint manager cannot provide a meaningful answer, this returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:57,Usability,simpl,simplifying,57,"/// Evaluates a given SVal by recursively evaluating and simplifying the; /// children SVals, then returns its maximal possible (integer) value. If the; /// constraint manager cannot provide a meaningful answer, this returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,Energy Efficiency,reduce,reduce,12,// We can't reduce this case; just treat it normally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:77,Integrability,Wrap,Wrap,77,// Idempotent ops (like a*1) can still change the type of an expression.; // Wrap the LHS up in a NonLoc again and let evalCast do the; // dirty work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:52,Usability,simpl,simplified,52,"// If we reach this point, the expression cannot be simplified.; // Make a SymbolVal for the entire expression, after converting the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:30,Modifiability,extend,extend,30,"// If the value is too small, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:169,Performance,perform,performed,169,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:191,Safety,risk,risk,191,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:293,Usability,simpl,simpler,293,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:23,Energy Efficiency,reduce,reduce,23,"// Fail to decompose: ""reduce"" the problem to the ""$x + 0"" case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,Simplify,3,"// Simplify ""(LSym + LInt) Op (RSym + RInt)"" assuming all values are of the; // same signed integral type and no overflows occur (which should be checked; // by the caller).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Usability,Simpl,Simplify,13,"// Shortcut: Simplify ""$x + 0"" to ""$x"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:99,Usability,simpl,simplified,99,// Constraints may have changed since the creation of a bound SVal. Check if; // the values can be simplified based on those new constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:51,Performance,perform,perform,51,"// If we're dealing with two known constants, just perform the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:428,Safety,avoid,avoid,428,"// FIXME: At this point the constant folding claims that the result; // of a bitwise shift is undefined. However, constant folding; // relies on the inaccurate type information that is stored in the; // bit size of APSInt objects, and if we reached this point, then; // the checker core.BitwiseShift already determined that the shift; // is valid (in a PreStmt callback, by querying the real type from; // the AST node).; // To avoid embarrassing false positives, let's just say that we; // don't know anything about the result of the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:25,Usability,simpl,simple,25,// We only handle LHS as simple symbols or SymIntExprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Testability,log,logical,13,// Is this a logical not? (!x is represented as x == 0.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:46,Usability,Simpl,Simplify,46,// We know how to negate certain expressions. Simplify them here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:102,Usability,simpl,simply,102,"// Next, see if the two FRs have the same super-region.; // FIXME: This doesn't handle casts yet, and simply stripping the casts; // doesn't help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:107,Modifiability,inherit,inheritance,107,// Make sure the two FRs are from the same kind of record. Just in case!; // FIXME: This is probably where inheritance would be a problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:58,Availability,down,downstream,58,"// This is used in debug builds only for now because some downstream users; // may hit this assert in their subsequent merges.; // There are still places in the analyzer where equal bitwidth Locs; // are compared, and need to be found and corrected. Recent previous fixes have; // addressed the known problems of making NULLs with specific bitwidths; // for Loc comparisons along with deprecation of APIs for the same purpose.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:92,Testability,assert,assert,92,"// This is used in debug builds only for now because some downstream users; // may hit this assert in their subsequent merges.; // There are still places in the analyzer where equal bitwidth Locs; // are compared, and need to be found and corrected. Recent previous fixes have; // addressed the known problems of making NULLs with specific bitwidths; // for Loc comparisons along with deprecation of APIs for the same purpose.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:19,Testability,log,logic,19,// FIXME: all this logic will change if/when we have MemRegion::getLocation().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Testability,Assert,Assert,3,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:197,Testability,test,test,197,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:287,Testability,assert,assertEqualBitWidths,287,"// Assert that bitwidth of lhs and rhs are the same.; // This can happen if two different address spaces are used,; // and the bitwidths of the address spaces are different.; // See LIT case clang/test/Analysis/cstring-checker-addressspace.c; // FIXME: See comment above in the function assertEqualBitWidths",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:143,Integrability,depend,depending,143,"// There may be two labels for the same location, and a function region may; // have the same address as a label at the start of the function (depending; // on the ABI).; // FIXME: we can probably do a comparison against other MemRegions, though.; // FIXME: is there a way to tell if two labels refer to the same location?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:40,Performance,perform,perform,40,"// If both operands are constants, just perform the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:71,Testability,test,test,71,"// Special case comparisons against NULL.; // This must come after the test if the RHS is a symbol, which is used to; // build constraints. The address of any non-symbolic region is guaranteed; // to be non-NULL, as is any label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:66,Testability,test,test,66,"// Special case comparisons to NULL.; // This must come after the test if the LHS is a symbol, which is used to; // build constraints. The address of any non-symbolic region is guaranteed; // to be non-NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:18,Integrability,wrap,wrap,18,"// If both values wrap regions, see if they're from different base regions.; // Note, heap base symbolic regions are assumed to not alias with; // each other; for example, we assume that malloc returns different address; // on each invocation.; // FIXME: ObjC object pointers always reside on the heap, but currently; // we treat their memory space as unknown, because symbolic pointers; // to ObjC objects may alias. There should be a way to construct; // possibly-aliasing heap-based regions. For instance, MacOSXApiChecker; // guesses memory space for ObjC object pointers manually instead of; // relying on us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,Performance,perform,perform,12,// Actually perform the operation.; // evalBinOpNN expects the two indexes to already be the right type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:81,Integrability,Depend,Depending,81,"// We need to know the type of the pointer in order to add an integer to it.; // Depending on the type, different amount of bytes is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:26,Availability,reliab,reliable,26,"// TODO: Is this actually reliable? Maybe improving our MemRegion; // hierarchy to provide typed regions for all non-void pointers would be; // better. For instance, we cannot extend this towards LocAsInteger; // operations, where result type of the expression is integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:176,Modifiability,extend,extend,176,"// TODO: Is this actually reliable? Maybe improving our MemRegion; // hierarchy to provide typed regions for all non-void pointers would be; // better. For instance, we cannot extend this towards LocAsInteger; // operations, where result type of the expression is integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:117,Usability,simpl,simplifications,117,"// For now, this function tries to constant-fold symbols inside a; // nonloc::SymbolVal, and does nothing else. More simplifications should; // be possible, such as constant-folding an index in an ElementRegion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Performance,Cache,Cache,3,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:241,Performance,cache,cache,241,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:41,Usability,Simpl,Simplifier,41,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:163,Usability,simpl,simplifying,163,"// Cache results for the lifetime of the Simplifier. Results change every; // time new constraints are added to the program state, which is the whole; // point of simplifying, and for that very reason it's pointless to maintain; // the same cache for the duration of the whole analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:47,Availability,avail,available,47,"// Return the known const value for the Sym if available, or return Undef; // otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:6,Performance,cache,cache,6,// No cache here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:24,Usability,simpl,simplify,24,// For now don't try to simplify mixed Loc/NonLoc expressions; // because they often appear from LocAsInteger operations; // and we don't know how to combine a LocAsInteger; // with a concrete value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Usability,Simpl,Simplification,3,"// Simplification is much more costly than computing complexity.; // For high complexity, it may be not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:19,Integrability,Interface,Interface,19,"//===- Store.cpp - Interface for maps from Locations to Values ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defined the types Store and StoreManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:232,Availability,down,downcasts,232,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:43,Integrability,depend,depending,43,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:35,Availability,down,downcasts,35,// FIXME: Need to handle arbitrary downcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:19,Safety,avoid,avoid,19,// Early return to avoid doing the wrong thing in the face of; // reinterpret_cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,Availability,down,down,9,"// Drill down the CXXBaseObject chains, which represent upcasts (casts from; // derived to base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:115,Modifiability,inherit,inheritance,115,"// Static upcasts are marked as DerivedToBase casts by Sema, so this will; // only happen when multiple or virtual inheritance is involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:9,Availability,down,down,9,// Drill down the chain to get the derived classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:382,Performance,perform,performance,382,"// Strange use of reinterpret_cast can give us paths we don't reason; // about well, by putting in ElementRegions where we'd expect; // CXXBaseObjectRegions. If it's a valid reinterpret_cast (i.e. if the; // derived class has a zero offset from the base class), then it's safe; // to strip the cast; if it's invalid, -Wreinterpret-base-class should; // catch it. In the interest of performance, the analyzer will silently; // do the wrong thing in the invalid case (because offsets for subregions; // will be wrong).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:272,Safety,safe,safe,272,"// Strange use of reinterpret_cast can give us paths we don't reason; // about well, by putting in ElementRegions where we'd expect; // CXXBaseObjectRegions. If it's a valid reinterpret_cast (i.e. if the; // derived class has a zero offset from the base class), then it's safe; // to strip the cast; if it's invalid, -Wreinterpret-base-class should; // catch it. In the interest of performance, the analyzer will silently; // do the wrong thing in the invalid case (because offsets for subregions; // will be wrong).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:33,Safety,avoid,avoid,33,// Fast-path some expressions to avoid the overhead of going through the AST's; // constant evaluator,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:104,Usability,simpl,simple,104,// If the right operand is a concrete int location then we have nothing; // better but to treat it as a simple nonloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:156,Usability,simpl,simplification-ptr-bool,156,// This change is needed for architectures with varying; // pointer widths. See the amdgcn opencl reproducer with; // this change as an example: solver-sym-simplification-ptr-bool.cl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:74,Integrability,wrap,wrap,74,"// When retrieving symbolic pointer and expecting a non-void pointer,; // wrap them into element regions of the expected type if necessary.; // It is necessary to make sure that the retrieved value makes sense,; // because there's no other cast in the AST that would tell us to cast; // it to the correct pointer type. We might need to do that for non-void; // pointers as well.; // FIXME: We really need a single good function to perform casts for us; // correctly every time we need it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:431,Performance,perform,perform,431,"// When retrieving symbolic pointer and expecting a non-void pointer,; // wrap them into element regions of the expected type if necessary.; // It is necessary to make sure that the retrieved value makes sense,; // because there's no other cast in the AST that would tell us to cast; // it to the correct pointer type. We might need to do that for non-void; // pointers as well.; // FIXME: We really need a single good function to perform casts for us; // correctly every time we need it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:209,Integrability,message,message,209,// FIXME: We should be able to cast NonLoc -> Loc; // (when Loc::isLocType(CastTy) is true); // But it's hard to do as SymbolicRegions can't refer to SymbolCasts holding; // generic SymExprs. Check the commit message for the details.; // Symbol to pointer and whatever else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,Availability,redundant,redundant,39,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:4,Energy Efficiency,Reduce,Reduce,4,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,Safety,redund,redundant,39,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:365,Usability,simpl,simplified,365,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:42,Usability,simpl,simplification,42,"// We use seven conditions to recognize a simplification case.; // For the clarity let `CastTy` be `C`, SE->getType() - `T`, root type -; // `R`, prefix `u` for unsigned, `s` for signed, no prefix - any sign: E.g.; // (char)(short)(uint x); // ( sC )( sT )( uR x); //; // C === R (the same type); // (char)(char x) -> (char x); // (long)(long x) -> (long x); // Note: Comparisons operators below are for bit width.; // C == T; // (short)(short)(int x) -> (short)(int x); // (int)(long)(char x) -> (int)(char x) (sizeof(long) == sizeof(int)); // (long)(ullong)(char x) -> (long)(char x) (sizeof(long) ==; // sizeof(ullong)); // C < T; // (short)(int)(char x) -> (short)(char x); // (char)(int)(short x) -> (char)(short x); // (short)(int)(short x) -> (short x); // C > T > uR; // (int)(short)(uchar x) -> (int)(uchar x); // (uint)(short)(uchar x) -> (uint)(uchar x); // (int)(ushort)(uchar x) -> (int)(uchar x); // C > sT > sR; // (int)(short)(char x) -> (int)(char x); // (uint)(short)(char x) -> (uint)(char x); // C > sT == sR; // (int)(char)(char x) -> (int)(char x); // (uint)(short)(short x) -> (uint)(short x); // C > uT == uR; // (int)(uchar)(uchar x) -> (int)(uchar x); // (uint)(ushort)(ushort x) -> (uint)(ushort x); // (llong)(ulong)(uint x) -> (llong)(uint x) (sizeof(ulong) ==; // sizeof(uint))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:17,Usability,simpl,simplification,17,// FIXME support simplification from non-integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:330,Performance,perform,performs,330,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:497,Performance,perform,performs,497,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:675,Performance,perform,performs,675,"// end anonymous namespace; /// Cast a given SVal to another SVal using given QualType's.; /// \param V -- SVal that should be casted.; /// \param CastTy -- QualType that V should be casted according to.; /// \param OriginalTy -- QualType which is associated to V. It provides; /// additional information about what type the cast performs from.; /// \returns the most appropriate casted SVal.; /// Note: Many cases don't use an exact OriginalTy. It can be extracted; /// from SVal or the cast can performs unconditionaly. Always pass OriginalTy!; /// It can be crucial in certain cases and generates different results.; /// FIXME: If `OriginalTy.isNull()` is true, then cast performs based on CastTy; /// only. This behavior is uncertain and should be improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:52,Integrability,wrap,wraps,52,"/// If this SVal is a location (subclasses Loc) and wraps a symbol,; /// return that SymbolRef. Otherwise return 0.; ///; /// Implicit casts (ex: void* -> char*) can turn Symbolic region into Element; /// region. If that is the case, gets the underlining region.; /// When IncludeBaseRegions is set to true and the SubRegion is non-symbolic,; /// the first symbolic parent region is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:39,Integrability,wrap,wrapped,39,// FIXME: should we consider SymbolRef wrapped in CodeTextRegion?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:17,Integrability,wrap,wraps,17,"/// If this SVal wraps a symbol return that SymbolRef.; /// Otherwise, return 0.; ///; /// Casts are ignored during lookup.; /// \param IncludeBaseRegions The boolean that controls whether the search; /// should continue to the base regions if the region is not symbolic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:39,Integrability,wrap,wrapped,39,// FIXME: should we consider SymbolRef wrapped in CodeTextRegion?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:15,Integrability,depend,dependents,15,// Do not mark dependents more then once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:273,Modifiability,variab,variable,273,"// TODO: For now, liveness of a memory region is equivalent to liveness of its; // base region. In fact we can do a bit better: say, if a particular FieldDecl; // is not used later in the path, we can diagnose a leak of a value within; // that field earlier than, say, the variable that contains the field dies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp:30,Modifiability,inherit,inheriting,30,// Anonymous parameters of an inheriting constructor are live for the entire; // duration of the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SymbolManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp:103,Availability,error,error,103,"/// Emits minimal diagnostics (report message + notes) for the 'none' output; /// type to the standard error, or to complement many others. Emits detailed; /// diagnostics in textual format for the 'text' output type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp:38,Integrability,message,message,38,"/// Emits minimal diagnostics (report message + notes) for the 'none' output; /// type to the standard error, or to complement many others. Emits detailed; /// diagnostics in textual format for the 'text' output type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:74,Safety,unsafe,unsafe,74,// Don't use const reference. The subsequent pop_back() might make it; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:78,Performance,queue,queue,78,"// Number of inserted nodes, used to emulate DFS ordering in the priority; // queue when insertions are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:78,Performance,queue,queue,78,"// Number of inserted nodes, used to emulate DFS ordering in the priority; // queue when insertions are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:135,Performance,optimiz,optimization,135,"/// Stores the declarations from the local translation unit.; /// Note, we pre-compute the local declarations at parse time as an; /// optimization to make sure we do not deserialize everything from disk.; /// The local declaration to all declarations ratio might be very small when; /// working with a PCH file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:99,Safety,avoid,avoids,99,/// Store the top level decls in the set to be processed later on.; /// (Doing this pre-processing avoids deserialization of data from PCH.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:55,Safety,avoid,avoid,55,"// Skip ObjCMethodDecl, wait for the objc container to avoid; // analyzing twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:122,Availability,down,down,122,"// Skip analysis of inheriting constructors as top-level functions. These; // constructors don't even have a body written down in the code, so even if; // we find a bug, we won't be able to display it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:20,Modifiability,inherit,inheriting,20,"// Skip analysis of inheriting constructors as top-level functions. These; // constructors don't even have a body written down in the code, so even if; // we find a bug, we won't be able to display it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:294,Availability,error,errors,294,"// We want to re-analyse the functions as top level in the following cases:; // - The 'init' methods should be reanalyzed because; // ObjCNonNilReturnValueChecker assumes that '[super init]' never returns; // 'nil' and unless we analyze the 'init' functions as top level, we will; // not catch errors within defensive code.; // - We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:426,Availability,error,errors,426,"// We want to re-analyse the functions as top level in the following cases:; // - The 'init' methods should be reanalyzed because; // ObjCNonNilReturnValueChecker assumes that '[super init]' never returns; // 'nil' and unless we analyze the 'init' functions as top level, we will; // not catch errors within defensive code.; // - We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:99,Availability,error,errors,99,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:144,Availability,down,down,144,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:139,Performance,tune,tune,139,// We want to reanalyze all ObjC methods as top level to report Retain; // Count naming convention errors more aggressively. But we should tune down; // inlining when reanalyzing an already inlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:248,Security,access,access,248,// Build the Call Graph by adding all the top level declarations to the graph.; // Note: CallGraph can trigger deserialization of more items from a pch; // (though HandleInterestingDecl); triggering additions to LocalTUDecls.; // We rely on random access to add the initially processed Decls to CG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:331,Performance,perform,performance,331,"// Walk over all of the call graph nodes in topological order, so that we; // analyze parents before the children. Skip the functions inlined into; // the previously processed functions. Use external Visited set to identify; // inlined functions. The topological order allows the ""do not reanalyze; // previously inlined function"" performance heuristic to be triggered more; // often.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:117,Usability,simpl,simplest,117,"// Run the AST-only checks using the order in which functions are defined.; // If inlining is not turned on, use the simplest function order for path; // sensitive analyzes as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:202,Security,access,access,202,"// Process all the top level declarations.; //; // Note: TraverseDecl may modify LocalTUDecls, but only by appending more; // entries. Thus we don't use an iterator, but rely on LocalTUDecls; // random access. By doing so, we automatically compensate for iterators; // possibly being invalidated, although this is a bit slower.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:31,Availability,error,error,31,// Don't run the actions if an error has occurred with parsing the file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:66,Performance,perform,performed,66,// Don't analyze if the user explicitly asked for no checks to be performed; // on this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:61,Integrability,depend,depending,61,"// Unless -analyze-all is specified, treat decls differently depending on; // where they came from:; // - Main source file: run both path-sensitive and non-path-sensitive checks.; // - Header files: run non-path-sensitive checks only.; // - System headers: don't run any checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:3,Usability,Clear,Clear,3,// Clear the AnalysisManager of old AnalysisDeclContexts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:15,Integrability,message,message,15,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:90,Modifiability,config,configs,90,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:223,Modifiability,config,config,223,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:158,Security,access,accessible,158,"// FIXME: This message sounds scary, should be scary, but incorrectly states; // that all configs are super dangerous. In reality, many of them should be; // accessible to the user. We should create a user-facing subset of config; // options under a different frontend flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:89,Deployability,configurat,configurations,89,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:47,Modifiability,config,config,47,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:89,Modifiability,config,configurations,89,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:161,Modifiability,variab,variables,161,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:376,Modifiability,config,config,376,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:428,Modifiability,config,config,428,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp:460,Modifiability,config,config,460,"R""(; OVERVIEW: Clang Static Analyzer -analyzer-config Option List. The following list of configurations are meant for development purposes only, as; some of the variables they define are set to result in the most optimal; analysis. Setting them to other values may drastically change how the analyzer; behaves, and may even result in instabilities, crashes!. USAGE: -analyzer-config <OPTION1=VALUE,OPTION2=VALUE,...>; -analyzer-config OPTION1=VALUE, -analyzer-config OPTION2=VALUE, ...; OPTIONS:; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalyzerHelpFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:43,Availability,avail,available,43,"//===- CheckerRegistry.cpp - Maintains all available checkers -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:54,Modifiability,plugin,plugin,54,"// If the version string is null, its not an analyzer plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:26,Modifiability,plugin,plugins,26,// Register checkers from plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:21,Modifiability,plugin,plugin,21,// Get access to the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:7,Security,access,access,7,// Get access to the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:21,Energy Efficiency,efficient,efficient,21,// Sort checkers for efficient collection.; // FIXME: Alphabetical sort puts 'experimental' in the middle.; // Would it be better to name it '~experimental' or something else; // that's ASCIIbetically last?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:42,Integrability,depend,dependencies,42,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:119,Integrability,depend,dependencies,119,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:8,Testability,assert,assertions,8,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:85,Integrability,Depend,Dependency,85,//===----------------------------------------------------------------------===//; // Dependency resolving.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:18,Integrability,depend,dependencies,18,/// Collects weak dependencies in \p enabledData.Checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:93,Integrability,depend,dependencies,93,"// First, we calculate the list of enabled checkers as specified by the; // invocation. Weak dependencies will not enable their unspecified strong; // depenencies, but its only after resolving strong dependencies for all; // checkers when we know whether they will be enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:200,Integrability,depend,dependencies,200,"// First, we calculate the list of enabled checkers as specified by the; // invocation. Weak dependencies will not enable their unspecified strong; // depenencies, but its only after resolving strong dependencies for all; // checkers when we know whether they will be enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Integrability,depend,dependencies,37,"// If we failed to enable any of the dependencies, don't enable this; // checker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:140,Availability,error,error,140,"// Calculate enabled checkers with the correct registration order. As this is; // done recursively, its arguably cheaper, but for sure less error prone to; // recalculate from scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Integrability,depend,dependencies,37,"// If we failed to enable any of the dependencies, don't enable this; // checker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:11,Integrability,depend,dependencies,11,// Collect dependencies recursively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:39,Integrability,depend,dependencies,39,"// Don't enable this checker if strong dependencies are unsatisfied, but; // assume that weak dependencies are transitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:94,Integrability,depend,dependencies,94,"// Don't enable this checker if strong dependencies are unsatisfied, but; // assume that weak dependencies are transitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:50,Integrability,depend,dependency,50,// We do allow diagnostics from unit test/example dependency checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,Testability,test,test,37,// We do allow diagnostics from unit test/example dependency checkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:267,Modifiability,config,config,267,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:114,Security,validat,validating,114,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:290,Security,validat,validate,290,"//===----------------------------------------------------------------------===//; // Checker option resolving and validating.; //===----------------------------------------------------------------------===//; /// Insert the checker/package option to AnalyzerOptions' config table, and; /// validate it, if the user supplied it on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:108,Modifiability,plugin,plugins,108,// Insertation was successful -- CmdLineOption's constructor will validate; // whether values received from plugins or TableGen files are correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:66,Security,validat,validate,66,// Insertation was successful -- CmdLineOption's constructor will validate; // whether values received from plugins or TableGen files are correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:241,Availability,error,error,241,"// Insertion failed, the user supplied this package/checker option on the; // command line. If the supplied value is invalid, we'll restore the option; // to it's default value, and if we're in non-compatibility mode, we'll also; // emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:20,Modifiability,config,config,20,"// AnalyzerOptions' config table contains the user input, so an entry could; // look like this:; //; // cor:NoFalsePositives=true; //; // Since lower_bound would look for the first element *not less* than ""cor"",; // it would return with an iterator to the first checker in the core, so we; // we really have to use find here, which uses operator==.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:779,Availability,avail,available,779,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:703,Integrability,inject,injected,703,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp:703,Security,inject,injected,703,"//===--- ModelConsumer.cpp - ASTConsumer for consuming model files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an ASTConsumer for consuming model files.; ///; /// This ASTConsumer handles the AST of a parsed model file. All top level; /// function definitions will be collected from that model file for later; /// retrieval during the static analysis. The body of these functions will not; /// be injected into the ASTUnit of the analyzed translation unit. It will be; /// available through the BodyFarm which is utilized by the AnalysisDeclContext; /// class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp:99,Safety,avoid,avoid,99,"// The instance wants to take ownership, however DisableFree frontend option; // is set to true to avoid double free issues",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:497,Integrability,interface,interface,497,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:538,Integrability,inject,injecting,538,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:538,Security,inject,injecting,538,"//===-- ModelInjector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the clang::ento::ModelInjector class which implements the; /// clang::CodeInjector interface. This class is responsible for injecting; /// function definitions that were synthesized from model files.; ///; /// Model files allow definitions of functions to be lazily constituted for functions; /// which lack bodies in the original source code. This allows the analyzer; /// to more precisely analyze code that calls such functions, analyzing the; /// artificial definitions (which typically approximate the semantics of the; /// called function) when called by client code. These definitions are; /// reconstituted lazily, on-demand, by the static analyzer engine.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:133,Deployability,configurat,configuration,133,"/// Synthesize a body for a declaration; ///; /// This method first looks up the appropriate model file based on the; /// model-path configuration option and the name of the declaration that is; /// looked up. If no model were synthesized yet for a function with that name; /// it will create a new compiler instance to parse the model file using the; /// ASTContext, Preprocessor, SourceManager of the original compiler instance.; /// The former resources are shared between the two compiler instance, so the; /// newly created instance have to ""leak"" these objects, since they are owned; /// by the original instance.; ///; /// The model-path should be either an absolute path or relative to the; /// working directory of the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:133,Modifiability,config,configuration,133,"/// Synthesize a body for a declaration; ///; /// This method first looks up the appropriate model file based on the; /// model-path configuration option and the name of the declaration that is; /// looked up. If no model were synthesized yet for a function with that name; /// it will create a new compiler instance to parse the model file using the; /// ASTContext, Preprocessor, SourceManager of the original compiler instance.; /// The former resources are shared between the two compiler instance, so the; /// newly created instance have to ""leak"" these objects, since they are owned; /// by the original instance.; ///; /// The model-path should be either an absolute path or relative to the; /// working directory of the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,Availability,redundant,redundant,32,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,Safety,redund,redundant,32,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:48,Performance,load,load,48,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:77,Performance,load,load,77,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:134,Performance,load,loaded,134,// Pointer to vector types. Defined for segment load intrinsics.; // segment load intrinsics have pointer type arguments to store the loaded; // vector values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update ElementBitwidth need to update Scale too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:34,Deployability,update,update,34,// Update ElementBitwidth need to update Scale too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,update,update,3,// update new elmul = (eew/sew) * lmul,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,update,update,3,// update new eew,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update new SEW,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:3,Deployability,Update,Update,3,// Update new LMUL,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:47,Performance,cache,cache,47,"// Compute the hash value of RVVType, used for cache the result of computeType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:15,Security,hash,hash,15,"// Compute the hash value of RVVType, used for cache the result of computeType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:13,Security,hash,hash,13,// Layout of hash value:; // 0 8 16 24 32 40; // | Log2LMUL + 3 | BT | Proto.PT | Proto.TM | Proto.VTM |,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:56,Deployability,update,update,56,// IntrinsicTypes is unmasked TA version index. Need to update it; // if there is merge operand (It is always in first operand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:131,Availability,mask,mask,131,"// Convert; // (void, op0 address, op1 address, ..., maskedoff0, maskedoff1, ...); // to; // (void, op0 address, op1 address, ..., mask, maskedoff0, maskedoff1,; // ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:43,Availability,Mask,Mask,43,"// If IsMasked, insert PrototypeDescriptor:Mask as first input operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:28,Performance,load,load,28,"// NF > 1 cases for segment load operations.; // Convert; // (void, op0 address, op1 address, ...); // to; // (void, op0 address, op1 address, maskedoff0, maskedoff1, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:27,Usability,guid,guideline,27,// This follows the naming guideline under riscv-c-api-doc to add the; // `__riscv_` suffix for all RVV intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp:3,Testability,Test,Test,3,// Test with basic arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CommandLineArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:9,Testability,Test,TestAST,9,"//===--- TestAST.cpp ------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:60,Availability,error,errors,60,"// Captures diagnostics into a vector, optionally reporting errors to gtest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:99,Testability,test,test,99,"// If we don't manage to finish parsing, create CompilerInstance components; // anyway so that the test will see an empty AST instead of crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:9,Availability,error,error,9,"// Extra error conditions are reported through diagnostics, set that up first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:90,Availability,alive,alive,90,"// We notified the preprocessor of EOF already, so detach it first.; // Sema needs the PP alive until after EndSourceFile() though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:11,Availability,alive,alive,11,// Keep PP alive for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:61,Safety,safe,safely,61,"// Destroy ASTContext and Sema.; // Now Sema is gone, PP can safely be destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp:72,Performance,concurren,concurrent,72,// Each thread gets an independent copy of a VFS to allow different; // concurrent working directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp:106,Modifiability,plugin,plugin,106,// This anchor is used to force the linker to link in the generated object file; // and thus register the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/AllTUsExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:463,Integrability,interface,interface,463,"//===- ArgumentsAdjusters.cpp - Command line arguments adjuster -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains definitions of classes which implement ArgumentsAdjuster; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:38,Integrability,depend,dependency,38,"// When not using the cl driver mode, dependency file generation options; // begin with -M. These include -MM, -MF, -MG, -MP, -MT, -MQ, -MD, and; // -MMD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:32,Integrability,depend,dependency,32,"// Under MSVC's cl driver mode, dependency file generation is controlled; // using /showIncludes",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:66,Modifiability,plugin,plugin,66,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:121,Modifiability,plugin,plugin,121,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:130,Modifiability,plugin,plugin-arg,130,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:142,Modifiability,plugin,plugin-name,142,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:161,Modifiability,plugin,plugin,161,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp:114,Performance,load,load,114,"// According to https://clang.llvm.org/docs/ClangPlugins.html; // plugin arguments are in the form:; // -Xclang {-load, -plugin, -plugin-arg-<plugin-name>, -add-plugin}; // -Xclang <arbitrary-argument>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ArgumentsAdjusters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:588,Integrability,interface,interface,588,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:798,Integrability,message,messages,798,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp:838,Integrability,interface,interface,838,"//===--- CommonOptionsParser.cpp - common options for clang tools ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CommonOptionsParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:547,Availability,Error,ErrorMessage,547,"//===- CompilationDatabase.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains implementations of the CompilationDatabase base class; // and the FixedCompilationDatabase.; //; // FIXME: Various functions that take a string &ErrorMessage should be upgraded; // to Expected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:570,Deployability,upgrade,upgraded,570,"//===- CompilationDatabase.cpp --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains implementations of the CompilationDatabase base class; // and the FixedCompilationDatabase.; //; // FIXME: Various functions that take a string &ErrorMessage should be upgraded; // to Expected.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:44,Deployability,integrat,integrated-as,44,"// Filter of tools unused flags such as -no-integrated-as and -Wa,*.; // They are not used for syntax checking, and could confuse targets; // which don't support these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:44,Integrability,integrat,integrated-as,44,"// Filter of tools unused flags such as -no-integrated-as and -Wa,*.; // They are not used for syntax checking, and could confuse targets; // which don't support these options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:632,Availability,avail,available,632,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:690,Integrability,interface,interface,690,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:729,Usability,clear,clear,729,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:54,Safety,detect,detect,54,"// This becomes the new argv[0]. The value is used to detect libc++ include; // dirs on Mac, it isn't used for other platforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:277,Availability,fault,fault,277,"// Put a dummy C++ file on to ensure there's at least one compile job for the; // driver to construct. If the user specified some other argument that; // prevents compilation, e.g. -E or something like -version, we may still end; // up with no jobs but then this is the user's fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:303,Safety,abort,abort,303,"/// Inserts 'NewPath' into this trie. \c ConsumedLength denotes; /// the number of \c NewPath's trailing characters already consumed during; /// recursion.; ///; /// An insert of a path; /// 'p'starts at the root node and does the following:; /// - If the node is empty, insert 'p' into its storage and abort.; /// - If the node has a path 'p2' but no children, take the last path segment; /// 's' of 'p2', put a new child into the map at 's' an insert the rest of; /// 'p2' there.; /// - Insert a new child for the last segment of 'p' and insert the rest of; /// 'p' there.; ///; /// An insert operation is linear in the number of a path's segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:1225,Availability,error,error,1225,"/// Tries to find the node under this \c FileMatchTrieNode that best; /// matches 'FileName'.; ///; /// If multiple paths fit 'FileName' equally well, \c IsAmbiguous is set to; /// \c true and an empty string is returned. If no path fits 'FileName', an; /// empty string is returned. \c ConsumedLength denotes the number of; /// \c Filename's trailing characters already consumed during recursion.; ///; /// To find the best matching node for a given path 'p', the; /// \c findEquivalent() function is called recursively for each path segment; /// (back to front) of 'p' until a node 'n' is reached that does not ..; /// - .. have children. In this case it is checked; /// whether the stored path is equivalent to 'p'. If yes, the best match is; /// found. Otherwise continue with the parent node as if this node did not; /// exist.; /// - .. a child matching the next path segment. In this case, all children of; /// 'n' are an equally good match for 'p'. All children are of 'n' are found; /// recursively and their equivalence to 'p' is determined. If none are; /// equivalent, continue with the parent node as if 'n' didn't exist. If one; /// is equivalent, the best match is found. Otherwise, report and ambigiuity; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:48,Performance,perform,performance,48,// Note: we support only directory symlinks for performance reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:76,Safety,avoid,avoid,76,"// As far as we do not support file symlinks, compare; // basenames here to avoid request to file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:1301,Availability,avail,available,1301,"nother CompilationDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must cross languages, we drop any -x and -std flags.; // - For .h files, candidates from any c-family language are acceptable.; // We use the candidate's language, inserting e.g. -x c++-header.; //; // This class is only useful when wrapping databases that can enumerate all; // their compile commands. If getAllFilenames() is empty, no inference occurs.; //; //===--------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:416,Integrability,wrap,wraps,416,"//===- InterpolatingCompilationDatabase.cpp ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InterpolatingCompilationDatabase wraps another CompilationDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:2230,Integrability,wrap,wrapping,2230,"tionDatabase and; // attempts to heuristically determine appropriate compile commands for files; // that are not included, such as headers or newly created files.; //; // Motivating cases include:; // Header files that live next to their implementation files. These typically; // share a base filename. (libclang/CXString.h, libclang/CXString.cpp).; // Some projects separate headers from includes. Filenames still typically; // match, maybe other path segments too. (include/llvm/IR/Use.h, lib/IR/Use.cc).; // Matches are sometimes only approximate (Sema.h, SemaDecl.cpp). This goes; // for directories too (Support/Unix/Process.inc, lib/Support/Process.cpp).; // Even if we can't find a ""right"" compile command, even a random one from; // the project will tend to get important flags like -I and -x right.; //; // We ""borrow"" the compile command for the closest available file:; // - points are awarded if the filename matches (ignoring extension); // - points are awarded if the directory structure matches; // - ties are broken by length of path prefix match; //; // The compile command is adjusted, replacing the filename and removing output; // file arguments. The -x and -std flags may be affected too.; //; // Source language is a tricky issue: is it OK to use a .c file's command; // for building a .cc file? What language is a .h file in?; // - We only consider compile commands for c-family languages as candidates.; // - For files whose language is implied by the filename (e.g. .m, .hpp); // we prefer candidates from the same language.; // If we must cross languages, we drop any -x and -std flags.; // - For .h files, candidates from any c-family language are acceptable.; // We use the candidate's language, inserting e.g. -x c++-header.; //; // This class is only useful when wrapping databases that can enumerate all; // their compile commands. If getAllFilenames() is empty, no inference occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:12,Safety,detect,detected,12,// Language detected from -x or the filename. Never TY_INVALID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the old arguments in an InputArgList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:7,Integrability,contract,contract,7,// The contract is to store None instead of TY_INVALID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:115,Safety,avoid,avoid,115,"// Produce a CompileCommand for \p filename, based on this one.; // (This consumes the TransferableCommand just to avoid copying Cmd).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:457,Testability,log,log,457,"// Given a filename, FileIndex picks the best matching file from the underlying; // DB. This is the proxy file whose CompileCommand will be reused. The; // heuristics incorporate file name, extension, and directory structure.; // Strategy:; // - Build indexes of each of the substrings we want to look up by.; // These indexes are just sorted lists of the substrings.; // - Each criterion corresponds to a range lookup into the index, so we only; // need O(log N) string comparisons to determine scores.; //; // Apart from path proximity signals, also takes file extensions into account; // when scoring the candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:3,Performance,Perform,Performs,3,"// Performs a point lookup into a nonempty index, returning a longest match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:34,Integrability,wrap,wrapper,34,"// The actual CompilationDatabase wrapper delegates to its inner database.; // If no match, looks up a proxy file in FileIndex and transfers its; // command to the requested file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:58,Availability,avail,available,58,// All private methods return true if there is more input available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:8,Modifiability,plugin,plugin,8,"// This plugin locates a nearby compile_command.json file, and also infers; // compile commands for files not present in the database.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:141,Modifiability,variab,variable,141,// namespace; // Register the JSONCompilationDatabasePlugin with the; // CompilationDatabasePluginRegistry using this statically initialized variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:22,Integrability,wrap,wrappers,22,"// There are compiler-wrappers (ccache, distcc, gomacc) that take the ""real""; // compiler as an argument, e.g. distcc gcc -O3 foo.c.; // These end up in compile_commands.json when people set CC=""distcc gcc"".; // Clang's driver doesn't understand this, so we need to unwrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:17,Integrability,wrap,wrappers,17,"// Most of these wrappers support being invoked 3 ways:; // `distcc g++ file.c` This is the mode we're trying to match.; // We need to drop `distcc`.; // `distcc file.c` This acts like compiler is cc or similar.; // Clang's driver can handle this, no change needed.; // `g++ file.c` g++ is a symlink to distcc.; // We don't even notice this case, and all is well.; //; // We need to distinguish between the first and second case.; // The wrappers themselves don't take flags, so Args[1] is a compiler flag,; // an input file, or a compiler. Inputs have extensions, compilers don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:438,Integrability,wrap,wrappers,438,"// Most of these wrappers support being invoked 3 ways:; // `distcc g++ file.c` This is the mode we're trying to match.; // We need to drop `distcc`.; // `distcc file.c` This acts like compiler is cc or similar.; // Clang's driver can handle this, no change needed.; // `g++ file.c` g++ is a symlink to distcc.; // We don't even notice this case, and all is well.; //; // We need to distinguish between the first and second case.; // The wrappers themselves don't take flags, so Args[1] is a compiler flag,; // an input file, or a compiler. Inputs have extensions, compilers don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:20,Integrability,wrap,wrappers,20,"// If !HasCompiler, wrappers act like GCC. Fine: so do we.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:25,Integrability,wrap,wrappers,25,// There may be multiple wrappers: using distcc and ccache together is common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:9,Modifiability,Refactor,Refactoring,9,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:47,Modifiability,refactor,refactoring,47,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp:411,Modifiability,refactor,refactorings,411,"//===--- Refactoring.cpp - Framework for clang refactoring tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements tools to support refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:9,Modifiability,Refactor,RefactoringCallbacks,9,"//===--- RefactoringCallbacks.cpp - Structural query framework ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:68,Usability,Clear,Clear,68,// The ASTMatchRefactorer is re-used between translation units.; // Clear the matchers so that each Replacement is only emitted once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:17,Availability,error,error,17,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:53,Availability,error,error,53,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:78,Deployability,release,release,78,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,Integrability,message,message,59,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp:106,Modifiability,plugin,plugin,106,// This anchor is used to force the linker to link in the generated object file; // and thus register the plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/StandaloneExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:477,Modifiability,plugin,plugin,477,"//===- Tooling.cpp - Running clang standalone tools -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions to run clang tools standalone instead; // of running them as a plugin.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:143,Modifiability,refactor,refactor,143,"// FIXME: This file contains structural duplication with other parts of the; // code that sets up a compiler to run tools on it, and we should refactor; // it to be based on the same framework.; /// Builds a clang driver initialized for running clang tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:40,Integrability,depend,depending,40,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:80,Integrability,inject,injected,80,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:80,Security,inject,injected,80,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:43,Integrability,wrap,wrapped,43,// On MacOSX real actions may end up being wrapped in BindArchAction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:43,Integrability,wrap,wrapped,43,// On MacOSX real actions may end up being wrapped in; // BindArchAction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:212,Modifiability,variab,variable,212,"// The FrontendAction can have lifetime requirements for Compiler or its; // members, and we need to ensure it's deleted earlier than Compiler. So we; // pass it to an std::unique_ptr declared after the Compiler variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:346,Integrability,interface,interface,346,"// Currently implementations of CompilationDatabase::getCompileCommands can; // change the state of the file system (e.g. prepare generated headers), so; // this method needs to run right before we invoke the tool, as the next; // file may require a different (incompatible) state of the file system.; //; // FIXME: Make the compilation database interface more explicit about the; // requirements to the order of invocation of its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:402,Integrability,depend,depends,402,"// FIXME: chdir is thread hostile; on the other hand, creating the same; // behavior as chdir is complex: chdir resolves the path once, thus; // guaranteeing that all subsequent relative path operations work; // on the same path the original chdir resulted in. This makes a; // difference for example on network filesystems, where symlinks might be; // switched during runtime of the tool. Fixing this depends on having a; // file system abstraction that allows openat() style interactions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:86,Integrability,message,message,86,// FIXME: We need a callback mechanism for the tool writer to output a; // customized message for each file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:438,Integrability,interface,interface,438,"//===- ASTDiff.cpp - AST differencing implementation-----------*- C++ -*- -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains definitons for the AST differencing interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:166,Deployability,update,update,166,"/// Implementation of Zhang and Shasha's Algorithm for tree edit distance.; /// Computes an optimal mapping between two trees using only insertion,; /// deletion and update as edit actions (similar to the Levenshtein distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:162,Performance,perform,perform,162,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:280,Safety,avoid,avoided,280,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:13,Usability,simpl,simple,13,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:79,Usability,Simpl,Simple,79,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:12,Performance,queue,queue,12,"// Priority queue for nodes, sorted descendingly by their height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp:430,Modifiability,refactor,refactoring,430,"//===--- Diagnostic.cpp - Framework for clang diagnostics tools ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store diagnostics refactoring.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp:99,Integrability,depend,depends,99,"// Don't store offset in the scratch space. It doesn't tell anything to the; // user. Moreover, it depends on the history of macro expansions and thus; // prevents deduplication of warnings in headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:45,Modifiability,refactor,refactoring,45,"//===- Replacement.cpp - Framework for clang refactoring tools ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:419,Modifiability,refactor,refactorings,419,"//===- Replacement.cpp - Framework for clang refactoring tools ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements classes to support/store refactorings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:167,Deployability,integrat,integrate,167,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:167,Integrability,integrat,integrate,167,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:96,Modifiability,refactor,refactoring,96,"// FIXME: This should go into the Lexer, but we need to figure out how; // to handle ranges for refactoring in general first - there is no obvious; // good way how to integrate this into the Lexer yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:106,Safety,safe,safe,106,"// Insertion `R` is adjacent to a non-insertion replacement `I`, so they; // are order-independent. It is safe to assume that `R` will not conflict; // with any replacement before `I` since all replacements before `I` must; // either end before `R` or end at `R` but has length > 0 (if the; // replacement before `I` is an insertion at `R`, it would have been `I`; // since it is a lower bound of `AtEnd` and ordered before the current `I`; // in the set).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:53,Safety,safe,safe,53,"// If `R` and `I` do not have the same offset, it is safe to add `R` since; // it must come after `I`. Otherwise:; // - If `R` is an insertion, `I` must not be an insertion since it would; // have come after `AtEnd`.; // - If `R` is not an insertion, `I` must be an insertion; otherwise, `R`; // and `I` would have overlapped.; // In either case, we can safely insert `R`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:354,Safety,safe,safely,354,"// If `R` and `I` do not have the same offset, it is safe to add `R` since; // it must come after `I`. Otherwise:; // - If `R` is an insertion, `I` must not be an insertion since it would; // have come after `AtEnd`.; // - If `R` is not an insertion, `I` must be an insertion; otherwise, `R`; // and `I` would have overlapped.; // In either case, we can safely insert `R`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:939,Modifiability,extend,extend,939,"// Represents a merged replacement, i.e. a replacement consisting of multiple; // overlapping replacements from 'First' and 'Second' in mergeReplacements.; //; // Position projection:; // Offsets and lengths of the replacements can generally refer to two different; // coordinate spaces. Replacements from 'First' refer to the original text; // whereas replacements from 'Second' refer to the text after applying 'First'.; //; // MergedReplacement always operates in the coordinate space of the original; // text, i.e. transforms elements from 'Second' to take into account what was; // changed based on the elements from 'First'.; //; // We can correctly calculate this projection as we look at the replacements in; // order of strictly increasing offsets.; //; // Invariants:; // * We always merge elements from 'First' into elements from 'Second' and vice; // versa. Within each set, the replacements are non-overlapping.; // * We only extend to the right, i.e. merge elements with strictly increasing; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:115,Deployability,update,update,115,// Sum of all deltas (text-length - length) of elements from 'First' merged; // into this element. This is used to update 'Delta' once the; // MergedReplacement is completed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:106,Modifiability,extend,extended,106,// Data of the actually merged replacement. FilePath and Offset aren't changed; // as the element is only extended to the right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:7,Integrability,Depend,DependencyScanningFilesystem,7,"//===- DependencyScanningFilesystem.cpp - clang-scan-deps fs --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:3,Performance,Load,Load,3,// Load the file and its content from the file system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:71,Integrability,depend,dependencies,71,// Scan the file for preprocessor directives that might affect the; // dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:17,Performance,perform,performed,17,"// This function performed double-checked locking using `DepDirectives`.; // Assigning it must be the last thing this function does, otherwise other; // threads may skip the; // critical section (`DepDirectives != nullptr`), leading to a data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:130,Performance,cache,cache,130,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:157,Performance,perform,performance,157,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:47,Testability,test,testing,47,// This heuristic was chosen using a empirical testing on a; // reasonably high core machine (iMacPro 18 cores / 36 threads). The cache; // sharding gives a performance edge by reducing the lock contention.; // FIXME: A better heuristic might also consider the OS to account for; // the different cost of lock contention on different OSes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:63,Availability,failure,failures,63,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:26,Performance,cache,cache,26,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:52,Performance,cache,cache,52,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:50,Performance,Cache,CachedFileSystemEntry,50,/// The VFS that is used by clang consumes the \c CachedFileSystemEntry using; /// this subclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp:7,Integrability,Depend,DependencyScanningService,7,"//===- DependencyScanningService.cpp - clang-scan-deps service ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningService.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:7,Integrability,Depend,DependencyScanningTool,7,"//===- DependencyScanningTool.cpp - clang-scan-deps service ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:35,Integrability,depend,dependencies,35,/// Prints out all of the gathered dependencies into a string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:9,Safety,Avoid,Avoid,9,// TODO: Avoid handleModuleDependency even being called for modules; // we've already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:9,Safety,Avoid,Avoid,9,// TODO: Avoid handleModuleDependency even being called for modules; // we've already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:7,Integrability,Depend,DependencyScanningWorker,7,"//===- DependencyScanningWorker.cpp - clang-scan-deps worker --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:28,Integrability,depend,dependencies,28,/// Forwards the gatherered dependencies to the consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:2,Security,Validat,ValidateDiagnosticOptions,2,/*ValidateDiagnosticOptions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:15,Integrability,depend,dependency,15,/// Deduce the dependency target based on the output file and input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:36,Integrability,depend,dependency,36,/// Sanitize diagnostic options for dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:4,Security,Sanitiz,Sanitize,4,/// Sanitize diagnostic options for dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:33,Availability,error,errors,33,// Don't print 'X warnings and Y errors generated'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:26,Availability,error,errors,26,// Don't emit warnings as errors (and all other warnings too).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:80,Integrability,depend,dependency,80,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:61,Performance,optimiz,optimized,61,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:146,Deployability,update,update,146,"// Scanning runs once for the first -cc1 invocation in a chain of driver; // jobs. For any dependent jobs, reuse the scanning result and just; // update the LastCC1Arguments to correspond to the new invocation.; // FIXME: to support multi-arch builds, each arch requires a separate scan",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:91,Integrability,depend,dependent,91,"// Scanning runs once for the first -cc1 invocation in a chain of driver; // jobs. For any dependent jobs, reuse the scanning result and just; // update the LastCC1Arguments to correspond to the new invocation.; // FIXME: to support multi-arch builds, each arch requires a separate scan",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:11,Integrability,depend,dependency,11,// Use the dependency scanning optimized file system if requested to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:31,Performance,optimiz,optimized,31,// Use the dependency scanning optimized file system if requested to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:14,Integrability,depend,dependency,14,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:70,Integrability,depend,dependencies,70,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:121,Integrability,depend,dependency,121,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:283,Integrability,depend,dependency,283,"// Create the dependency collector that will collect the produced; // dependencies.; //; // This also moves the existing dependency output options from the; // invocation to the collector. The options in the invocation are reset,; // which ensures that the compiler won't create new dependency collectors,; // and thus won't write out the extra '.d' files to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:65,Integrability,depend,dependency,65,// We need at least one -MT equivalent for the generator of make dependency; // files to work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:189,Energy Efficiency,reduce,reduce,189,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:97,Safety,avoid,avoids,97,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:229,Security,hash,hashing,229,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:49,Performance,load,loading,49,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:3,Safety,Avoid,Avoid,3,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:143,Integrability,depend,dependencies,143,/// Take the cc1 arguments corresponding to the most recent invocation used; /// with this action. Any modifications implied by the discovered dependencies; /// will have already been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:86,Availability,failure,failure,86,// Capture the emitted diagnostics and report them to the client; // in the case of a failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:47,Integrability,depend,dependency,47,// Non-clang command. Just pass through to the dependency; // consumer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:163,Integrability,depend,dependency,163,// Create an invocation that uses the underlying file; // system to ensure that any file system requests that; // are made by the driver do not go through the; // dependency scanning filesystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:56,Integrability,depend,dependency,56,// Only preserve search paths that were used during the dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:76,Performance,optimiz,optimize,76,"// If this is not a system module or -Wsystem-headers was passed, don't; // optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:21,Integrability,depend,dependency,21,"// Fallback to -o as dependency target, as in the driver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:90,Security,hash,hash,90,"// Map output paths that affect behaviour to ""-"" so their existence is in the; // context hash. The final path will be computed in addOutputPaths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:42,Usability,simpl,simplify,42,// TODO: Track these as `FileEntryRef` to simplify the equality check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:54,Integrability,depend,dependency,54,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:47,Performance,load,loaded,47,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:198,Performance,load,loaded,198,"// Don't report module maps describing eagerly-loaded dependency. This; // information will be deserialized from the PCM.; // TODO: Verify this works fine when modulemap for module A is eagerly; // loaded from A.pcm, and module map passed on the command line contains; // definition of a submodule: ""explicit module A.Private { ... }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:85,Integrability,depend,dependency,85,// Don't report module map file of the current module unless it also; // describes a dependency (for symmetry).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:31,Integrability,depend,dependencies,31,// Add module file inputs from dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:32,Performance,load,load,32,// Only pcm is needed for eager load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:63,Integrability,depend,dependencies,63,// TODO: Report module maps the same way it's done for modular dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,// Hash the compiler version and serialization version to ensure the module; // will be readable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,// Hash the BuildInvocation without any input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,Integrability,depend,dependencies,19,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:104,Integrability,depend,depend,104,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:261,Performance,optimiz,optimization,261,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Security,Hash,Hash,3,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:41,Security,hash,hash,41,// This has to be delayed as the context hash can change at the start of; // `CompilerInstance::ExecuteAction`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:3,Integrability,Depend,Dependency,3,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:124,Integrability,depend,depended,124,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:180,Integrability,depend,dependency,180,// Dependency generation really does want to go all the way to the; // file entry for a source location to find out what is depended on.; // We do not want #line markers to affect dependency generation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:22,Integrability,depend,dependencies,22,// Only report direct dependencies that were successfully handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:215,Integrability,depend,dependencies,215,// A top-level module might not be actually imported as a module when; // -fmodule-name is used to compile a translation unit that imports this; // module. In that case it can be skipped. The appropriate header; // dependencies will still be reported as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:44,Integrability,depend,dependencies,44,// Finish the compiler invocation. Requires dependencies and the context hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:73,Security,hash,hash,73,// Finish the compiler invocation. Requires dependencies and the context hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,Integrability,depend,depends,19,"// Submodule order depends on order of header includes for inferred submodules; // we don't care about the exact order, so sort so that it's consistent across; // TUs to improve sharing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:125,Integrability,depend,dependencies,125,"// Within P1689 format, we don't want all the paths to be absolute path; // since it may violate the tranditional make style dependencies info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp:187,Safety,avoid,avoid,187,// The clang AST has several methods on base classes which are overriden; // pseudo-virtually by derived classes.; // We record only the pseudo-virtual methods on the base classes to; // avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:15,Availability,error,errors,15,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:44,Integrability,message,messages,44,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:15,Availability,error,error,15,// Is Line an #error directive mentioning includes?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:47,Safety,avoid,avoid,47,"// Strip off whitespace and comment markers to avoid confusion. This isn't; // fully-compatible with IWYU, which splits into whitespace-delimited tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp:187,Safety,avoid,avoid,187,"// Returns the offset of the last #include directive after which a new; // #include can be inserted. This ignores #include's after the #include block(s); // in the beginning of a file to avoid inserting headers into code sections; // where new #include's should not be added by default.; // These code sections include:; // - raw string literals (containing #include).; // - #if blocks.; // - Special #include's among declarations (e.g. functions).; //; // If no #include after which a new #include can be inserted, this returns the; // offset after skipping all comments from the start of the code.; // Inserting after an #include is not allowed if it comes after code that is not; // #include (e.g. pre-processing directive that is not #include, declarations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp:46,Availability,avail,available,46,"// First symbol or new symbol, increment next available index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/Stdlib/StandardLibrary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:34,Modifiability,refactor,refactoring,34,"//===--- ASTSelection.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Safety,Avoid,Avoid,3,// Avoid traversing the semantic expressions. They should be handled by; // looking through the appropriate opaque expressions in order to build; // a meaningful selection tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Safety,Avoid,Avoid,3,// Avoid selecting implicit 'this' expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:111,Testability,test,test,111,"// Select the parent expression when:; // - The string literal in ObjC string literal is selected, e.g.:; // @""test"" becomes @""test""; // ~~~~~~ ~~~~~~~",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:127,Testability,test,test,127,"// Select the parent expression when:; // - The string literal in ObjC string literal is selected, e.g.:; // @""test"" becomes @""test""; // ~~~~~~ ~~~~~~~",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:323,Modifiability,Refactor,Refactor,323,"// FIXME (Alex L): First selected SwitchCase means that first case statement.; // is selected actually; // (See https://github.com/apple/swift-clang & CompoundStmtRange).; // FIXME (Alex L): Tweak selection rules for compound statements, see:; // https://github.com/apple/swift-clang/blob/swift-4.1-branch/lib/Tooling/; // Refactor/ASTSlice.cpp#L513; // The user selected multiple statements in a compound statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:19,Testability,Test,Test,19,// FIXME (Alex L): Test for BlockDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:46,Safety,avoid,avoid,46,"// Stop the search at any type declaration to avoid returning true for; // expressions in type declarations in functions, like:; // function foo() { struct X {; // int m = /*selection:*/ 1 + 2 /*selection end*/; }; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp:46,Modifiability,refactor,refactoring,46,"//===--- ASTSelectionRequirements.cpp - Clang refactoring library ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelectionRequirements.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp:76,Security,access,access,76,/// Helper to (de)serialize an AtomicChange since we don't have direct; /// access to its data members.; /// Data members of a normalized AtomicChange can be directly mapped from/to; /// YAML string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/AtomicChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:42,Modifiability,refactor,refactoring,42,"//===--- Lookup.cpp - Framework for clang refactoring tools ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:432,Performance,perform,performing,432,"//===--- Lookup.cpp - Framework for clang refactoring tools ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,Availability,redundant,redundant,23,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,Safety,redund,redundant,23,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:368,Availability,error,error,368,"// Adds more scope specifier to the spelled name until the spelling is not; // ambiguous. A spelling is ambiguous if the resolution of the symbol is; // ambiguous. For example, if QName is ""::y::bar"", the spelling is ""y::bar"", and; // context contains a nested namespace ""a::y"", then ""y::bar"" can be resolved to; // ::a::y::bar in the context, which can cause compile error.; // FIXME: consider using namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:295,Modifiability,refactor,refactor,295,"// We can do a raw name replacement when we are not inside the namespace for; // the original class/function and it is not in the global namespace. The; // assumption is that outside the original namespace we must have a using; // statement that makes this work out and that other parts of this refactor; // will automatically fix using statements to point to the new class/function.; // However, if the `FromDecl` is a class forward declaration, the reference is; // still considered as referring to the original definition, so we can't do a; // raw name replacement in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:9,Modifiability,Refactor,RefactoringActions,9,"//===--- RefactoringActions.cpp - Constructs refactoring actions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:45,Modifiability,refactor,refactoring,45,"//===--- RefactoringActions.cpp - Constructs refactoring actions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:33,Safety,avoid,avoid,33,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:21,Modifiability,refactor,refactoring,21,/// Returns a set of refactoring actions rules that are defined by this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:33,Safety,avoid,avoid,33,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:21,Modifiability,refactor,refactoring,21,/// Returns a set of refactoring actions rules that are defined by this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:29,Modifiability,refactor,refactoring,29,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:421,Modifiability,refactor,refactoring,421,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:500,Modifiability,variab,variables,500,"//===--- Extract.cpp - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Implements the ""extract"" refactoring that can pull code into; /// new functions, methods or declare new variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:30,Usability,simpl,simple,30,/// Returns true if \c E is a simple literal or a reference expression that; /// should not be extracted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:114,Modifiability,variab,variable,114,// We would like to extract code out of functions/methods/blocks.; // Prohibit extraction from things like global variable / field; // initializers and other top-level expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:3,Safety,Avoid,Avoid,3,// Avoid extraction of simple literals and references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:23,Usability,simpl,simple,23,// Avoid extraction of simple literals and references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:23,Modifiability,variab,variables,23,// FIXME: Capture used variables.; // Compute the return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:30,Usability,user-friendly,user-friendly,30,// FIXME (Alex L): Get a more user-friendly type if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:10,Modifiability,Rewrite,Rewrite,10,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:174,Modifiability,variab,variables,174,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:37,Performance,perform,performing,37,// FIXME: Rewrite the extracted code performing any required adjustments.; // FIXME: Capture any field if necessary (method -> function extraction).; // FIXME: Sort captured variables by name.; // FIXME: Capture 'this' / 'self' if necessary.; // FIXME: Compute the actual parameter types.; // Compute the location of the extracted declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp:38,Modifiability,refactor,refactoring,38,"//===--- SourceExtraction.cpp - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/SourceExtraction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:36,Modifiability,refactor,refactoring,36,"//===--- RenamingAction.cpp - Clang refactoring library -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to rename every symbol at a point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:55,Availability,error,error,55,// FIXME: Support multi-piece names.; // FIXME: better error handling (propagate error out).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:81,Availability,error,error,81,// FIXME: Support multi-piece names.; // FIXME: better error handling (propagate error out).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp:48,Modifiability,refactor,refactoring,48,// FIXME: Apply AtomicChanges directly once the refactoring APIs are; // ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/RenamingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp:39,Modifiability,refactor,refactoring,39,"//===--- SymbolOccurrences.cpp - Clang refactoring library ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/SymbolOccurrences.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:31,Modifiability,refactor,refactoring,31,"//===--- USRFinder.cpp - Clang refactoring library ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Implements a recursive AST visitor that finds the USR of a symbol at a; /// point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:14,Testability,test,tests,14,// FIXME: Add tests for Point == End.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:34,Availability,down,down,34,// Try to be clever about pruning down the number of top-level declarations we; // see. If both start and end is either before or after the point we're; // looking for the point cannot be inside of this decl. Don't even look at it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp:14,Testability,test,test,14,// FIXME: Add test for the nullptr case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp:38,Modifiability,refactor,refactoring,38,"//===--- USRFindingAction.cpp - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to find USR for the symbol at <offset>, as well as; /// all additional USRs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp:116,Deployability,update,update,116,"// FIXME: (Alex L): Canonicalize implicit template instantions, just like; // the indexer does it.; // Note: please update the declaration's doc comment every time the; // canonicalization rules are changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRFindingAction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:34,Modifiability,refactor,refactoring,34,"//===--- USRLocFinder.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Methods for finding all instances of a USR. Our strategy is very; /// simple; we just compare the USR at every relevant AST node with the one; /// provided.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:466,Usability,simpl,simple,466,"//===--- USRLocFinder.cpp - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Methods for finding all instances of a USR. Our strategy is very; /// simple; we just compare the USR at every relevant AST node with the one; /// provided.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:158,Safety,avoid,avoid,158,"// Determine whether the prefix qualifiers of the NewName should be ignored.; // Normally, we set it to true for the symbol declaration and definition to; // avoid adding prefix qualifiers.; // For example, if it is true and NewName is ""a::b::foo"", then the symbol; // occurrence which the RenameInfo points to will be renamed to ""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:157,Energy Efficiency,Green,Green,157,"// In case of renaming an enum declaration, we have to explicitly handle; // unscoped enum constants referenced in expressions (e.g.; // ""auto r = ns1::ns2::Green"" where Green is an enum constant of an unscoped; // enum decl ""ns1::ns2::Color"") as these enum constants cannot be caught by; // TypeLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:170,Energy Efficiency,Green,Green,170,"// In case of renaming an enum declaration, we have to explicitly handle; // unscoped enum constants referenced in expressions (e.g.; // ""auto r = ns1::ns2::Green"" where Green is an enum constant of an unscoped; // enum decl ""ns1::ns2::Color"") as these enum constants cannot be caught by; // TypeLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:67,Energy Efficiency,Green,Green,67,// FIXME: Handle the enum constant without prefix qualifiers (`a = Green`); // when renaming an unscoped enum declaration with a new namespace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:44,Energy Efficiency,Green,Green,44,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:76,Energy Efficiency,Green,Green,76,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:208,Energy Efficiency,Green,Green,208,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:94,Integrability,interface,interface,94,"// Handle cases of nested name specificier locations.; //; // The VisitNestedNameSpecifierLoc interface is not impelmented in; // RecursiveASTVisitor, we have to handle it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:60,Deployability,update,update,60,// Returns a list of using declarations which are needed to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:193,Usability,simpl,simply,193,"// This fixes the case where type `T` is a parameter inside a function; // type (e.g. `std::function<void(T)>`) and the DeclContext of `T`; // becomes the translation unit. As a workaround, we simply use; // fully-qualified name here for all references whose `DeclContext` is; // the translation unit and ignore the possible existence of; // using-decls (in the global scope) that can shorten the replaced; // name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:158,Integrability,wrap,wrapping,158,"// Ignores the implicit `CXXConstructExpr` for copy/move constructor calls; // generated by the compiler, as well as in implicit conversions like the one; // wrapping `1` in `X x = 1;`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:110,Integrability,wrap,wraps,110,// In:; // struct X {; // X(int); // };; // X x = X(1);; // Ignores the implicit `CXXFunctionalCastExpr` that wraps; // `CXXConstructExpr X(1)`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:98,Modifiability,inherit,inheritors,98,"// All other cases are not important, as they are either part of declaration; // specifiers (e.g. inheritors of TypeSpecTypeLoc) or introduce modifiers on; // existing declarators (e.g. QualifiedTypeLoc). They cannot start the; // declarator themselves, but their underlying type can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:3,Safety,avoid,avoid,3,// avoid recursing into the suffix of declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:163,Security,expose,expose,163,"/// Maintains a mapping from AST to syntax tree nodes. This class will get more; /// complicated as we support more kinds of AST nodes, e.g. TypeLocs.; /// FIXME: expose this as public API.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:194,Integrability,wrap,wraps,194,"/// Mark the \p Child node with a corresponding \p Role. All marked children; /// should be consumed by foldNode.; /// When called on expressions (clang::Expr is derived from clang::Stmt),; /// wraps expressions into expression statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:77,Integrability,wrap,wrapping,77,/// Should be called for expressions in non-statement position to avoid; /// wrapping into expression statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:66,Safety,avoid,avoid,66,/// Should be called for expressions in non-statement position to avoid; /// wrapping into expression statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:100,Usability,Simpl,SimpleDeclaration,100,/// Returns true if \p D is the last declarator in a chain and is thus; /// reponsible for creating SimpleDeclaration for the whole chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:215,Deployability,update,update,215,"/// A collection of trees covering the input tokens.; /// When created, each tree corresponds to a single token in the file.; /// Clients call 'foldChildren' to attach one or more subtrees to a parent; /// node and update the list of trees accordingly.; ///; /// Ensures that added nodes properly nest and cover the whole token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,Usability,Simpl,SimpleDeclaration,47,"// We want to consume the semicolon, make sure SimpleDeclaration does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:73,Integrability,Depend,DependentTemplateSpecializationType,73,// FIXME: Fix `NestedNameSpecifierLoc::getLocalSourceRange` for the; // `DependentTemplateSpecializationType` case.; /// Given a nested-name-specifier return the range for the last name; /// specifier.; ///; /// e.g. `std::T::template X<U>::` => `template X<U>::`,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:146,Integrability,Depend,DependentTemplateSpecializationType,146,"// The method `NestedNameSpecifierLoc::getLocalSourceRange` *should*; // return the desired `SourceRange`, but there is a corner case. For a; // `DependentTemplateSpecializationType` this method returns its; // qualifiers as well, in other words in the example above this method; // returns `T::template X<U>::` instead of only `template X<U>::`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,Integrability,depend,dependent,47,// The 'template' keyword is always present in dependent template; // specializations. Except in the case of incorrect code; // TODO: Treat the case of incorrect code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:72,Security,access,accessors,72,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:16,Usability,Simpl,SimpleTemplateNameSpecifier,16,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:123,Usability,simpl,simply,123,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:19,Security,access,accessor,19,"// TODO: Implement accessor to `DecltypeNameSpecifier` inner; // `DecltypeTypeLoc`.; // For that add mapping from `TypeLoc` to `syntax::Node*` then:; // Builder.markChild(TypeLoc, syntax::NodeRole);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:57,Usability,simpl,simple,57,"// For `MemberExpr` with implicit `this->` we generate a simple; // `id-expression` syntax node, beacuse an implicit `member-expression` is; // syntactically undistinguishable from an `id-expression`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:8,Testability,log,logic,8,// Same logic as DeclRefExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Testability,Assert,Assert,10,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have fixed; // the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:85,Testability,test,test,85,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have fixed; // the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:177,Usability,simpl,simple,177,"// To construct a syntax tree of the same shape for calls to built-in and; // user-defined operators, ignore the `DeclRefExpr` that refers to the; // operator and treat it as a simple token. Do that by traversing; // arguments instead of children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Testability,Assert,Assert,10,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have; // fixed the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:85,Testability,test,test,85,// FIXME: Assert that `LParenToken` is indeed a `l_paren` once we have; // fixed the test on decltype desctructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:70,Testability,test,test,70,// FIXME: Deleting the `TraverseParenTypeLoc` override doesn't change test; // results. Find test coverage or remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:93,Testability,test,test,93,// FIXME: Deleting the `TraverseParenTypeLoc` override doesn't change test; // results. Find test coverage or remove it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:10,Usability,Simpl,SimpleDeclarator,10,/// Folds SimpleDeclarator node (if present) and in case this is the last; /// declarator in the chain it also folds SimpleDeclaration node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:117,Usability,Simpl,SimpleDeclaration,117,/// Folds SimpleDeclarator node (if present) and in case this is the last; /// declarator in the chain it also folds SimpleDeclaration node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp:3,Modifiability,Extend,Extend,3,// Extend the current span.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/ComputeReplacements.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:18,Security,access,access,18,// This class has access to the internals of tree nodes. Its sole purpose is to; // define helpers that allow implementing the high-level mutation operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:44,Safety,safe,safely,44,// A child of CompoundStatement can just be safely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp:4,Security,Expose,Exposes,4,/// Exposes private syntax tree APIs required to implement node synthesis.; /// Should not be used for anything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp:3,Energy Efficiency,Allocate,Allocates,3,// Allocates the concrete syntax `Tree` according to its `NodeKind`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Synthesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:118,Security,validat,validating,118,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:316,Security,validat,validation,316,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:335,Usability,simpl,simple,335,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:84,Integrability,wrap,wrapped,84,"// Careful, given:; // #define HIDE ID(ID(a)); // ID(ID(HIDE)); // The token `a` is wrapped in 4 arg-expansions, we only want to unwrap 2.; // We distinguish them by whether the macro expands into the target file.; // Fortunately, the target file ones will always appear first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:3,Safety,Avoid,Avoid,3,// Avoid returning empty ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:172,Security,access,access,172,/// Disabled instance will stop reporting anything to TokenCollector.; /// This ensures that uses of the preprocessor after TokenCollector::consume(); /// is called do not access the (possibly invalid) collector instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:267,Modifiability,rewrite,rewrite,267,"// Only record top-level expansions that directly produce expanded tokens.; // This excludes those where:; // - the macro use is inside a macro body,; // - the macro appears in an argument to another macro.; // However macro expansion isn't really a tree, it's token rewrite rules,; // so there are other cases, e.g.; // #define B(X) X; // #define A 1 + B; // A(2); // Both A and B produce expanded tokens, though the macro name 'B' comes; // from an expansion. The best we can do is merge the mappings for both.; // The *last* token of any top-level macro expansion must be in a file.; // (In the example above, see the closing paren of the expansion of B).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:12,Safety,detect,detect,12,/// Used to detect recursive macro expansions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:45,Availability,recover,recover,45,"// And locations of macro calls, to properly recover boundaries of those in; // case of empty expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:45,Safety,recover,recover,45,"// And locations of macro calls, to properly recover boundaries of those in; // case of empty expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:163,Testability,log,logical,163,"// The expanded token stream consists of runs of tokens that came from; // the same source (a macro expansion, part of a file etc).; // Between these runs are the logical positions of spelled tokens that; // didn't expand to anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:225,Energy Efficiency,Drain,Drain,225,"// Consume a sequence of spelled tokens that didn't expand to anything.; // In the simplest case, skips spelled tokens until finding one that produced; // the NextExpanded token, and creates an empty mapping for them.; // If Drain is provided, skips remaining tokens from that file instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:83,Usability,simpl,simplest,83,"// Consume a sequence of spelled tokens that didn't expand to anything.; // In the simplest case, skips spelled tokens until finding one that produced; // the NextExpanded token, and creates an empty mapping for them.; // If Drain is provided, skips remaining tokens from that file instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp:10,Security,validat,validate,10,// FIXME: validate the role.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp:77,Testability,assert,assert,77,// FIXME: re-enable it when there is way to retrieve token kind in Leaf.; // assert(cast<Leaf>(C).getToken()->kind() == L->getDelimiterTokenKind());,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:78,Availability,error,error,78,// The original input. Not modified during parsing; only for reference in; // error reporting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:26,Availability,Error,ErrorInfo,26,// Required field for all ErrorInfo derivatives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:19,Availability,error,error,19,// Position of the error in the input string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:40,Availability,error,error,40,// Excerpt of the input starting at the error position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:93,Availability,Error,Error,93,"// Parses a single expected character \c c from \c State, skipping preceding; // whitespace. Error if the expected character isn't found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:163,Availability,error,error,163,"// Parses input for a stencil operator(single arg ops like AsValue, MemberOp or; // Id operator). Returns StencilType representing the operator on success and; // error if it fails to parse input for an operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:39,Modifiability,config,configurable,39,// FIXME: handling of macros should be configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:105,Modifiability,config,configurable,105,// Finds the start location of the previous token of kind \p TK.; // FIXME: handling of macros should be configurable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:61,Modifiability,extend,extend,61,"// Verify that the range covers exactly the name.; // FIXME: extend this code to support cases like `operator +` or; // `foo<int>` for which this range will be too short. Doing so will; // require subcasing `NamedDecl`, because it doesn't provide virtual; // access to the \c DeclarationNameInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:259,Security,access,access,259,"// Verify that the range covers exactly the name.; // FIXME: extend this code to support cases like `operator +` or; // `foo<int>` for which this range will be too short. Doing so will; // require subcasing `NamedDecl`, because it doesn't provide virtual; // access to the \c DeclarationNameInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:20,Availability,avail,available,20,"// FIXME: make this available in the public API for users to easily create their; // own selectors.; // Creates a selector from a range-selection function \p Func, which selects a; // range that is relative to a bound node id. \c T is the node type expected by; // \p Func.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:60,Availability,error,error,60,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:155,Availability,failure,failures,155,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:257,Availability,error,error,257,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:242,Safety,abort,abort,242,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:321,Safety,abort,abort,321,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:429,Safety,abort,abort,429,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:492,Usability,simpl,simply,492,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:286,Modifiability,Rewrite,RewriteRule,286,"/// Matches nodes of type T that have at least one descendant node for which the; /// given inner matcher matches. Will match for each descendant node that; /// matches. Based on ForEachDescendantMatcher, but takes a dynamic matcher,; /// instead of a static one, because it is used by RewriteRule, which carries; /// (only top-level) dynamic matchers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:23,Availability,error,error,23,// Initialize to a non-error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:3,Usability,Simpl,Simply,3,// Simply gathers the contents of the various rules into a single rule. The; // actual work to combine these into an ordered choice is deferred to matcher; // registration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:51,Integrability,rout,routines,51,"//===--- SourceCode.cpp - Source code manipulation routines -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:417,Usability,simpl,simplify,417,"//===--- SourceCode.cpp - Source code manipulation routines -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:701,Safety,safe,safely,701,"// First, lex to the current token (which is the last token of the range that; // is definitely associated with the decl). Then, we process the first token; // separately from the rest based on conditions that hold specifically for; // that first token.; //; // We do not search for a terminator if none is required or we've already; // encountered it. Otherwise, if the original `EntityLast` location was in a; // macro expansion, we don't have visibility into the text, so we assume we've; // already terminated. However, we note this assumption with; // `TerminatedByMacro`, because we'll want to handle it somewhat differently; // for the terminators semicolon and comma. These terminators can be safely; // associated with the entity when they appear after the macro -- extra; // semicolons have no effect on the program and a well-formed program won't; // have multiple commas in a row, so we're guaranteed that there is only one.; //; // FIXME: This handling of macros is more conservative than necessary. When; // the end of the expansion coincides with the end of the node, we can still; // safely analyze the code. But, it is more complicated, because we need to; // start by lexing the spelling loc for the first token and then switch to the; // expansion loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:1100,Safety,safe,safely,1100,"// First, lex to the current token (which is the last token of the range that; // is definitely associated with the decl). Then, we process the first token; // separately from the rest based on conditions that hold specifically for; // that first token.; //; // We do not search for a terminator if none is required or we've already; // encountered it. Otherwise, if the original `EntityLast` location was in a; // macro expansion, we don't have visibility into the text, so we assume we've; // already terminated. However, we note this assumption with; // `TerminatedByMacro`, because we'll want to handle it somewhat differently; // for the terminators semicolon and comma. These terminators can be safely; // associated with the entity when they appear after the macro -- extra; // semicolons have no effect on the program and a well-formed program won't; // have multiple commas in a row, so we're guaranteed that there is only one.; //; // FIXME: This handling of macros is more conservative than necessary. When; // the end of the expansion coincides with the end of the node, we can still; // safely analyze the code. But, it is more complicated, because we need to; // start by lexing the spelling loc for the first token and then switch to the; // expansion loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:3,Modifiability,Extend,Extend,3,"// Extend to the left '[[' or '__attribute((' if we saw the attribute,; // unless it is not a valid location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:26,Security,access,access,26,"// Append the appropriate access operation (syntactically) to `E`, assuming `E`; // is a non-pointer value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:26,Security,access,access,26,"// Append the appropriate access operation (syntactically) to `E`, assuming `E`; // is a pointer value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:78,Availability,failure,failure,78,"// Return the empty string, because `std::nullopt` signifies some sort of; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:85,Security,access,access,85,"// Strip off operator-> calls. They can only occur inside an actual arrow; // member access, so we treat them as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:83,Security,access,access,83,"// Strip off any operator->. This can only occur inside an actual arrow; // member access, so we treat it as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:83,Security,access,access,83,"// Strip off any operator->. This can only occur inside an actual arrow; // member access, so we treat it as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:62,Availability,error,error,62,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:164,Availability,failure,failure,164,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:72,Integrability,message,message,72,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:172,Integrability,message,message,172,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Security,Validat,Validate,3,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Security,Validat,Validate,3,"// Validate `Range`, because `makeFileCharRange` accepts some ranges that; // `validateRange` rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:79,Security,validat,validateRange,79,"// Validate `Range`, because `makeFileCharRange` accepts some ranges that; // `validateRange` rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:41,Security,access,access,41,"// A stencil operation to build a member access `e.m` or `e->m`, as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:31,Integrability,wrap,wrap,31,"// Only one argument, so don't wrap in sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:36,Deployability,install,installed,36,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:439,Deployability,install,installed,439,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp:414,Safety,detect,detecting,414,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system.; // This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:36,Deployability,install,installed,36,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:439,Deployability,install,installed,439,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp:414,Safety,detect,detecting,414,"//===- AMDGPUArch.cpp - list AMDGPU installed ----------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HIP runtime. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHIP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:41,Deployability,install,installed,41,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:440,Deployability,install,installed,440,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:415,Safety,detect,detecting,415,"//===- AMDGPUArchLinux.cpp - list AMDGPU installed ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of AMDGPU installed in system; // using HSA on Linux. This tool is used by AMDGPU OpenMP and HIP driver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp:14,Performance,load,load,14,// Attempt to load the HSA runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/amdgpu-arch/AMDGPUArchByHSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp:37,Testability,Test,Testing,37,"//===-- APINotesTest.cpp - API Notes Testing Tool ------------------ C++ --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/apinotes-test/APINotesTest.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:14,Testability,test,test,14,"//===-- arcmt-test.cpp - ARC Migration Tool testbed -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:44,Testability,test,testbed,44,"//===-- arcmt-test.cpp - ARC Migration Tool testbed -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:32,Testability,Test,TestResultForARC,32,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:50,Testability,test,test-result,50,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:83,Testability,Test,Test,83,"//static llvm::cl::opt<bool>; //TestResultForARC(""test-result"",; //llvm::cl::desc(""Test the result of transformations by parsing it in ARC mode""));",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp:10,Testability,Test,TestResultForARC,10,// FIXME: TestResultForARC,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/arcmt-test/arcmt-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:11,Testability,test,test,11,/* c-arcmt-test.c */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:147,Energy Efficiency,reduce,reduced,147,"/***/; /* We intentionally run in a separate thread to ensure we at least minimal; * testing of a multithreaded environment (for example, having a reduced stack; * size). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:85,Testability,test,testing,85,"/***/; /* We intentionally run in a separate thread to ensure we at least minimal; * testing of a multithreaded environment (for example, having a reduced stack; * size). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c:139,Performance,load,load,139,"/* stdout, and surprisingly even stderr, are not always flushed on process; * and thread exit, particularly when the system is under heavy load. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-arcmt-test/c-arcmt-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:11,Testability,test,test,11,/* c-index-test.c */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:56,Availability,failure,failure,56,"/** Returns 0 in case of success, non-zero in case of a failure. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:73,Modifiability,variab,variable,73,/* no llvm_unreachable in C. */; /* Set to NULL to prevent uninitialized variable warnings. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Testability,Log,Logic,85,/******************************************************************************/; /* Logic for testing traversal. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:95,Testability,test,testing,95,/******************************************************************************/; /* Logic for testing traversal. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:89,Testability,test,testing,89,/******************************************************************************/; /* USR testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:101,Testability,test,testing,101,/******************************************************************************/; /* Inclusion stack testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:93,Testability,test,testing,93,/******************************************************************************/; /* Linkage testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:96,Testability,test,testing,96,/******************************************************************************/; /* Visibility testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:94,Testability,test,testing,94,/******************************************************************************/; /* Typekind testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:63,Availability,avail,available,63,"/* Print ObjC base types, type arguments, and protocol list if available. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:46,Integrability,protocol,protocol,46,"/* Print ObjC base types, type arguments, and protocol list if available. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:94,Testability,test,testing,94,/******************************************************************************/; /* Mangling testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:94,Testability,test,testing,94,/******************************************************************************/; /* Bitwidth testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:102,Testability,test,testing,102,/******************************************************************************/; /* Type declaration testing */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:108,Testability,test,testing,108,/******************************************************************************/; /* Declaration attributes testing */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:104,Testability,test,testing,104,/******************************************************************************/; /* Target information testing. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Performance,Load,Loading,85,/******************************************************************************/; /* Loading ASTs/source. */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:3,Performance,Perform,Perform,3,/* Perform some simple filtering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:16,Usability,simpl,simple,16,/* Perform some simple filtering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:3,Performance,Load,Load,3,"/* Load the initial translation unit -- we do this without honoring remapped; * files, so that we have a way to test results after changing the source. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:112,Testability,test,test,112,"/* Load the initial translation unit -- we do this without honoring remapped; * files, so that we have a way to test results after changing the source. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Testability,Log,Logic,85,/******************************************************************************/; /* Logic for testing clang_getCursor(). */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:95,Testability,test,testing,95,/******************************************************************************/; /* Logic for testing clang_getCursor(). */; /******************************************************************************/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:296,Availability,failure,failure,296,"/******************************************************************************/; /* Logic for testing clang code completion. */; /******************************************************************************/; /* Parse file:line:column from the input string. Returns 0 on success, non-zero; on failure. If successful, the pointer *filename will contain newly-allocated; memory (that will be owned by the caller) to store the file name. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:361,Energy Efficiency,allocate,allocated,361,"/******************************************************************************/; /* Logic for testing clang code completion. */; /******************************************************************************/; /* Parse file:line:column from the input string. Returns 0 on success, non-zero; on failure. If successful, the pointer *filename will contain newly-allocated; memory (that will be owned by the caller) to store the file name. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Testability,Log,Logic,85,"/******************************************************************************/; /* Logic for testing clang code completion. */; /******************************************************************************/; /* Parse file:line:column from the input string. Returns 0 on success, non-zero; on failure. If successful, the pointer *filename will contain newly-allocated; memory (that will be owned by the caller) to store the file name. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:95,Testability,test,testing,95,"/******************************************************************************/; /* Logic for testing clang code completion. */; /******************************************************************************/; /* Parse file:line:column from the input string. Returns 0 on success, non-zero; on failure. If successful, the pointer *filename will contain newly-allocated; memory (that will be owned by the caller) to store the file name. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:42,Testability,test,testing,42,"/* Parse the translation unit. When we're testing clang_getCursor() after; reparsing, don't remap unsaved files until the second parse. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:42,Testability,test,testing,42,"/* Parse the translation unit. When we're testing clang_getCursor() after; reparsing, don't remap unsaved files until the second parse. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:42,Testability,test,testing,42,"/* Parse the translation unit. When we're testing clang_getCursor() after; reparsing, don't remap unsaved files until the second parse. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:36,Safety,safe,safe,36,"/* This code is not really all that safe, but it works fine for testing. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:64,Testability,test,testing,64,"/* This code is not really all that safe, but it works fine for testing. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:147,Energy Efficiency,reduce,reduced,147,"/***/; /* We intentionally run in a separate thread to ensure we at least minimal; * testing of a multithreaded environment (for example, having a reduced stack; * size). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:85,Testability,test,testing,85,"/***/; /* We intentionally run in a separate thread to ensure we at least minimal; * testing of a multithreaded environment (for example, having a reduced stack; * size). */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:139,Performance,load,load,139,"/* stdout, and surprisingly even stderr, are not always flushed on process; * and thread exit, particularly when the system is under heavy load. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:40,Testability,test,testbed,40,"//===-- core_main.cpp - Core Index Tool testbed ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:15,Integrability,depend,dependencies,15,// skip module dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:44,Modifiability,Rewrite,Rewrite,44,// FIXME: Move FixItRewriteInPlace from lib/Rewrite/Frontend/FrontendActions.cpp; // into a header file and reuse that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:86,Availability,error,errors,86,// We don't need to do permission checking here since clang will diagnose; // any I/O errors itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:58,Availability,error,errors,58,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:92,Availability,error,error,92,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:215,Availability,error,errors,215,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:52,Deployability,install,install,52,/// Subclasses \c clang::FixItAction so that we can install the custom; /// \c FixItRewriter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:136,Deployability,install,installed,136,"// Running the analyzer requires --analyze. Other modes can work with the; // -fsyntax-only option.; //; // The syntax-only adjuster is installed by default.; // Good: It also strips options that trigger extra output, like -save-temps.; // Bad: We don't want the -fsyntax-only when executing the static analyzer.; //; // To enable the static analyzer, we first strip all -fsyntax-only options; // and then add an --analyze option to the front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1839,Availability,down,down,1839,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1898,Availability,down,down,1898,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:2074,Availability,down,down,2074,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:2392,Availability,down,down,2392,"; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHighlight(prefix + number); }; window.onload = scrollToBoth; window.onkeydown = handleKey; </script>; <body>; <div onclick='highlight(event)'>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:123,Energy Efficiency,green,green,123,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:582,Modifiability,inherit,inherit,582,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:662,Modifiability,inherit,inherit,662,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1458,Security,hash,hash,1458,"{; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:1526,Security,hash,hash,1526,"; document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.getElementById(id); var number = parseInt(id.substr(1)); var increment = down ? 1 : -1; var lastnumber = number; var prefix = id[0]; do {; number = nextChangedNode(prefix, increment, number); var elem = document.getElementById(prefix + number); if (up && elem) {; while (elem.parentElement && changed(elem.parentElement)); elem = elem.parentElement; number = elem.id.substr(1); }; } while ((down && id !== 'R0' && oldelem.contains(elem))); if (!number); number = lastnumber; elem = document.getElementById(prefix + number); doHi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:442,Usability,clear,clearHighlight,442,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp:784,Usability,clear,clearHighlight,784,"R""(; <html>; <head>; <meta charset='utf-8'/>; <style>; span.d { color: red; }; span.u { color: #cc00cc; }; span.i { color: green; }; span.m { font-weight: bold; }; span { font-weight: normal; color: black; }; div.code {; width: 48%;; height: 98%;; overflow: scroll;; float: left;; padding: 0 0 0.5% 0.5%;; border: solid 2px LightGrey;; border-radius: 5px;; }; </style>; </head>; <script type='text/javascript'>; highlightStack = []; function clearHighlight() {; while (highlightStack.length) {; var [l, r] = highlightStack.pop(); document.getElementById(l).style.backgroundColor = 'inherit'; if (r[1] != '-'); document.getElementById(r).style.backgroundColor = 'inherit'; }; }; function highlight(event) {; var id = event.target['id']; doHighlight(id); }; function doHighlight(id) {; clearHighlight(); source = document.getElementById(id); if (!source.attributes['tid']); return; var mapped = source; while (mapped && mapped.parentElement && mapped.attributes['tid'].value.substr(1) === '-1'); mapped = mapped.parentElement; var tid = null, target = null; if (mapped) {; tid = mapped.attributes['tid'].value; target = document.getElementById(tid); }; if (source.parentElement && source.parentElement.classList.contains('code')); return; source.style.backgroundColor = 'lightgrey'; source.scrollIntoView(); if (target) {; if (mapped === source); target.style.backgroundColor = 'lightgrey'; target.scrollIntoView(); }; highlightStack.push([id, tid]); location.hash = '#' + id; }; function scrollToBoth() {; doHighlight(location.hash.substr(1)); }; function changed(elem) {; return elem.classList.length == 0; }; function nextChangedNode(prefix, increment, number) {; do {; number += increment; var elem = document.getElementById(prefix + number); } while(elem && !changed(elem)); return elem ? number : null; }; function handleKey(e) {; var down = e.code === ""KeyJ""; var up = e.code === ""KeyK""; if (!down && !up); return; var id = highlightStack[0] ? highlightStack[0][0] : 'R0'; var oldelem = document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-diff/ClangDiff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp:40,Availability,error,errors,40,// Call reset to make sure we don't mix errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp:58,Performance,Load,LoadFromASTFile,58,// Retain this one time so it's not destroyed by ASTUnit::LoadFromASTFile,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-extdef-mapping/ClangExtDefMapGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py:150,Deployability,patch,patch,150,"""""""; This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | {clang_format_diff} -p1 -i; svn diff --diff-cmd=diff -x-U0 | {clang_format_diff} -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py:431,Deployability,update,update,431,"""""""; This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | {clang_format_diff} -p1 -i; svn diff --diff-cmd=diff -x-U0 | {clang_format_diff} -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-diff.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:46,Deployability,integrat,integration,46,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:62,Deployability,install,install,62,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:378,Deployability,integrat,integration,378,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:46,Integrability,integrat,integration,46,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:378,Integrability,integrat,integration,378,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:218,Modifiability,config,config,218,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:537,Modifiability,extend,extended,537,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py:717,Usability,undo,undo,717,"# This file is a minimal clang-format sublime-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Put this file into your sublime Packages directory, e.g. on Linux:; # ~/.config/sublime-text-2/Packages/User/clang-format-sublime.py; # - Add a key binding:; # { ""keys"": [""ctrl+shift+c""], ""command"": ""clang_format"" },; #; # With this integration you can press the bound key and clang-format will; # format the current lines and selections for all cursor positions. The lines; # or regions are extended to the next bigger syntactic entities.; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format-sublime.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:42,Deployability,integrat,integration,42,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:58,Deployability,install,install,58,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:547,Deployability,integrat,integration,547,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:833,Deployability,integrat,integration,833,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:42,Integrability,integrat,integration,42,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:547,Integrability,integrat,integration,547,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:559,Integrability,depend,depending,559,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:833,Integrability,integrat,integration,833,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1012,Modifiability,extend,extended,1012,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1092,Modifiability,variab,variable,1092,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1155,Modifiability,variab,variable,1155,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:1649,Usability,undo,undo,1649,"# This file is a minimal clang-format vim-integration. To install:; # - Change 'binary' if clang-format is not on the path (see below).; # - Add to your .vimrc:; #; # if has('python'); # map <C-I> :pyf <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; # elseif has('python3'); # map <C-I> :py3f <path-to-this-file>/clang-format.py<cr>; # imap <C-I> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; # endif; #; # The if-elseif-endif conditional should pick either the python3 or python2; # integration depending on your vim setup.; #; # The first mapping enables clang-format for NORMAL and VISUAL mode, the second; # mapping adds support for INSERT mode. Change ""C-I"" to another binding if you; # need clang-format on a different key (C-I stands for Ctrl+i).; #; # With this integration you can press the bound key and clang-format will; # format the current line in NORMAL and INSERT mode or the selected region in; # VISUAL mode. The line or region is extended to the next bigger syntactic; # entity.; #; # You can also pass in the variable ""l:lines"" to choose the range for; # formatting. This variable can either contain ""<start line>:<end line>"" or; # ""all"" to format the full file. So, to format the full file, write a function; # like:; # :function FormatFile(); # : let l:lines=""all""; # : if has('python'); # : pyf <path-to-this-file>/clang-format.py; # : elseif has('python3'); # : py3f <path-to-this-file>/clang-format.py; # : endif; # :endfunction; #; # It operates on the current, potentially unsaved buffer and does not create; # or save any files. To revert a formatting, just undo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:2,Safety,Avoid,Avoid,2,"# Avoid flashing an ugly, ugly cmd prompt on Windows when invoking clang-format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:87,Availability,error,error,87,// Parses <start line>:<end line> input to a pair of line numbers.; // Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:19,Availability,error,error,19,// Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:27,Modifiability,variab,variable,27,// To format JSON insert a variable to trick the code into thinking its; // JavaScript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:12,Deployability,configurat,configuration,12,// Dump the configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:12,Modifiability,config,configuration,12,// Dump the configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:29,Safety,detect,detect,29,// We can't read the code to detect the language if there's no file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:63,Safety,detect,detect,63,// Read in the code in case the filename alone isn't enough to detect the; // language.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:280,Security,hash,hash,280,// Patterns in .clang-format-ignore file.; // Check whether `FilePath` is ignored according to the nearest; // .clang-format-ignore file based on the rules below:; // - A blank line is skipped.; // - Leading and trailing spaces of a line are trimmed.; // - A line starting with a hash (`#`) is a comment.; // - A non-comment line is a single pattern.; // - The slash (`/`) is used as the directory separator.; // - A pattern is relative to the directory of the .clang-format-ignore file (or; // the root directory if the pattern starts with a slash).; // - A pattern is negated if it starts with a bang (`!`).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:119,Safety,avoid,avoid,119,"// Check if string contains quotes. On Windows, file names cannot contain quotes.; // We do not accept them however to avoid hard-to-debug problems.; // A quote in user input would end the parameter quote and so break the command invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:3,Performance,Load,Load,3,// Load package on solution load,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:28,Performance,load,load,28,// Load package on solution load,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:56,Availability,down,down,56,"// 5. clang-format is done, wait until it is fully shut down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:56,Availability,error,error,56,"// FIXME: If clang-format writes enough to the standard error stream to block,; // we will never reach this point; instead, read the standard error asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:142,Availability,error,error,142,"// FIXME: If clang-format writes enough to the standard error stream to block,; // we will never reach this point; instead, read the standard error asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:327,Availability,Error,Error,327,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:308,Integrability,message,message,308,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:358,Integrability,Message,Message,358,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs:31,Performance,cache,cached,31,/// <summary>; /// Returns the cached ResourceManager instance used by this class.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs:3,Security,Expose,Exposes,3,// Exposes event sources for IVsRunningDocTableEvents3 events.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/RunningDocTableEventsDispatcher.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs:60,Integrability,interface,interfaces,60,"// Now we have the active view as IVsTextView, but the text interfaces we need; // are in the IWpfTextView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp:46,Safety,sanity check,sanity check,46,"//===-- DummyClangFuzzer.cpp - Entry point to sanity check fuzzers --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides a main() to build without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/DummyClangFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:468,Performance,optimiz,optimization,468,"//==-- handle_llvm.cpp - Helper function for Clang fuzzers -----------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements HandleLLVM for use by the Clang fuzzers. First runs a loop; // vectorizer optimization pass over the given IR code. Then mimics lli on both; // versions to JIT the generated code and execute it. Currently, functions are ; // executed on dummy inputs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:59,Performance,optimiz,optimization,59,// Helper function to parse command line args and find the optimization level,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:12,Performance,optimiz,optimization,12,// Find the optimization level from the command line args,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:26,Performance,optimiz,optimization,26,"// Helper function to add optimization passes to the TargetMachine at the ; // specified optimization level, OptLevel",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:89,Performance,optimiz,optimization,89,"// Helper function to add optimization passes to the TargetMachine at the ; // specified optimization level, OptLevel",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:33,Performance,optimiz,optimization,33,// Mimics the opt tool to run an optimization pass over the provided IR,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:37,Performance,optimiz,optimization,37,// Create a module that will run the optimization passes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:30,Performance,optimiz,optimized,30,// Add a pass that writes the optimized IR to an output stream,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:89,Performance,optimiz,optimized,89,// Takes a function and runs it on a set of inputs; // First determines whether f is the optimized or unoptimized function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:36,Performance,optimiz,optimized,36,// Figure out if we are running the optimized func or the unoptimized func,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:30,Performance,optimiz,optimization,30,// Parse ExtraArgs to set the optimization level,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:12,Performance,optimiz,optimize,12,// First we optimize the IR by running a loop vectorizer pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h:403,Modifiability,variab,variables,403,"//==-- input_arrays.h - Helper function for LLVM fuzzer inputs -------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Define a few static variables used by the LLVM Proto Fuzzer; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/input_arrays.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp:483,Integrability,wrap,wrapping,483,"//==-- loop_proto_to_cxx.cpp - Protobuf-C++ conversion ---------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements functions for converting between protobufs and C++. Differs from; // proto_to_cxx.cpp by wrapping all the generated C++ code in either a single; // for loop or two nested loops. Also outputs a different function signature; // that includes a size_t parameter for the loop to use. The C++ code generated; // is meant to stress the LLVM loop vectorizer.; //; // Still a work in progress.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp:396,Usability,simpl,simple,396,"//==-- loop_proto_to_cxx_main.cpp - Driver for protobuf-C++ conversion -----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a C++ program from a protobuf with loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/loop_proto_to_cxx_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp:396,Usability,simpl,simple,396,"//==-- proto_to_cxx_main.cpp - Driver for protobuf-C++ conversion ----------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a C++ program from a protobuf.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-cxx/proto_to_cxx_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:63,Integrability,wrap,wrapper,63,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:11,Modifiability,variab,variable,11,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp:44,Modifiability,variab,variable,44,// Counter variable to generate new LLVM IR variable names and wrapper function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp:396,Usability,simpl,simple,396,"//==-- loop_proto_to_llvm_main.cpp - Driver for protobuf-LLVM conversion----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a simple driver to print a LLVM program from a protobuf with loops; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/proto-to-llvm/loop_proto_to_llvm_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:21,Testability,test,test,21,"//===-- clang-import-test.cpp - ASTImporter/ExternalASTSource testbed -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:62,Testability,test,testbed,62,"//===-- clang-import-test.cpp - ASTImporter/ExternalASTSource testbed -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:14,Testability,test,testing,14,// Needed for testing dynamic_cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:131,Security,access,accessor,131,/// A container for a CompilerInstance (possibly with an ExternalASTMerger; /// attached to its ASTContext).; ///; /// Provides an accessor for the DeclContext origins associated with the; /// ExternalASTMerger (or an empty list of origins if no ExternalASTMerger is; /// attached).; ///; /// This is the main unit of parsed source code maintained by clang-import-test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:364,Testability,test,test,364,/// A container for a CompilerInstance (possibly with an ExternalASTMerger; /// attached to its ASTContext).; ///; /// Provides an accessor for the DeclContext origins associated with the; /// ExternalASTMerger (or an empty list of origins if no ExternalASTMerger is; /// attached).; ///; /// This is the main unit of parsed source code maintained by clang-import-test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:21,Integrability,wrap,wrapper,21,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:54,Integrability,wrap,wrapper,54,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:402,Integrability,wrap,wrapper,402,"//===-- clang-linker-wrapper/ClangLinkerWrapper.cpp - wrapper over linker-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This tool works as a wrapper over a linking job. This tool is used to create; // linked device images for offloading. It scans the linker's input for embedded; // device offloading data stored in sections `.llvm.offloading` and extracts it; // as a temporary file. The extracted device files will then be passed to a; // device linking job to create a final device image.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:29,Deployability,install,installation,29,/// Binary path for the CUDA installation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:42,Integrability,wrap,wrapper,42,/// Temporary files created by the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:59,Availability,error,error,59,/// Global flag to indicate that the LTO pipeline threw an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:41,Deployability,pipeline,pipeline,41,/// Global flag to indicate that the LTO pipeline threw an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:35,Integrability,wrap,wrapper,35,// Options only used by the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:86,Integrability,wrap,wrap,86,/// Create an extra user-specified \p OffloadFile.; /// TODO: We should find a way to wrap these as libraries instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:13,Integrability,wrap,wrapped,13,/// Runs the wrapped linker job with the newly created input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:57,Integrability,wrap,wrapper,57,// Do not forward arguments only intended for the linker wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:73,Security,sanitiz,sanitizers,73,"// Sometimes needed libraries are passed by name, such as when using; // sanitizers. We need to check the file magic for any libraries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:127,Usability,simpl,simplified,127,// We need to resolve the symbols so the LTO backend knows which symbols need; // to be kept or can be internalized. This is a simplified symbol resolution; // scheme to approximate the full resolution a linker would do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:156,Testability,assert,assertion,156,"// The final definition will reside in this linkage unit if the symbol is; // defined and local to the module. This only checks for bitcode files,; // full assertion will require complete symbol resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:54,Integrability,wrap,wrap,54,"// We do not support linker redefined symbols (e.g. --wrap) for device; // image linking, so the symbols will not be changed after LTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:3,Deployability,Update,Update,3,"// Update this symbol in the ""table"" with the new information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:33,Deployability,update,update,33,// If the file gets extracted we update the table with the new symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:3,Deployability,Update,Update,3,"// Update this symbol in the ""table"" with the new information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:33,Deployability,update,update,33,// If the file gets extracted we update the table with the new symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:12,Integrability,wrap,wrap,12,// Link and wrap the device images extracted from the linker input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:42,Availability,error,errors,42,// Process commandline options and report errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:101,Modifiability,variab,variables,101,/// Class to store bundler options in standard (non-cl::opt) data structures; // Avoid using cl::opt variables after these assignments when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:81,Safety,Avoid,Avoid,81,/// Class to store bundler options in standard (non-cl::opt) data structures; // Avoid using cl::opt variables after these assignments when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:105,Availability,error,error,105,"// Host triple is not really needed for unbundling operation, so do not; // treat missing host triple as error if we do unbundling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:41,Modifiability,refactor,refactoring,41,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:425,Modifiability,refactor,refactor,425,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:444,Performance,perform,performs,444,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:232,Integrability,inject,inject,232,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:26,Modifiability,refactor,refactoring,26,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:105,Modifiability,refactor,refactoring,105,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:154,Modifiability,refactor,refactoring,154,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:291,Modifiability,refactor,refactoring,291,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:232,Security,inject,inject,232,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:201,Testability,Test,TestSourceSelectionArgument,201,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:241,Testability,test,test-specific,241,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:276,Testability,log,logic,276,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:318,Testability,test,test-specific,318,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:398,Testability,test,test,398,/// Returns a replacement refactoring result consumer (if any) that should; /// consume the results of a refactoring operation.; ///; /// The replacement refactoring result consumer is used by \c; /// TestSourceSelectionArgument to inject a test-specific result handling; /// logic into the refactoring operation. The test-specific consumer; /// ensures that the individual results in a particular test group are; /// identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:99,Availability,error,error,99,"/// Runs the give refactoring function for each specified selection.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:18,Modifiability,refactor,refactoring,18,"/// Runs the give refactoring function for each specified selection.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:33,Testability,test,test,33,/// Stores the parsed -selection=test:<filename> option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:4,Testability,Test,Testing,4,/// Testing support: invokes the selection action for each selection range in; /// the test file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:87,Testability,test,test,87,/// Testing support: invokes the selection action for each selection range in; /// the test file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:13,Availability,error,error,13,// A parsing error was already reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:75,Modifiability,refactor,refactoring,75,/// A container that stores the command-line options used by a single; /// refactoring option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:79,Modifiability,refactor,refactoring,79,/// Passes the command-line option values to the options used by a single; /// refactoring action rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:16,Modifiability,refactor,refactoring,16,/// Creates the refactoring options used by all the rules in a single; /// refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:75,Modifiability,refactor,refactoring,75,/// Creates the refactoring options used by all the rules in a single; /// refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:48,Modifiability,refactor,refactoring,48,/// A subcommand that corresponds to individual refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:14,Modifiability,refactor,refactoring,14,// Create the refactoring options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:78,Availability,error,error,78,"/// Parses the ""-selection"" command-line argument.; ///; /// \returns true on error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:43,Modifiability,refactor,refactoring,43,// Initializes the selected subcommand and refactoring rule based on the; // command line options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:30,Testability,test,test,30,"// If the selection option is test specific, we use a test-specific; // consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:54,Testability,test,test-specific,54,"// If the selection option is test specific, we use a test-specific; // consumer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:23,Modifiability,refactor,refactoring,23,/// Logs an individual refactoring action invocation to STDOUT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:4,Testability,Log,Logs,4,/// Logs an individual refactoring action invocation to STDOUT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:150,Modifiability,refactor,refactor,150,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:210,Modifiability,refactor,refactoring,210,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:315,Modifiability,refactor,refactoring,315,"// Figure out which action is specified by the user. The user must specify the; // action using a command-line subcommand, e.g. the invocation `clang-refactor; // local-rename` corresponds to the `LocalRename` refactoring action. All; // subcommands must have a unique names. This allows us to figure out which; // refactoring action should be invoked by looking at the first subcommand; // that's enabled by LLVM's command-line parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:417,Integrability,rout,routines,417,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:39,Modifiability,refactor,refactoring,39,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:439,Modifiability,refactor,refactoring,439,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:9,Testability,Test,TestSupport,9,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:451,Testability,test,testing,451,"//===--- TestSupport.cpp - Clang-based refactoring tool -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements routines that provide refactoring testing; /// utilities.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:3,Availability,error,error,3,// error has occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:7,Availability,error,error,7,// The error messages must match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:13,Integrability,message,messages,13,// The error messages must match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:10,Safety,detect,detect,10,// Try to detect mistyped 'range:' comments to ensure tests don't miss; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:54,Testability,test,tests,54,// Try to detect mistyped 'range:' comments to ensure tests don't miss; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:419,Integrability,rout,routines,419,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:37,Modifiability,refactor,refactoring,37,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:478,Modifiability,refactor,refactor,478,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:9,Testability,Test,TestSupport,9,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:445,Testability,test,test-specific,445,"//===--- TestSupport.h - Clang-based refactoring tool -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Declares datatypes and routines that are used by test-specific code; /// in clang-refactor.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:719,Modifiability,refactor,refactor,719,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:51,Testability,test,test,51,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:760,Testability,test,test,760,"/// A source selection range that's specified in a test file using an inline; /// command in the comment. These commands can take the following forms:; ///; /// - /*range=*/ will create an empty selection range in the default group; /// right after the comment.; /// - /*range a=*/ will create an empty selection range in the 'a' group right; /// after the comment.; /// - /*range = +1*/ will create an empty selection range at a location that's; /// right after the comment with one offset to the column.; /// - /*range= -> +2:3*/ will create a selection range that starts at the; /// location right after the comment, and ends at column 3 of the 2nd line; /// after the line of the starting location.; ///; /// Clang-refactor will expected all ranges in one test group to produce; /// identical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:13,Testability,test,test,13,/// A set of test selection ranges specified in one file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1051,Availability,error,error,1051,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1473,Availability,failure,failure,1473,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1482,Availability,error,errors,1482,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:924,Modifiability,refactor,refactoring,924,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:996,Modifiability,refactor,refactor,996,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1358,Modifiability,refactor,refactor,1358,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:96,Testability,test,test,96,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:959,Testability,test,testing,959,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1286,Testability,test,test,1286,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:7,Integrability,interface,interface,7,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:66,Integrability,interface,interface,66,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:40,Modifiability,Refactor,RefactoringResultConsumer,40,/// An interface that subclasses the \c RefactoringResultConsumer interface; /// that stores the reference to the TU-specific diagnostics engine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h:17,Modifiability,refactor,refactor,17,// end namespace refactor,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ToolRefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:26,Deployability,integrat,integration,26,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:55,Deployability,install,installing,55,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:298,Deployability,install,install,298,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:26,Integrability,integrat,integration,26,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:670,Modifiability,variab,variable,670,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py:307,Usability,simpl,simply,307,"""""""; Minimal clang-rename integration with Vim. Before installing make sure one of the following is satisfied:. * clang-rename is in your PATH; * `g:clang_rename_path` in ~/.vimrc points to valid clang-rename executable; * `binary` in clang-rename.py points to valid to clang-rename executable. To install, simply put this into your ~/.vimrc for python2 support. noremap <leader>cr :pyf <path-to>/clang-rename.py<cr>. For python3 use the following command (note the change from :pyf to :py3f). noremap <leader>cr :py3f <path-to>/clang-rename.py<cr>. IMPORTANT NOTE: Before running the tool, make sure you saved the file. All you have to do now is to place a cursor on a variable/function/class which; you would like to rename and press '<leader>cr'. You will be prompted for a new; name if the cursor points to a valid symbol.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/clang-rename.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp:3,Performance,Perform,Perform,3,// Perform the renaming.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-rename/ClangRename.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:25,Testability,test,test,25,// Disable LSan for this test.; // FIXME: Re-enable once we can assume GCC 13.2 or higher.; // https://llvm.org/github.com/llvm/llvm-project/issues/67586.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:13,Availability,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:31,Availability,error,errors,31,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:62,Availability,error,error,62,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:184,Availability,error,error,184,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:13,Safety,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:118,Testability,test,test,118,// If we are running with -verify a reported has to be returned as unsuccess.; // This is relevant especially for the test suite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:19,Availability,error,error,19,// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:126,Testability,test,test,126,// If there was an error that came from the verifier we must return 1 as; // an exit code for the process. This will make the test fail as expected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:11,Availability,error,error,11,// log the error and returns an empty vector;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:3,Testability,log,log,3,// log the error and returns an empty vector;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:22,Modifiability,plugin,plugins,22,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:3,Performance,Load,Load,3,// Load any requested plugins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:4,Usability,undo,undo,4,"R""(%undo)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:7,Availability,error,error,7,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:149,Availability,error,errors,149,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:21,Integrability,depend,depends,21,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:162,Performance,cache,cache,162,"/// findResourceDir finds the resource directory relative to the clang; /// compiler being used in Args, by running it with ""-print-resource-dir""; /// option and cache the results for reuse. \returns resource directory path; /// associated with the given invocation command or empty string if the; /// compiler path is NOT an absolute path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:81,Availability,error,error,81,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:159,Availability,error,error,159,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Integrability,depend,dependency,54,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:89,Integrability,depend,dependency,89,// end anonymous namespace; /// Takes the result of a dependency scan and prints error / dependency files; /// based on the result.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:42,Integrability,depend,dependency,42,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:104,Usability,simpl,simply,104,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:10,Safety,safe,safe,10,// Thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:50,Deployability,update,updated,50,"// FIXME: This is mutable so that it can still be updated after insertion; // into an unordered associative container. This is ""fine"", since this; // field doesn't contribute to the hash, but it's a brittle hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:182,Security,hash,hash,182,"// FIXME: This is mutable so that it can still be updated after insertion; // into an unordered associative container. This is ""fine"", since this; // field doesn't contribute to the hash, but it's a brittle hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:81,Integrability,depend,dependency,81,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:565,Integrability,depend,dependency,565,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:241,Security,hash,hash,241,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:421,Security,hash,hash,421,"/// We need the output of clang-scan-deps to be deterministic. However,; /// the dependency graph may contain two modules with the same name. How; /// do we decide which one to print first? If we made that decision based; /// on the context hash, the ordering would be deterministic, but; /// different across machines. This can happen for example when the inputs; /// or the SDKs (which both contribute to the ""context"" hash) live in; /// different absolute locations. We solve that by tracking the index of; /// the first input TU that (transitively) imports the dependency, which; /// is always the same for the same input, resulting in deterministic; /// sorting that's also reproducible across machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:61,Performance,load,load,61,"// getCompilationDataBase - If -compilation-database is set, load the; // compilation database from the specified file. Otherwise if the we're; // generating P1689 format, trying to generate the compilation database; // form specified command line after the positional parameter ""--"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Integrability,Inject,Inject,54,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Security,Inject,Inject,54,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:17,Integrability,depend,dependency,17,// Print out the dependency results to STDOUT by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:44,Integrability,depend,dependency,44,// It is useful to generate the make-format dependency output during; // the scanning for P1689. Otherwise the users need to scan again for; // it. We will generate the make-format dependency output if we find; // `-MF` in the command lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:181,Integrability,depend,dependency,181,// It is useful to generate the make-format dependency output during; // the scanning for P1689. Otherwise the users need to scan again for; // it. We will generate the make-format dependency output if we find; // `-MF` in the command lines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:62,Performance,concurren,concurrently,62,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:105,Performance,concurren,concurrently,105,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:238,Safety,avoid,avoid,238,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp:13,Availability,error,errors,13,"// Flush any errors created when initializing everything. This could happen; // for invalid command lines, which will probably give non-sensical results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/diagtool/ShowEnabledWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:473,Integrability,interface,interface,473,"//===-- cc1as_main.cpp - Clang Assembler ---------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang -cc1as functionality, which implements; // the direct interface to the LLVM MC based assembler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:53,Deployability,deploy,deployment,53,"/// Darwin target variant triple, the variant of the deployment target; /// for which the code is being compiled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:30,Availability,error,error,30,// Check for missing argument error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:9,Availability,error,errors,9,// Issue errors on unknown arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:36,Security,sanitiz,sanitizer,36,// FIXME: init MCTargetOptions from sanitizer flags here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:19,Availability,error,error,19,// We have already error checked this in the driver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:36,Availability,error,errors,36,// Delete output file if there were errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:13,Availability,recover,recover,13,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:31,Availability,error,errors,31,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:13,Safety,recover,recover,13,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:56,Integrability,message,message,56,// Honor -version.; //; // FIXME: Use a better -version message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:53,Availability,error,errors,53,"// Execute the invocation, unless there were parsing errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp:31,Security,hash,hashes,31,// FIXME: Compare unsaved file hashes and report mismatch in the reproducer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1gen_reproducer_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:559,Testability,test,testing,559,"//===-- cc1_main.cpp - Clang CC1 Compiler Frontend ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang -cc1 functionality, which implements the; // core compiler functionality along with a number of additional tools for; // demonstration and testing purposes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:13,Availability,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:31,Availability,error,errors,31,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:62,Availability,error,error,62,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:184,Availability,error,error,184,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:13,Safety,recover,recover,13,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:28,Modifiability,extend,extends,28,"// We assume that the stack extends from its current address to the end of; // the environment space. In reality, there is another string literal (the; // program name) after the environment, but this is close enough (we only; // need to be within 100K or so).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:207,Energy Efficiency,allocate,allocate,207,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:368,Energy Efficiency,allocate,allocated,368,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:291,Safety,avoid,avoid,291,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:52,Usability,usab,usable,52,/// Attempt to ensure that we have at least 8MiB of usable stack space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:10,Energy Efficiency,allocate,allocate,10,// Try to allocate sufficient stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:10,Availability,error,error,10,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:81,Availability,error,error,81,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:7,Availability,error,error,7,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:149,Availability,error,errors,149,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:21,Integrability,depend,depends,21,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:441,Integrability,wrap,wrapper,441,"//===-- driver.cpp - Clang GCC-Compatible Driver --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the entry point to the clang driver; it is a thin wrapper; // for functionality in the Driver clang library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:141,Performance,perform,perform,141,"/// ApplyOneQAOverride - Apply a list of edits to the input argument lists.; ///; /// The input string is a space separated list of edits to perform,; /// they are applied in order to the input argument lists. Edits; /// should be one of the following forms:; ///; /// '#': Silence information about the changes to the command line arguments.; ///; /// '^': Add FOO as a new argument at the beginning of the command line.; ///; /// '+': Add FOO as a new argument at the end of the command line.; ///; /// 's/XXX/YYY/': Substitute the regular expression XXX with YYY in the command; /// line.; ///; /// 'xOPTION': Removes all instances of the literal argument OPTION.; ///; /// 'XOPTION': Removes all instances of the literal argument OPTION,; /// and the following argument.; ///; /// 'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'; /// at the end of the command line.; ///; /// \param OS - The stream to write edit information to.; /// \param Args - The vector of command line arguments.; /// \param Edit - The override command to perform.; /// \param SavedStrings - Set to use for storing string representations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:1050,Performance,perform,perform,1050,"/// ApplyOneQAOverride - Apply a list of edits to the input argument lists.; ///; /// The input string is a space separated list of edits to perform,; /// they are applied in order to the input argument lists. Edits; /// should be one of the following forms:; ///; /// '#': Silence information about the changes to the command line arguments.; ///; /// '^': Add FOO as a new argument at the beginning of the command line.; ///; /// '+': Add FOO as a new argument at the end of the command line.; ///; /// 's/XXX/YYY/': Substitute the regular expression XXX with YYY in the command; /// line.; ///; /// 'xOPTION': Removes all instances of the literal argument OPTION.; ///; /// 'XOPTION': Removes all instances of the literal argument OPTION,; /// and the following argument.; ///; /// 'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'; /// at the end of the command line.; ///; /// \param OS - The stream to write edit information to.; /// \param Args - The vector of command line arguments.; /// \param Edit - The override command to perform.; /// \param SavedStrings - Set to use for storing string representations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:28,Energy Efficiency,efficient,efficient,28,// This does not need to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:28,Energy Efficiency,efficient,efficient,28,// This does not need to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:132,Safety,Avoid,Avoid,132,"// Put target and mode arguments at the start of argument list so that; // arguments specified in command line could override them. Avoid putting; // them at index 0, as an option like '-cc1' must remain the first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:115,Safety,avoid,avoid,115,"// If the clang binary happens to be named cl.exe for compatibility reasons,; // use clang-cl.exe as the prefix to avoid confusion between clang and MSVC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:85,Deployability,install,installed,85,"// Attempt to find the original path used to invoke the driver, to determine; // the installed path. We do this manually, because we want to support that; // path being a symlink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:15,Deployability,integrat,integrated,15,// Handle -cc1 integrated tools.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:15,Integrability,integrat,integrated,15,// Handle -cc1 integrated tools.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:226,Safety,safe,safe,226,"// If -canonical-prefixes is set, GetExecutablePath will have resolved Path; // to the llvm driver binary, not clang. In this case, we need to use; // PrependArg which should be clang-*. Checking just CanonicalPrefixes is; // safe even in the normal case because PrependArg will be null so; // setPrependArg will be a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:65,Availability,error,error,65,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:141,Availability,error,error,141,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:164,Safety,abort,abort,164,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:19,Deployability,integrat,integrated-,19,"// When running in integrated-cc1 mode, the CrashRecoveryContext returns; // the same codes as if the program crashed. See section ""Exit Status for; // Commands"":; // https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:19,Integrability,integrat,integrated-,19,"// When running in integrated-cc1 mode, the CrashRecoveryContext returns; // the same codes as if the program crashed. See section ""Exit Status for; // Commands"":; // https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:24,Integrability,message,message,24,"// Print the bug report message that would be printed if we did actually; // crash, but only if we're crashing due to FORCE_CLANG_DIAGNOSTICS_CRASH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:128,Deployability,release,released,128,"// When crashing in -fintegrated-cc1 mode, bury the timer pointers, because; // the internal linked list might point to already released stack frames.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/driver/driver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/cppreference_parser.py:53,Integrability,wrap,wrapped,53,# The interesting header content (e.g. <cstdlib>) is wrapped in <code>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/cppreference_parser.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/cppreference_parser.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:641,Availability,Down,Download,641,"""""""gen_std.py is a tool to generate a lookup table (from qualified names to; include headers) for C/C++ Standard Library symbols by parsing archived HTML; files from cppreference. The generated files are located in clang/include/Tooling/Inclusions. Caveats and FIXMEs:; - only symbols directly in ""std"" namespace are added, we should also add std's; subnamespace symbols (e.g. chrono).; - symbols with multiple variants or defined in multiple headers aren't added,; e.g. std::move, std::swap. Usage:; 1. Install BeautifulSoup dependency, see instruction:; https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup; 2. Download cppreference offline HTML files (html_book_20220730.zip in Unofficial Release) at; https://en.cppreference.com/w/Cppreference:Archives; 3. Unzip the zip file from step 2 (e.g., to a ""cppreference"" directory). You should; get a ""cppreference/reference"" directory.; 4. Run the command:; // Generate C++ symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=cpp > StdSymbolMap.inc; // Generate C symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=c > CSymbolMap.inc; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:504,Deployability,Install,Install,504,"""""""gen_std.py is a tool to generate a lookup table (from qualified names to; include headers) for C/C++ Standard Library symbols by parsing archived HTML; files from cppreference. The generated files are located in clang/include/Tooling/Inclusions. Caveats and FIXMEs:; - only symbols directly in ""std"" namespace are added, we should also add std's; subnamespace symbols (e.g. chrono).; - symbols with multiple variants or defined in multiple headers aren't added,; e.g. std::move, std::swap. Usage:; 1. Install BeautifulSoup dependency, see instruction:; https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup; 2. Download cppreference offline HTML files (html_book_20220730.zip in Unofficial Release) at; https://en.cppreference.com/w/Cppreference:Archives; 3. Unzip the zip file from step 2 (e.g., to a ""cppreference"" directory). You should; get a ""cppreference/reference"" directory.; 4. Run the command:; // Generate C++ symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=cpp > StdSymbolMap.inc; // Generate C symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=c > CSymbolMap.inc; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:611,Deployability,install,installing-beautiful-soup,611,"""""""gen_std.py is a tool to generate a lookup table (from qualified names to; include headers) for C/C++ Standard Library symbols by parsing archived HTML; files from cppreference. The generated files are located in clang/include/Tooling/Inclusions. Caveats and FIXMEs:; - only symbols directly in ""std"" namespace are added, we should also add std's; subnamespace symbols (e.g. chrono).; - symbols with multiple variants or defined in multiple headers aren't added,; e.g. std::move, std::swap. Usage:; 1. Install BeautifulSoup dependency, see instruction:; https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup; 2. Download cppreference offline HTML files (html_book_20220730.zip in Unofficial Release) at; https://en.cppreference.com/w/Cppreference:Archives; 3. Unzip the zip file from step 2 (e.g., to a ""cppreference"" directory). You should; get a ""cppreference/reference"" directory.; 4. Run the command:; // Generate C++ symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=cpp > StdSymbolMap.inc; // Generate C symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=c > CSymbolMap.inc; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:720,Deployability,Release,Release,720,"""""""gen_std.py is a tool to generate a lookup table (from qualified names to; include headers) for C/C++ Standard Library symbols by parsing archived HTML; files from cppreference. The generated files are located in clang/include/Tooling/Inclusions. Caveats and FIXMEs:; - only symbols directly in ""std"" namespace are added, we should also add std's; subnamespace symbols (e.g. chrono).; - symbols with multiple variants or defined in multiple headers aren't added,; e.g. std::move, std::swap. Usage:; 1. Install BeautifulSoup dependency, see instruction:; https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup; 2. Download cppreference offline HTML files (html_book_20220730.zip in Unofficial Release) at; https://en.cppreference.com/w/Cppreference:Archives; 3. Unzip the zip file from step 2 (e.g., to a ""cppreference"" directory). You should; get a ""cppreference/reference"" directory.; 4. Run the command:; // Generate C++ symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=cpp > StdSymbolMap.inc; // Generate C symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=c > CSymbolMap.inc; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:526,Integrability,depend,dependency,526,"""""""gen_std.py is a tool to generate a lookup table (from qualified names to; include headers) for C/C++ Standard Library symbols by parsing archived HTML; files from cppreference. The generated files are located in clang/include/Tooling/Inclusions. Caveats and FIXMEs:; - only symbols directly in ""std"" namespace are added, we should also add std's; subnamespace symbols (e.g. chrono).; - symbols with multiple variants or defined in multiple headers aren't added,; e.g. std::move, std::swap. Usage:; 1. Install BeautifulSoup dependency, see instruction:; https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup; 2. Download cppreference offline HTML files (html_book_20220730.zip in Unofficial Release) at; https://en.cppreference.com/w/Cppreference:Archives; 3. Unzip the zip file from step 2 (e.g., to a ""cppreference"" directory). You should; get a ""cppreference/reference"" directory.; 4. Run the command:; // Generate C++ symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=cpp > StdSymbolMap.inc; // Generate C symbols; python3 gen_std.py -cppreference cppreference/reference -symbols=c > CSymbolMap.inc; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:2,Safety,avoid,avoid,2,"# avoid printing duplicated entries, for C macros!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:171,Security,access,accessed,171,"# std sub-namespace symbols have separated pages.; # We don't index std literal operators (e.g.; # std::literals::chrono_literals::operator""""d), these symbols can't be; # accessed by std::<symbol_name>.; #; # std::placeholders symbols are handled manually in StdSpecialSymbolMap.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:28,Security,access,accessed,28,# std::ranges::views can be accessed as std::views.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:27,Availability,avail,available,27,"# Zombie symbols that were available from the Standard Library, but are; # removed in the following standards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/test.py:30,Testability,test,test,30,"#!/usr/bin/env python; # ===- test.py - ---------------------------------------------*- python -*--===#; #; # Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; # See https://llvm.org/LICENSE.txt for license information.; # SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; #; # ===------------------------------------------------------------------------===#",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/include-mapping/test.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/test.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:295,Integrability,rout,routine,295,"/// Translate a Clang source range into a CIndex source range.; ///; /// Clang internally represents ranges where the end location points to the; /// start of the token at the end. However, for external clients it is more; /// useful to have a CXSourceRange be a proper half-open interval. This routine; /// does the appropriate translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:315,Safety,abort,aborted,315,"/// Visit the given cursor and, if requested by the visitor,; /// its children.; ///; /// \param Cursor the cursor to visit.; ///; /// \param CheckedRegionOfInterest if true, then the caller already checked; /// that this cursor is within the region of interest.; ///; /// \returns true if the visitation should be aborted, false if it; /// should continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,abort,abort,3,// abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:64,Performance,optimiz,optimization,64,"// If the begin/end of the range lie in the same FileID, do the optimization; // where we skip preprocessed entities that do not come from the same; // FileID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,Availability,recover,recover,55,"// If the end does not reside in the same file, try to recover by; // picking the end of the file of begin location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,Safety,recover,recover,55,"// If the end does not reside in the same file, try to recover by; // picking the end of the file of begin location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,Modifiability,extend,extends,55,"// Beginning of range lies in the preamble but it also extends beyond; // it into the main file. Split the range into 2 parts, one covering; // the preamble and another covering the main file. This allows subsequent; // calls to visitPreprocessedEntitiesInRange to accept a source range that; // lies in the same FileID, allowing it to skip preprocessed entities that; // do not come from the same FileID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:96,Safety,abort,aborted,96,"/// Visit the children of the given cursor.; ///; /// \returns true if the visitation should be aborted, false if it; /// should continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:35,Security,access,accessor,35,// Filter out synthesized property accessor redeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:57,Integrability,protocol,protocol,57,// FIXME: ObjCClassRef/ObjCProtocolRef for forward class/protocol; // declarations is a mismatch with the compiler semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:82,Deployability,install,installed,82,// FIXME: This implements a workaround with @property declarations also being; // installed in the DeclContext for the @interface. Eventually this code; // should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:120,Integrability,interface,interface,120,// FIXME: This implements a workaround with @property declarations also being; // installed in the DeclContext for the @interface. Eventually this code; // should be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,Integrability,interface,interface,79,// Visit synthesized methods since they will be skipped when visiting; // the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:21,Integrability,rout,routine,21,"// FIXME: This whole routine is a hack to work around the lack of proper; // source information in nested-name-specifiers (PR5791). Since we do have; // a beginning source location, we can visit the first component of the; // nested-name-specifier, if it's a single-token component.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,Performance,perform,performed,79,// Now reverse the entries we just added. This will match the DFS; // ordering performed by the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:33,Modifiability,variab,variables,33,/// Process clauses with list of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,Performance,perform,performed,79,// Now reverse the entries we just added. This will match the DFS; // ordering performed by the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,Performance,perform,performed,79,// Now reverse the entries we just added. This will match the DFS; // ordering performed by the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:15,Energy Efficiency,allocate,allocated,15,// Enqueue the allocated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:79,Performance,perform,performed,79,// Now reverse the entries we just added. This will match the DFS; // ordering performed by the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:29,Security,access,access,29,"// If the base of the member access expression is an implicit 'this', don't; // visit it.; // FIXME: If we ever want to show these implicit accesses, this will be; // unfortunate. However, clang_getCursor() relies on this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:140,Security,access,accesses,140,"// If the base of the member access expression is an implicit 'this', don't; // visit it.; // FIXME: If we ever want to show these implicit accesses, this will be; // unfortunate. However, clang_getCursor() relies on this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:12,Performance,perform,perform,12,"// For now, perform default visitation for Decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Performance,Perform,Perform,3,// Perform default visitation for TypeLocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Deployability,Update,Update,3,// Update the current cursor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:16,Availability,recover,recovery,16,"// We use crash recovery to make some of our APIs more reliable, implicitly; // enable it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,Availability,reliab,reliable,55,"// We use crash recovery to make some of our APIs more reliable, implicitly; // enable it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:16,Safety,recover,recovery,16,"// We use crash recovery to make some of our APIs more reliable, implicitly; // enable it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:111,Availability,error,error,111,// Look through the managed static to trigger construction of the managed; // static which registers our fatal error handler. This ensures it is only; // registered once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:1192,Availability,failure,failure,1192,"// Adding new options to struct CXIndexOptions:; // 1. If no other new option has been added in the same libclang version,; // sizeof(CXIndexOptions) must increase for versioning purposes.; // 2. Options should be added at the end of the struct in order to seamlessly; // support older struct versions. If options->Size < sizeof(CXIndexOptions),; // don't attempt to read the missing options and rely on the default values of; // recently added options being reasonable. For example:; // if (options->Size >= offsetof(CXIndexOptions, RecentlyAddedMember)); // do_something(options->RecentlyAddedMember);; // An exception: if a new option is small enough, it can be squeezed into the; // /*Reserved*/ bits in CXIndexOptions. Since the default value of each option; // is guaranteed to be 0 and the callers are advised to zero out the struct,; // programs built against older libclang versions would implicitly set the new; // options to default values, which should keep the behavior of previous; // libclang versions and thus be backward-compatible.; // If options->Size > sizeof(CXIndexOptions), the user may have set an option; // we can't handle, in which case we return nullptr to report failure.; // Replace `!=` with `>` here to support older struct versions. `!=` has the; // advantage of catching more usage bugs and no disadvantages while there is a; // single supported struct version (the initial version).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Modifiability,Config,Configure,3,// Configure the diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:179,Performance,perform,performance,179,"// Since the Clang C library is primarily used by batch tools dealing with; // (often very broken) source code, where spell-checking can have a; // significant negative impact on performance (particularly when; // precompiled headers are involved), we disable it by default.; // Only do this if we haven't found a spell-checking-related argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:9,Availability,failure,failures,9,// Early failures in LoadFromCommandLine may return with ErrUnit unset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:21,Performance,Load,LoadFromCommandLine,21,// Early failures in LoadFromCommandLine may return with ErrUnit unset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:57,Availability,error,errors,57,// We have an AST that has invalid nodes due to compiler errors.; // Use a crash recovery thread for protection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:81,Availability,recover,recovery,81,// We have an AST that has invalid nodes due to compiler errors.; // Use a crash recovery thread for protection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:81,Safety,recover,recovery,81,// We have an AST that has invalid nodes due to compiler errors.; // Use a crash recovery thread for protection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:46,Safety,unsafe,unsafe,46,"// If the translation unit has been marked as unsafe to free, just discard; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:41,Modifiability,variab,variables,41,// Mangling only works for functions and variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Avoid,Avoid,3,// Avoid having the implicit methods override the property decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:234,Modifiability,variab,variable,234,"// Avoid having the cursor of an expression replace the declaration cursor; // when the expression source range overlaps the declaration range.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure pointing at 'foo' returns a VarDecl; // cursor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Avoid,Avoid,3,"// Avoid having the cursor of an expression replace the declaration cursor; // when the expression source range overlaps the declaration range.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure pointing at 'foo' returns a VarDecl; // cursor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:69,Deployability,update,update,69,"// If we already have an Objective-C superclass reference, don't; // update it further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:403,Modifiability,enhance,enhanced,403,"// Clear out the ""FirstInDeclGroup"" part in a declaration cursor, since we; // can't set consistently. For example, when visiting a DeclStmt we will set; // it but we don't set it on the result of clang_getCursorDefinition for; // a reference of the same declaration.; // FIXME: Setting ""FirstInDeclGroup"" in CXCursors is a hack that only works; // when visiting a DeclStmt currently, the AST should be enhanced to be able; // to provide that kind of info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Usability,Clear,Clear,3,"// Clear out the ""FirstInDeclGroup"" part in a declaration cursor, since we; // can't set consistently. For example, when visiting a DeclStmt we will set; // it but we don't set it on the result of clang_getCursorDefinition for; // a reference of the same declaration.; // FIXME: Setting ""FirstInDeclGroup"" in CXCursors is a hack that only works; // when visiting a DeclStmt currently, the AST should be enhanced to be able; // to provide that kind of info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:19,Modifiability,variab,variables,19,"// FIXME: Multiple variables declared in a single declaration; // currently lack the information needed to correctly determine their; // ranges when accounting for the type-specifier. We use context; // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,; // and if so, whether it is the first decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:54,Testability,assert,assert,54,"// Guard against an invalid SourceLocation, or we may assert in one; // of the following calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:19,Modifiability,variab,variables,19,"// FIXME: Multiple variables declared in a single declaration; // currently lack the information needed to correctly determine their; // ranges when accounting for the type-specifier. We use context; // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,; // and if so, whether it is the first decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:53,Modifiability,extend,extended,53,"/// Retrieves the ""raw"" cursor extent, which is then extended to include; /// the decl-specifier-seq for declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:19,Modifiability,variab,variables,19,"// FIXME: Multiple variables declared in a single declaration; // currently lack the information needed to correctly determine their; // ranges when accounting for the type-specifier. We use context; // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,; // and if so, whether it is the first decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:11,Modifiability,variab,variable,11,// Ask the variable if it has a definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:77,Integrability,interface,interface,77,"// There are two notions of a ""definition"" for an Objective-C; // class: the interface and its implementation. When we resolved a; // reference to an Objective-C class, produce the @interface as; // the definition; when we were provided with the interface,; // produce the @implementation as the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:182,Integrability,interface,interface,182,"// There are two notions of a ""definition"" for an Objective-C; // class: the interface and its implementation. When we resolved a; // reference to an Objective-C class, produce the @interface as; // the definition; when we were provided with the interface,; // produce the @implementation as the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:246,Integrability,interface,interface,246,"// There are two notions of a ""definition"" for an Objective-C; // class: the interface and its implementation. When we resolved a; // reference to an Objective-C class, produce the @interface as; // the definition; when we were provided with the interface,; // produce the @implementation as the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:364,Safety,avoid,avoid,364,"// The DeclRefExpr of CXXOperatorCallExpr referring to the custom operator is; // visited before the arguments to the operator call. For the Call and; // Subscript operator the range of this DeclRefExpr includes the whole call; // expression, so that all tokens in that range would be mapped to the; // operator function, including the tokens of the arguments. To avoid that,; // ensure to visit this DeclRefExpr as last node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:223,Testability,test,test,223,"// This works differently than annotateAndAdvanceTokens; because expanded; // macro arguments can have arbitrary translation-unit source order, we do not; // advance the token index one by one until a token fails the range test.; // We only advance once past all of the macro arg tokens if all of them; // pass the range test. If one of them fails we keep the token index pointing; // at the start of the macro arg tokens so that the failing token will be; // annotated by a subsequent annotation try.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:321,Testability,test,test,321,"// This works differently than annotateAndAdvanceTokens; because expanded; // macro arguments can have arbitrary translation-unit source order, we do not; // advance the token index one by one until a token fails the range test.; // We only advance once past all of the macro arg tokens if all of them; // pass the range test. If one of them fails we keep the token index pointing; // at the start of the macro arg tokens so that the failing token will be; // annotated by a subsequent annotation try.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:82,Modifiability,variab,variable,82,"// Avoid having the cursor of an expression ""overwrite"" the annotation of the; // variable declaration that it belongs to.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:213,Modifiability,variab,variable,213,"// Avoid having the cursor of an expression ""overwrite"" the annotation of the; // variable declaration that it belongs to.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Safety,Avoid,Avoid,3,"// Avoid having the cursor of an expression ""overwrite"" the annotation of the; // variable declaration that it belongs to.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:250,Safety,avoid,avoid,250,// Before recursing into the children keep some state that we are going; // to use in the AnnotateTokensWorker::postVisitChildren callback to do some; // extra work after the child nodes are visited.; // Note that we don't call VisitChildren here to avoid traversing statements; // code-recursively which can blow the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Energy Efficiency,Adapt,Adapt,3,"// Adapt the end range, because LocationCompare() reports; // RangeOverlap even for the not-inclusive end location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Modifiability,Adapt,Adapt,3,"// Adapt the end range, because LocationCompare() reports; // RangeOverlap even for the not-inclusive end location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:14,Deployability,update,updated,14,"// All tokens updated for current range, check next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:64,Safety,avoid,avoid,64,"// Lex tokens in raw mode until we hit the end of the range, to avoid; // entering #includes or expanding macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:110,Testability,test,tests,110,"// We have found a preprocessing directive. Annotate the tokens; // appropriately.; //; // FIXME: Some simple tests here could identify macro definitions and; // #undefs, to provide specific cursor kinds for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:103,Usability,simpl,simple,103,"// We have found a preprocessing directive. Annotate the tokens; // appropriately.; //; // FIXME: Some simple tests here could identify macro definitions and; // #undefs, to provide specific cursor kinds for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:38,Safety,avoid,avoid,38,// This gets run a separate thread to avoid stack blowout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:9,Availability,avail,availability,9,"// If no availability attributes are found, inherit the attribute from the; // containing decl or the class or category interface decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:120,Integrability,interface,interface,120,"// If no availability attributes are found, inherit the attribute from the; // containing decl or the class or category interface decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:44,Modifiability,inherit,inherit,44,"// If no availability attributes are found, inherit the attribute from the; // containing decl or the class or category interface decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:60,Performance,cache,cache,60,// How much memory is being used by SourceManager's content cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:246,Safety,safe,safety,246,"//===----------------------------------------------------------------------===//; // Misc. utility functions.; //===----------------------------------------------------------------------===//; /// Default to using our desired 8 MB stack size on ""safety"" threads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:9,Modifiability,Portab,Portability,9,// TODO: Portability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:43,Energy Efficiency,allocate,allocate,43,"/// The CXCodeCompleteResults structure we allocate internally;; /// the client only sees the initial CXCodeCompleteResults structure.; ///; /// Normally, clients of CXString shouldn't care whether or not a CXString is; /// managed by a pool or by explicitly malloc'ed memory. But; /// AllocatedCXCodeCompleteResults outlives the CXTranslationUnit, so we can; /// not rely on the StringPool in the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:286,Energy Efficiency,Allocate,AllocatedCXCodeCompleteResults,286,"/// The CXCodeCompleteResults structure we allocate internally;; /// the client only sees the initial CXCodeCompleteResults structure.; ///; /// Normally, clients of CXString shouldn't care whether or not a CXString is; /// managed by a pool or by explicitly malloc'ed memory. But; /// AllocatedCXCodeCompleteResults outlives the CXTranslationUnit, so we can; /// not rely on the StringPool in the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:31,Performance,perform,performing,31,/// Diagnostics produced while performing code completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:4,Energy Efficiency,Allocate,Allocated,4,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:26,Integrability,wrap,wrappters,26,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:18,Security,expose,exposed,18,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:37,Performance,cache,cached,37,/// Allocator used to store globally cached code-completion results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:77,Integrability,message,message,77,/// A string containing the Objective-C selector entered thus far for a; /// message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:12,Integrability,interface,interface,12,"// Get the @interface declaration for a (possibly-qualified) Objective-C; // object pointer type, e.g., NSString*",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:12,Integrability,interface,interface,12,// Get the @interface declaration for an Objective-C object type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:27,Integrability,inject,injected-class-name,27,// Get the class for a C++ injected-class-name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:27,Security,inject,injected-class-name,27,// Get the class for a C++ injected-class-name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:3,Performance,Perform,Perform,3,// Perform the remapping of source files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:14,Testability,log,logging,14,// FIXME: Add logging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:3,Performance,Perform,Perform,3,// Perform completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:46,Performance,cache,cached,46,"// Keep a reference to the allocator used for cached global completions, so; // that we can be sure that the memory used by our code completion strings; // doesn't get freed due to subsequent reparses (while the code completion; // results are still active).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:210,Deployability,update,updated,210,"/// Simple utility function that appends a \p New string to the given; /// \p Old string, using the \p Buffer for storage.; ///; /// \param Old The string to which we are appending. This parameter will be; /// updated to reflect the complete string.; ///; ///; /// \param New The string to append to \p Old.; ///; /// \param Buffer A buffer that stores the actual, concatenated string. It will; /// be used if the old string is already-non-empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:4,Usability,Simpl,Simple,4,"/// Simple utility function that appends a \p New string to the given; /// \p Old string, using the \p Buffer for storage.; ///; /// \param Old The string to which we are appending. This parameter will be; /// updated to reflect the complete string.; ///; ///; /// \param New The string to append to \p Old.; ///; /// \param Buffer A buffer that stores the actual, concatenated string. It will; /// be used if the old string is already-non-empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:44,Integrability,Interface,Interface,44,"//===- CIndexDiagnostic.cpp - Diagnostics C Interface ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements the diagnostic functions of the Clang C interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:434,Integrability,interface,interface,434,"//===- CIndexDiagnostic.cpp - Diagnostics C Interface ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements the diagnostic functions of the Clang C interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:153,Availability,error,error-on-deserialized-decl,153,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:192,Availability,error,error,192,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:386,Availability,error,errors,386,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:482,Availability,error,error-on-deserialized-decl,482,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:538,Availability,error,error,538,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:659,Availability,error,error,659,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:680,Performance,perform,performing,680,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:134,Testability,test,testing,134,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:281,Testability,test,test,281,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:628,Testability,test,test,628,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:35,Deployability,update,updated,35,"// Diagnostics in the ASTUnit were updated, reset the associated; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:86,Integrability,Interface,Interface,86,//-----------------------------------------------------------------------------; // C Interface Routines; //-----------------------------------------------------------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:96,Integrability,Rout,Routines,96,//-----------------------------------------------------------------------------; // C Interface Routines; //-----------------------------------------------------------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:17,Availability,error,error,17,/* Print warning/error/etc. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h:43,Integrability,Interface,Interface,43,"/*===-- CIndexDiagnostic.h - Diagnostics C Interface ------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Implements the diagnostic functions of the Clang C interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h:459,Integrability,interface,interface,459,"/*===-- CIndexDiagnostic.h - Diagnostics C Interface ------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Implements the diagnostic functions of the Clang C interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:3,Performance,load,loadquery,3,// loadquery() was successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:27,Energy Efficiency,allocate,allocate,27,// errno == ENOMEM; try to allocate more memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:50,Performance,load,loadquery,50,// Loop to locate the function entry point in the loadquery() results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:25,Safety,avoid,avoids,25,// This silly cast below avoids a C++ warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:78,Availability,error,error,78,"// It's rather unlikely we end up here. But it could happen, so report an; // error instead of crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:3,Performance,Cache,Cache,3,// Cache our result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:46,Testability,log,log,46,// Create a temporary file for the invocation log.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:4,Testability,Log,Logs,4,/// Logs information about a particular libclang operation like parsing to; /// a new file in the invocation emission path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:44,Safety,safe,safety,44,"/// Return the current size to request for ""safety"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:41,Safety,safe,safety,41,"/// Set the current size to request for ""safety"" (or 0, if safety; /// threads should not be used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:59,Safety,safe,safety,59,"/// Set the current size to request for ""safety"" (or 0, if safety; /// threads should not be used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:51,Availability,recover,recovery,51,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:30,Safety,safe,safely,30,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:51,Safety,recover,recovery,51,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:63,Safety,safe,safety,63,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:137,Safety,detect,detected,137,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:48,Availability,error,error,48,/// Print libclang's resource usage to standard error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:24,Integrability,Interface,Interface,24,"//===- CLog.h - Logging Interface -------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:16,Testability,Log,Logging,16,"//===- CLog.h - Logging Interface -------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:13,Testability,log,logging,13,"/// Collects logging output and writes it to stderr when it's destructed.; /// Common use case:; /// \code; /// if (LogRef Log = Logger::make(__func__)) {; /// *Log << ""stuff"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:116,Testability,Log,LogRef,116,"/// Collects logging output and writes it to stderr when it's destructed.; /// Common use case:; /// \code; /// if (LogRef Log = Logger::make(__func__)) {; /// *Log << ""stuff"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:123,Testability,Log,Log,123,"/// Collects logging output and writes it to stderr when it's destructed.; /// Common use case:; /// \code; /// if (LogRef Log = Logger::make(__func__)) {; /// *Log << ""stuff"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:129,Testability,Log,Logger,129,"/// Collects logging output and writes it to stderr when it's destructed.; /// Common use case:; /// \code; /// if (LogRef Log = Logger::make(__func__)) {; /// *Log << ""stuff"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:161,Testability,Log,Log,161,"/// Collects logging output and writes it to stderr when it's destructed.; /// Common use case:; /// \code; /// if (LogRef Log = Logger::make(__func__)) {; /// *Log << ""stuff"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:38,Testability,Log,Logger,38,"/// Macros to automate common uses of Logger. Like this:; /// \code; /// LOG_FUNC_SECTION {; /// *Log << ""blah"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h:98,Testability,Log,Log,98,"/// Macros to automate common uses of Logger. Like this:; /// \code; /// LOG_FUNC_SECTION {; /// *Log << ""blah"";; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:39,Integrability,interface,interface,39,"//===- CursorVisitor.h - CursorVisitor interface ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:16,Energy Efficiency,allocate,allocated,16,// Cache of pre-allocated worklists for data-recursion walk of Stmts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:3,Performance,Cache,Cache,3,// Cache of pre-allocated worklists for data-recursion walk of Stmts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h:16,Energy Efficiency,allocate,allocated,16,// Free the pre-allocated worklists for data-recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CursorVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXComment.h:21,Integrability,Rout,Routines,21,"//===- CXComment.h - Routines for manipulating CXComments -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXComments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXComment.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXComment.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXComment.h:401,Integrability,rout,routines,401,"//===- CXComment.h - Routines for manipulating CXComments -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXComments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXComment.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXComment.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp:44,Availability,error,error,44,// FIXME: do something more useful with the error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp:50,Integrability,message,message,50,// FIXME: do something more useful with the error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:22,Integrability,Rout,Routines,22,"//===- CXCursor.cpp - Routines for manipulating CXCursors -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors. It should be the; // only file that has internal knowledge of the encoding of the data in; // CXCursor.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:401,Integrability,rout,routines,401,"//===- CXCursor.cpp - Routines for manipulating CXCursors -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors. It should be the; // only file that has internal knowledge of the encoding of the data in; // CXCursor.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:10,Security,Expose,Expose,10,// FIXME: Expose these values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:70,Energy Efficiency,reduce,reduces,70,"// Clear out the vector, but don't free the memory contents. This; // reduces malloc() traffic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:3,Usability,Clear,Clear,3,"// Clear out the vector, but don't free the memory contents. This; // reduces malloc() traffic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp:76,Availability,avail,available,76,"// Did we get any overridden cursors? If not, return Vec to the pool; // of available cursor vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:20,Integrability,Rout,Routines,20,"//===- CXCursor.h - Routines for manipulating CXCursors -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:401,Integrability,rout,routines,401,"//===- CXCursor.h - Routines for manipulating CXCursors -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:48,Integrability,interface,interface,48,/// Unpack an ObjCSuperClassRef cursor into the interface it references; /// and optionally the location where the reference occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:26,Integrability,protocol,protocol,26,/// Create an Objective-C protocol reference at the given location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:46,Integrability,protocol,protocol,46,/// Unpack an ObjCProtocolRef cursor into the protocol it references; /// and optionally the location where the reference occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:28,Modifiability,variab,variable,28,/// Create a reference to a variable at the given location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:13,Modifiability,Variab,VariableRef,13,/// Unpack a VariableRef cursor into the variable it references and the; /// location where the where the reference occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:41,Modifiability,variab,variable,41,/// Unpack a VariableRef cursor into the variable it references and the; /// location where the where the reference occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:4,Integrability,Wrap,Wraps,4,"/// Wraps a macro expansion cursor and provides a common interface; /// for a normal macro expansion cursor or a ""pseudo"" one.; ///; /// ""Pseudo"" macro expansion cursors (essentially a macro definition along with; /// a source location) are created in special cases, for example they can be; /// created for identifiers inside macro definitions, if these identifiers are; /// macro names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h:57,Integrability,interface,interface,57,"/// Wraps a macro expansion cursor and provides a common interface; /// for a normal macro expansion cursor or a ""pseudo"" one.; ///; /// ""Pseudo"" macro expansion cursors (essentially a macro definition along with; /// a source location) are created in special cases, for example they can be; /// created for identifiers inside macro definitions, if these identifiers are; /// macro names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXCursor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCursor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXExtractAPI.cpp:78,Integrability,interface,interface,78,// Build declaration fragments and sub-heading by generating them for the; // interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXExtractAPI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXExtractAPI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXFile.h:18,Integrability,Rout,Routines,18,"//===- CXFile.h - Routines for manipulating CXFile --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h:11,Deployability,Release,Release,11,"/// Retain/Release only useful when we allocate a AttrListInfo from the; /// BumpPtrAllocator, and not from the stack; so that we keep a pointer; // in the EntityInfo",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h:39,Energy Efficiency,allocate,allocate,39,"/// Retain/Release only useful when we allocate a AttrListInfo from the; /// BumpPtrAllocator, and not from the stack; so that we keep a pointer; // in the EntityInfo",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h:13,Energy Efficiency,allocate,allocated,13,"// Memory is allocated from a BumpPtrAllocator, no need to delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp:85,Modifiability,Extend,Extend,85,//===----------------------------------------------------------------------===//; // Extend CXDiagnosticSetImpl which contains strings for diagnostics.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp:19,Modifiability,refactor,refactor,19,// FIXME: possibly refactor with logic in CXStoredDiagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp:33,Testability,log,logic,33,// FIXME: possibly refactor with logic in CXStoredDiagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp:311,Performance,optimiz,optimize,311,"// CXSourceLocation consists of the following fields:; //; // void *ptr_data[2];; // unsigned int_data;; //; // The lowest bit of ptr_data[0] is always set to 1 to indicate this; // is a persistent diagnostic.; //; // For now, do the unoptimized approach and store the data in a side; // data structure. We can optimize this case later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXLoadedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp:401,Integrability,rout,routines,401,"//===- CXSourceLocation.cpp - CXSourceLocations APIs ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXSourceLocations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp:24,Usability,clear,clear,24,"// If the lowest bit is clear then the first ptr_data entry is a SourceManager; // pointer, or the CXSourceLocation is a null location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp:85,Integrability,Rout,Routines,85,"//===----------------------------------------------------------------------===//; // Routines for expanding and manipulating CXSourceLocations, regardless; // of their origin.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h:401,Integrability,rout,routines,401,"//===- CXSourceLocation.h - CXSourceLocations Utilities ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXSourceLocations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h:295,Integrability,rout,routine,295,"/// Translate a Clang source range into a CIndex source range.; ///; /// Clang internally represents ranges where the end location points to the; /// start of the token at the end. However, for external clients it is more; /// useful to have a CXSourceRange be a proper half-open interval. This routine; /// does the appropriate translation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp:46,Integrability,Interface,Interface,46,"//===- CXStoredDiagnostic.cpp - Diagnostics C Interface -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements part of the diagnostic functions of the Clang C interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp:442,Integrability,interface,interface,442,"//===- CXStoredDiagnostic.cpp - Diagnostics C Interface -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements part of the diagnostic functions of the Clang C interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXStoredDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp:22,Integrability,Rout,Routines,22,"//===- CXString.cpp - Routines for manipulating CXStrings -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings. It should be the; // only file that has internal knowledge of the encoding of the data in; // CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp:401,Integrability,rout,routines,401,"//===- CXString.cpp - Routines for manipulating CXStrings -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings. It should be the; // only file that has internal knowledge of the encoding of the data in; // CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp:47,Energy Efficiency,allocate,allocated,47,/// CXString contains a 'const char *' that it allocated with malloc().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h:20,Integrability,Rout,Routines,20,"//===- CXString.h - Routines for manipulating CXStrings -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h:401,Integrability,rout,routines,401,"//===- CXString.h - Routines for manipulating CXStrings -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h:121,Availability,error,errors,121,"/// Create a CXString object for an NULL string.; ///; /// A NULL string should be used as an ""invalid"" value in case of errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h:29,Integrability,Rout,Routines,29,"//===- CXTranslationUnit.h - Routines for manipulating CXTranslationUnits -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXTranslationUnits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h:401,Integrability,rout,routines,401,"//===- CXTranslationUnit.h - Routines for manipulating CXTranslationUnits -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXTranslationUnits.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXTranslationUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:20,Security,expose,expose,20,// FIXME: We should expose the canThrow(...) result instead of the EST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:305,Availability,error,error,305,"// [expr.sizeof] p1: return -1 on: func, incomplete, bitfield, incomplete; // enumeration; // Note: We get the cxtype, not the cxcursor, so we can't call; // FieldDecl->isBitField(); // [expr.sizeof] p3: pointer ok, function not ok.; // [gcc extension] lib/AST/ExprConstant.cpp:1372 HandleSizeof : vla == error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:3,Security,validat,validate,3,// validate parent declaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:3,Security,validat,validate,3,// validate parent type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:62,Integrability,depend,dependent,62,// We recurse into all record fields to detect incomplete and dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:40,Safety,detect,detect,40,// We recurse into all record fields to detect incomplete and dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:35,Integrability,depend,dependent,35,// check that PT is not incomplete/dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:15,Security,validat,validateFieldParentType,15,// verified in validateFieldParentType,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:202,Availability,failure,failure,202,"// If a field of the parent record is incomplete, lookup will fail.; // and we would return InvalidFieldName instead of Incomplete.; // But this erroneous results does protects again a hidden assertion failure; // in the RecordLayoutBuilder",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:192,Testability,assert,assertion,192,"// If a field of the parent record is incomplete, lookup will fail.; // and we would return InvalidFieldName instead of Incomplete.; // But this erroneous results does protects again a hidden assertion failure; // in the RecordLayoutBuilder",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:14,Security,validat,validate,14,// we need to validate the parent type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.h:19,Integrability,Rout,Routines,19,"//===- CXTypes.h - Routines for manipulating CXTypes ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.h:401,Integrability,rout,routines,401,"//===- CXTypes.h - Routines for manipulating CXTypes ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXCursors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/CXType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp:46,Availability,Error,Error,46,"/*===-- clang-c/FatalErrorHandler.cpp - Fatal Error Handling ------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp:34,Safety,avoid,avoiding,34,// Write the result out to stderr avoiding errs() because raw_ostreams can; // call report_fatal_error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:86,Safety,safe,safe,86,/// Keeps track of function bodies that have already been parsed.; ///; /// Is thread-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:131,Safety,safe,safe,131,/// Provides information whether source locations have already been parsed in; /// another FrontendAction.; ///; /// Is NOT thread-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:4,Deployability,Update,Updates,4,/// Updates ParsedRegionsStorage with newly parsed regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:85,Deployability,release,released,85,/// MacroUndefined - This hook is called whenever a macro #undef is seen.; /// MI is released immediately following this callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Modifiability,Config,Configure,3,// Configure the diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:168,Performance,perform,performance,168,"// Since libclang is primarily used by batch tools dealing with; // (often very broken) source code, where spell-checking can have a; // significant negative impact on performance (particularly when ; // precompiled headers are involved), we disable it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:33,Performance,optimiz,optimization,33,// Enable the skip-parsed-bodies optimization only for C++; this may be; // revisited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Index_Internal.h:20,Integrability,Rout,Routines,20,"//===- CXString.h - Routines for manipulating CXStrings -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Index_Internal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Index_Internal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Index_Internal.h:401,Integrability,rout,routines,401,"//===- CXString.h - Routines for manipulating CXStrings -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for manipulating CXStrings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Index_Internal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Index_Internal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Rewrite.cpp:7,Modifiability,Rewrite,Rewrite,7,"//===- Rewrite.cpp --------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/libclang/Rewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Rewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp:28,Deployability,install,installed,28,"//===- NVPTXArch.cpp - list installed NVPTX devies ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of CUDA gpus installed in the; // system.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp:443,Deployability,install,installed,443,"//===- NVPTXArch.cpp - list installed NVPTX devies ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of CUDA gpus installed in the; // system.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp:415,Safety,detect,detecting,415,"//===- NVPTXArch.cpp - list installed NVPTX devies ------*- C++ -*---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a tool for detecting name of CUDA gpus installed in the; // system.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp:14,Performance,load,load,14,// Attempt to load the NVPTX driver runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/nvptx-arch/NVPTXArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:125,Availability,Down,Download,125,"/*; SortTable; version 2; 7th April 2007; Stuart Langridge, http://www.kryogenix.org/code/browser/sorttable/. Instructions:; Download this file; Add <script src=""sorttable.js""></script> to your HTML; Add class=""sortable"" to any table you'd like to make sortable; Click on the headers to sort. Thanks to many, many people for contributions and suggestions.; Licenced as X11: http://www.kryogenix.org/code/browser/licence.html; This basically means: do what you want with it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:115,Integrability,depend,depending,115,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:109,Safety,avoid,avoid,109,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:12,Security,hash,hash,12,// create a hash table of event types for the element,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:12,Security,hash,hash,12,// create a hash table of event handlers for each element/event pair,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:34,Security,hash,hash,34,// store the event handler in the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:37,Security,hash,hash,37,// delete the event handler from the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:26,Security,hash,hash,26,// get a reference to the hash table of event handlers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:567,Integrability,inject,inject,567,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:848,Modifiability,variab,variable,848,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:304,Performance,load,loaded,304,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:434,Performance,load,load,434,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:567,Security,inject,inject,567,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:576,Testability,log,logic,576,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:616,Testability,log,logic,616,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:767,Testability,log,log,767,"/* -*- coding: utf-8 -*-; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; */; /**; * This file implements a shared library. This library can be pre-loaded by; * the dynamic linker of the Operating System (OS). It implements a few function; * related to process creation. By pre-load this library the executed process; * uses these functions instead of those from the standard library.; *; * The idea here is to inject a logic before call the real methods. The logic is; * to dump the call into a file. To call the real method this library is doing; * the job of the dynamic linker.; *; * The only input for the log writing is about the destination directory.; * This is passed as environment variable.; */; // NOLINTNEXTLINE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:62,Modifiability,variab,variables,62,/* Initialization method to Captures the relevant environment variables.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:27,Testability,log,log,27,/* this method is to write log about the process creation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:3,Deployability,update,update,3,/* update environment assure that children processes will copy the desired; * behaviour */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:3,Energy Efficiency,allocate,allocate,3,// allocate a environment entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py:18,Integrability,interface,interface,18,"""""""part of public interface""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py:18,Integrability,interface,interface,18,"""""""part of public interface""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py:18,Integrability,interface,interface,18,"""""""part of public interface""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:130,Integrability,wrap,wrappers,130,"# Run against a build command. there are cases, when analyzer run; # is not required. But we need to set up everything for the; # wrappers, because 'configure' needs to capture the CC/CXX values; # for the Makefile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:149,Modifiability,config,configure,149,"# Run against a build command. there are cases, when analyzer run; # is not required. But we need to set up everything for the; # wrappers, because 'configure' needs to capture the CC/CXX values; # for the Makefile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:47,Integrability,wrap,wrappers,47,# Run build command and analyzer with compiler wrappers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:254,Integrability,wrap,wrappers,254,"""""""Check the intent of the build command. When static analyzer run against project configure step, it should be; silent and no need to run the analyzer or generate report. To run `scan-build` against the configure step might be necessary,; when compiler wrappers are used. That's the moment when build setup; check the compiler and capture the location for the build process.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:83,Modifiability,config,configure,83,"""""""Check the intent of the build command. When static analyzer run against project configure step, it should be; silent and no need to run the analyzer or generate report. To run `scan-build` against the configure step might be necessary,; when compiler wrappers are used. That's the moment when build setup; check the compiler and capture the location for the build process.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:204,Modifiability,config,configure,204,"""""""Check the intent of the build command. When static analyzer run against project configure step, it should be; silent and no need to run the analyzer or generate report. To run `scan-build` against the configure step might be necessary,; when compiler wrappers are used. That's the moment when build setup; check the compiler and capture the location for the build process.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:7,Deployability,configurat,configuration,7,"""""""CTU configuration is created from the chosen phases and dir.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:7,Modifiability,config,configuration,7,"""""""CTU configuration is created from the chosen phases and dir.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:7,Deployability,configurat,configuration,7,"""""""CTU configuration is created from the chosen phases and dir.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:7,Modifiability,config,configuration,7,"""""""CTU configuration is created from the chosen phases and dir.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:2,Availability,Recover,Recover,2,# Recover namedtuple from json when coming from analyze-cc or analyze-c++,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:2,Safety,Recover,Recover,2,# Recover namedtuple from json when coming from analyze-cc or analyze-c++,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:10,Availability,error,error,10,# display error message from the static analyzer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:16,Integrability,message,message,16,# display error message from the static analyzer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:62,Integrability,wrap,wrapper,62,"""""""Set up environment for build command to interpose compiler wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:59,Integrability,wrap,wrappers,59,"""""""Entry point for `analyze-cc` and `analyze-c++` compiler wrappers.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:32,Integrability,wrap,wrapper,32,"""""""Implements analyzer compiler wrapper functionality.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:10,Availability,error,error,10,# display error message from the static analyzer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:16,Integrability,message,message,16,# display error message from the static analyzer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:461,Integrability,contract,contract,461,"""""""Entry point to run (or not) static analyzer against a single entry; of the compilation database. This complex task is decomposed into smaller methods which are calling; each other in chain. If the analysis is not possible the given method; just return and break the chain. The passed parameter is a python dictionary. Each method first check; that the needed parameters received. (This is done by the 'require'; decorator. It's like an 'assert' to check the contract between the; caller and the called method.)""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:440,Testability,assert,assert,440,"""""""Entry point to run (or not) static analyzer against a single entry; of the compilation database. This complex task is decomposed into smaller methods which are calling; each other in chain. If the analysis is not possible the given method; just return and break the chain. The passed parameter is a python dictionary. Each method first check; that the needed parameters received. (This is done by the 'require'; decorator. It's like an 'assert' to check the contract between the; caller and the called method.)""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:11,Availability,failure,failures,11,"""""""Creates failures directory if not exits yet.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:11,Availability,error,error,11,# Classify error type: when Clang terminated by a signal it's a 'Crash'.; # (python subprocess Popen.returncode is negative when child terminated; # by signal.) Everything else is 'Other Error'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:187,Availability,Error,Error,187,# Classify error type: when Clang terminated by a signal it's a 'Crash'.; # (python subprocess Popen.returncode is negative when child terminated; # by signal.) Everything else is 'Other Error'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:119,Availability,failure,failure,119,"""""""It assembles the analysis command line and executes it. Capture the; output of the analysis and returns with it. If failure reports are; requested, it calls the continuation to generate it.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:49,Modifiability,inherit,inherited,49,# will set up own output file; # flags below are inherited from the perl implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:64,Integrability,interface,interfaces,64,""""""" This module parses and validates arguments for command-line interfaces. It uses argparse module to create the command line parser. (This library is; in the standard python library since 3.2 and backported to 2.7, but not; earlier.). It also implements basic validation methods, related to the command.; Validations are mostly calling specific help methods, or mangling values.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:27,Security,validat,validates,27,""""""" This module parses and validates arguments for command-line interfaces. It uses argparse module to create the command line parser. (This library is; in the standard python library since 3.2 and backported to 2.7, but not; earlier.). It also implements basic validation methods, related to the command.; Validations are mostly calling specific help methods, or mangling values.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:262,Security,validat,validation,262,""""""" This module parses and validates arguments for command-line interfaces. It uses argparse module to create the command line parser. (This library is; in the standard python library since 3.2 and backported to 2.7, but not; earlier.). It also implements basic validation methods, related to the command.; Validations are mostly calling specific help methods, or mangling values.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:307,Security,Validat,Validations,307,""""""" This module parses and validates arguments for command-line interfaces. It uses argparse module to create the command line parser. (This library is; in the standard python library since 3.2 and backported to 2.7, but not; earlier.). It also implements basic validation methods, related to the command.; Validations are mostly calling specific help methods, or mangling values.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:13,Security,validat,validate,13,"""""""Parse and validate command-line arguments for intercept-build.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:8,Security,validat,validation,8,# short validation logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:19,Testability,log,logic,19,# short validation logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:13,Security,validat,validate,13,"""""""Parse and validate command-line arguments for analyze-build.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:13,Security,validat,validate,13,"""""""Parse and validate command-line arguments for scan-build.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:7,Modifiability,plugin,plugins,7,# make plugins always a list. (it might be None when not specified.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:70,Security,validat,validation,70,"""""""Command line parsing is done by the argparse module, but semantic; validation still needs to be done. This method is doing it for; analyze-build and scan-build commands. :param parser: The command line parser object.; :param args: Parsed argument object.; :param from_build_command: Boolean value tells is the command suppose; to run the analyzer against a build command or a compilation db.; :return: No return value, but this call might throw when validation; fails.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:453,Security,validat,validation,453,"""""""Command line parsing is done by the argparse module, but semantic; validation still needs to be done. This method is doing it for; analyze-build and scan-build commands. :param parser: The command line parser object.; :param args: Parsed argument object.; :param from_build_command: Boolean value tells is the command suppose; to run the analyzer against a build command or a compilation db.; :return: No return value, but this call might throw when validation; fails.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:146,Deployability,continuous,continuously,146,"""""""Extend existing compilation database with new entries.; Duplicate entries are detected and not present in the final output.; The output is not continuously updated, it's done when the build; command finished. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:159,Deployability,update,updated,159,"""""""Extend existing compilation database with new entries.; Duplicate entries are detected and not present in the final output.; The output is not continuously updated, it's done when the build; command finished. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Modifiability,Extend,Extend,3,"""""""Extend existing compilation database with new entries.; Duplicate entries are detected and not present in the final output.; The output is not continuously updated, it's done when the build; command finished. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:81,Safety,detect,detected,81,"""""""Extend existing compilation database with new entries.; Duplicate entries are detected and not present in the final output.; The output is not continuously updated, it's done when the build; command finished. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:210,Integrability,wrap,wrapper,210,"""""""Run the build commands first, intercept compiler; calls and then run the static analyzer afterwards.; Generally speaking it has better coverage on build commands.; With '--override-compiler' it use compiler wrapper, but does; not run the analyzer till the build is finished.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:20,Availability,failure,failures,20,"""""""Do not create a 'failures' subdirectory that includes analyzer; crash reports and preprocessed source files.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:96,Energy Efficiency,power,powerful,96,"""""""Specify the constraint engine used by the analyzer. Specifying; 'basic' uses a simpler, less powerful constraint model used by; checker-0.160 and earlier.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:82,Usability,simpl,simpler,82,"""""""Specify the constraint engine used by the analyzer. Specifying; 'basic' uses a simpler, less powerful constraint model used by; checker-0.160 and earlier.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:143,Availability,Avail,Available,143,"""""""Provide options to pass through to the analyzer's; -analyzer-config flag. Several options are separated with comma:; 'key1=val1,key2=val2'. Available options:; stable-report-filename=true or false (default). Switch the page naming to:; report-<filename>-<function/method name>-<id>.html; instead of report-XXXXXX.html""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:64,Modifiability,config,config,64,"""""""Provide options to pass through to the analyzer's; -analyzer-config flag. Several options are separated with comma:; 'key1=val1,key2=val2'. Available options:; stable-report-filename=true or false (default). Switch the page naming to:; report-<filename>-<function/method name>-<id>.html; instead of report-XXXXXX.html""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:28,Testability,assert,assertions,28,"""""""Tells analyzer to enable assertions in code even if they were; disabled during compilation, enabling more precise results.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:52,Integrability,interface,interface,52,"""""""Loading external checkers using the clang plugin interface.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:45,Modifiability,plugin,plugin,45,"""""""Loading external checkers using the clang plugin interface.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Performance,Load,Loading,3,"""""""Loading external checkers using the clang plugin interface.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:13,Availability,avail,available,13,"""""""Print all available checkers and mark the enabled ones.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Performance,Perform,Perform,3,"""""""Perform cross translation unit (ctu) analysis (both collect; and analyze phases) using default <ctu-dir> for temporary output.; At the end of the analysis, the temporary directory is removed.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Performance,Perform,Perform,3,"""""""Perform only the collect phase of ctu.; Keep <ctu-dir> for further use.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:3,Performance,Perform,Perform,3,"""""""Perform only the analyze phase of ctu. <ctu-dir> should be; present and will not be removed after analysis.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:45,Integrability,wrap,wrapper,45,"""""""Creates command line parser for all build wrapper commands.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:81,Availability,avail,available,81,"""""""Always resort to the compiler wrapper even when better; intercept methods are available.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:33,Integrability,wrap,wrapper,33,"""""""Always resort to the compiler wrapper even when better; intercept methods are available.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:65,Integrability,wrap,wrapper,65,"""""""When '%(prog)s' analyzes a project by interposing a compiler; wrapper, which executes a real compiler for compilation and do other; tasks (record the compiler invocation). Because of this interposing,; '%(prog)s' does not know what compiler your project normally uses.; Instead, it simply overrides the CC environment variable, and guesses; your default compiler. If you need '%(prog)s' to use a specific compiler for *compilation*; then you can use this option to specify a path to that compiler.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:321,Modifiability,variab,variable,321,"""""""When '%(prog)s' analyzes a project by interposing a compiler; wrapper, which executes a real compiler for compilation and do other; tasks (record the compiler invocation). Because of this interposing,; '%(prog)s' does not know what compiler your project normally uses.; Instead, it simply overrides the CC environment variable, and guesses; your default compiler. If you need '%(prog)s' to use a specific compiler for *compilation*; then you can use this option to specify a path to that compiler.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:285,Usability,simpl,simply,285,"""""""When '%(prog)s' analyzes a project by interposing a compiler; wrapper, which executes a real compiler for compilation and do other; tasks (record the compiler invocation). Because of this interposing,; '%(prog)s' does not know what compiler your project normally uses.; Instead, it simply overrides the CC environment variable, and guesses; your default compiler. If you need '%(prog)s' to use a specific compiler for *compilation*; then you can use this option to specify a path to that compiler.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:82,Integrability,interface,interface,82,""""""" This module is responsible for the Clang executable. Since Clang command line interface is so rich, but this project is using only; a subset of that, it makes sense to create a function specific wrapper. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:199,Integrability,wrap,wrapper,199,""""""" This module is responsible for the Clang executable. Since Clang command line interface is so rich, but this project is using only; a subset of that, it makes sense to create a function specific wrapper. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:80,Modifiability,plugin,plugins,80,"""""""Get the active checker list. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: list of checker names which are active. To get the default checkers we execute Clang to print how this; compilation would be called. And take out the enabled checker from the; arguments. For input file we specify stdin and pass only language; information.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:97,Modifiability,plugin,plugins,97,"""""""Get the active checker list. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: list of checker names which are active. To get the default checkers we execute Clang to print how this; compilation would be called. And take out the enabled checker from the; arguments. For input file we specify stdin and pass only language; information.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:15,Availability,avail,available,15,"""""""Get all the available checkers from default and from the plugins. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: a dictionary of all available checkers and its status. {<checker name>: (<checker description>, <is active by default>)}""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:204,Availability,avail,available,204,"""""""Get all the available checkers from default and from the plugins. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: a dictionary of all available checkers and its status. {<checker name>: (<checker description>, <is active by default>)}""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:60,Modifiability,plugin,plugins,60,"""""""Get all the available checkers from default and from the plugins. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: a dictionary of all available checkers and its status. {<checker name>: (<checker description>, <is active by default>)}""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:117,Modifiability,plugin,plugins,117,"""""""Get all the available checkers from default and from the plugins. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: a dictionary of all available checkers and its status. {<checker name>: (<checker description>, <is active by default>)}""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:134,Modifiability,plugin,plugins,134,"""""""Get all the available checkers from default and from the plugins. :param clang: the compiler we are using; :param plugins: list of plugins which was requested by the user; :return: a dictionary of all available checkers and its status. {<checker name>: (<checker description>, <is active by default>)}""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:3,Safety,Detect,Detects,3,"""""""Detects if the current (or given) clang and external definition mapping; executables are CTU compatible.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:693,Integrability,wrap,wrappers,693,""""""" This module is responsible to capture the compiler invocation of any; build process. The result of that should be a compilation database. This implementation is using the LD_PRELOAD or DYLD_INSERT_LIBRARIES; mechanisms provided by the dynamic linker. The related library is implemented; in C language and can be found under 'libear' directory. The 'libear' library is capturing all child process creation and logging the; relevant information about it into separate files in a specified directory.; The parameter of this process is the output directory name, where the report; files shall be placed. This parameter is passed as an environment variable. The module also implements compiler wrappers to intercept the compiler calls. The module implements the build command execution and the post-processing of; the output files, which will condensates into a compilation database. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:647,Modifiability,variab,variable,647,""""""" This module is responsible to capture the compiler invocation of any; build process. The result of that should be a compilation database. This implementation is using the LD_PRELOAD or DYLD_INSERT_LIBRARIES; mechanisms provided by the dynamic linker. The related library is implemented; in C language and can be found under 'libear' directory. The 'libear' library is capturing all child process creation and logging the; relevant information about it into separate files in a specified directory.; The parameter of this process is the output directory name, where the report; files shall be placed. This parameter is passed as an environment variable. The module also implements compiler wrappers to intercept the compiler calls. The module implements the build command execution and the post-processing of; the output files, which will condensates into a compilation database. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:413,Testability,log,logging,413,""""""" This module is responsible to capture the compiler invocation of any; build process. The result of that should be a compilation database. This implementation is using the LD_PRELOAD or DYLD_INSERT_LIBRARIES; mechanisms provided by the dynamic linker. The related library is implemented; in C language and can be found under 'libear' directory. The 'libear' library is capturing all child process creation and logging the; relevant information about it into separate files in a specified directory.; The parameter of this process is the output directory name, where the report; files shall be placed. This parameter is passed as an environment variable. The module also implements compiler wrappers to intercept the compiler calls. The module implements the build command execution and the post-processing of; the output files, which will condensates into a compilation database. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:201,Integrability,wrap,wrapper,201,"""""""Sets up the environment for the build command. It sets the required environment variables and execute the given command.; The exec calls will be logged by the 'libear' preloaded library or by the; 'wrapper' programs.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:83,Modifiability,variab,variables,83,"""""""Sets up the environment for the build command. It sets the required environment variables and execute the given command.; The exec calls will be logged by the 'libear' preloaded library or by the; 'wrapper' programs.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:148,Testability,log,logged,148,"""""""Sets up the environment for the build command. It sets the required environment variables and execute the given command.; The exec calls will be logged by the 'libear' preloaded library or by the; 'wrapper' programs.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:32,Integrability,wrap,wrapper,32,"""""""Implement intercept compiler wrapper functionality. It does generate execution report into target directory.; The target directory name is from environment variables.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:159,Modifiability,variab,variables,159,"""""""Implement intercept compiler wrapper functionality. It does generate execution report into target directory.; The target directory name is from environment variables.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:169,Integrability,wrap,wrapper,169,"""""""Parse the file generated by the 'libear' preloaded library. Given filename points to a file which contains the basic report; generated by the interception library or wrapper command. A single; report file _might_ contain multiple process creation info.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:88,Safety,detect,detected,88,"""""""Library-based interposition will fail silently if SIP is enabled,; so this should be detected. You can detect whether SIP is enabled on; Darwin by checking whether (1) there is a binary called 'csrutil' in; the path and, if so, (2) whether the output of executing 'csrutil status'; contains 'System Integrity Protection status: enabled'. :param platform: name of the platform (returned by sys.platform),; :return: True if library preload will fail by the dynamic linker.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:106,Safety,detect,detect,106,"""""""Library-based interposition will fail silently if SIP is enabled,; so this should be detected. You can detect whether SIP is enabled on; Darwin by checking whether (1) there is a binary called 'csrutil' in; the path and, if so, (2) whether the output of executing 'csrutil status'; contains 'System Integrity Protection status: enabled'. :param platform: name of the platform (returned by sys.platform),; :return: True if library preload will fail by the dynamic linker.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:302,Security,Integrity,Integrity,302,"""""""Library-based interposition will fail silently if SIP is enabled,; so this should be detected. You can detect whether SIP is enabled on; Darwin by checking whether (1) there is a binary called 'csrutil' in; the path and, if so, (2) whether the output of executing 'csrutil status'; contains 'System Integrity Protection status: enabled'. :param platform: name of the platform (returned by sys.platform),; :return: True if library preload will fail by the dynamic linker.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:20,Security,hash,hash,20,"""""""Implement unique hash method for compilation database entries.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:43,Integrability,wrap,wrappers,43,# On OS X the 'cc' and 'c++' compilers are wrappers for; # 'clang' therefore both call would be logged. To avoid; # this the hash does not contain the first word of the; # command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:107,Safety,avoid,avoid,107,# On OS X the 'cc' and 'c++' compilers are wrappers for; # 'clang' therefore both call would be logged. To avoid; # this the hash does not contain the first word of the; # command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:125,Security,hash,hash,125,# On OS X the 'cc' and 'c++' compilers are wrappers for; # 'clang' therefore both call would be logged. To avoid; # this the hash does not contain the first word of the; # command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:96,Testability,log,logged,96,# On OS X the 'cc' and 'c++' compilers are wrappers for; # 'clang' therefore both call would be logged. To avoid; # this the hash does not contain the first word of the; # command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:153,Deployability,Toggle,ToggleDisplay,153,"""""""; | <tr>; | <td class=""SUMM_DESC"">{bug_type}</td>; | <td class=""Q"">{bug_count}</td>; | <td>; | <center>; | <input checked type=""checkbox""; | onClick=""ToggleDisplay(this,'{bug_type_class}');""/>; | </center>; | </td>; | </tr>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:19,Availability,Failure,Failures,19,"""""""; |<h2>Analyzer Failures</h2>; |<p>The analyzer had problems processing the following files:</p>; |<table>; | <thead>; | <tr>; | <td>Problem</td>; | <td>Source File</td>; | <td>Preprocessed File</td>; | <td>STDERR Output</td>; | </tr>; | </thead>; | <tbody>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:257,Integrability,message,messages,257,"""""""Reads and merges all .sarif files in the given output directory. Each sarif file in the output directory is understood as a single run; and thus appear separate in the top level runs array. This requires; modifying the run index of any embedded links in messages.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:98,Deployability,update,updates,98,"""""""; Given a SARIF object, checks its dictionary entries for a 'message' property.; If it exists, updates the message index of embedded links in the run index. Recursively looks through entries in the dictionary.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:64,Integrability,message,message,64,"""""""; Given a SARIF object, checks its dictionary entries for a 'message' property.; If it exists, updates the message index of embedded links in the run index. Recursively looks through entries in the dictionary.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:110,Integrability,message,message,110,"""""""; Given a SARIF object, checks its dictionary entries for a 'message' property.; If it exists, updates the message index of embedded links in the run index. Recursively looks through entries in the dictionary.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:33,Deployability,update,update,33,# iterate through subobjects and update it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:94,Deployability,update,updates,94,"""""""; Given a SARIF message object, checks if the text property contains an embedded link and; updates the run index if necessary.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:19,Integrability,message,message,19,"""""""; Given a SARIF message object, checks if the text property contains an embedded link and; updates the run index if necessary.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:41,Deployability,update,update,41,"# we only merge runs, so we only need to update the run index",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:2,Deployability,update,update,2,# update matches from right to left to make increasing character length (9->10) smoother,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:2,Security,expose,exposed,2,# exposed for testing since the order of files returned by glob is not guaranteed to be sorted,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:14,Testability,test,testing,14,# exposed for testing since the order of files returned by glob is not guaranteed to be sorted,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:8,Safety,safe,safe,8,"""""""Make safe this values to embed into HTML.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:8,Safety,safe,safe,8,"""""""Make safe this values to embed into HTML.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:46,Deployability,update,update,46,"""""""Run 'encode' on 'container[key]' value and update it.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:16,Safety,detect,detect,16,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:76,Safety,detect,detect,76,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:284,Safety,detect,detect,284,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:50,Security,hash,hash,50,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:158,Security,hash,hash,158,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:232,Security,hash,hash,232,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:40,Integrability,depend,depend,40,"""""""check_output returns bytes or string depend on python version""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:15,Testability,log,logging,15,"""""""Reconfigure logging level and format based on the verbose flag. :param verbose_level: number of `-v` flags received by the command; :return: no return value; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:2,Performance,Tune,Tune,2,# Tune logging level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:7,Testability,log,logging,7,# Tune logging level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:18,Integrability,message,messages,18,# Be verbose with messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:108,Availability,error,errors,108,"""""""Decorator for command entry methods. The decorator initialize/shutdown logging and guard on programming; errors (catch exceptions). The decorated method can have arbitrary parameters, the return value will; be the exit code of the process.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:74,Testability,log,logging,74,"""""""Decorator for command entry methods. The decorator initialize/shutdown logging and guard on programming; errors (catch exceptions). The decorated method can have arbitrary parameters, the return value will; be the exit code of the process.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:41,Integrability,wrap,wrapped,41,"""""""Do housekeeping tasks and execute the wrapped method.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:39,Availability,error,errors,39,# Some non used exit code for internal errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:23,Integrability,wrap,wrapper,23,"""""""Implements compiler wrapper base functionality. A compiler wrapper executes the real compiler, then implement some; functionality, then returns with the real compiler exit code. :param function: the extra functionality what the wrapper want to; do on top of the compiler call. If it throws exception, it will be; caught and logged.; :return: the exit code of the real compiler. The :param function: will receive the following arguments:. :param result: the exit code of the compilation.; :param execution: the command executed by the wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:62,Integrability,wrap,wrapper,62,"""""""Implements compiler wrapper base functionality. A compiler wrapper executes the real compiler, then implement some; functionality, then returns with the real compiler exit code. :param function: the extra functionality what the wrapper want to; do on top of the compiler call. If it throws exception, it will be; caught and logged.; :return: the exit code of the real compiler. The :param function: will receive the following arguments:. :param result: the exit code of the compilation.; :param execution: the command executed by the wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:231,Integrability,wrap,wrapper,231,"""""""Implements compiler wrapper base functionality. A compiler wrapper executes the real compiler, then implement some; functionality, then returns with the real compiler exit code. :param function: the extra functionality what the wrapper want to; do on top of the compiler call. If it throws exception, it will be; caught and logged.; :return: the exit code of the real compiler. The :param function: will receive the following arguments:. :param result: the exit code of the compilation.; :param execution: the command executed by the wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:537,Integrability,wrap,wrapper,537,"""""""Implements compiler wrapper base functionality. A compiler wrapper executes the real compiler, then implement some; functionality, then returns with the real compiler exit code. :param function: the extra functionality what the wrapper want to; do on top of the compiler call. If it throws exception, it will be; caught and logged.; :return: the exit code of the real compiler. The :param function: will receive the following arguments:. :param result: the exit code of the compilation.; :param execution: the command executed by the wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:327,Testability,log,logged,327,"""""""Implements compiler wrapper base functionality. A compiler wrapper executes the real compiler, then implement some; functionality, then returns with the real compiler exit code. :param function: the extra functionality what the wrapper want to; do on top of the compiler call. If it throws exception, it will be; caught and logged.; :return: the exit code of the real compiler. The :param function: will receive the following arguments:. :param result: the exit code of the compilation.; :param execution: the command executed by the wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:49,Integrability,wrap,wrapper,49,"""""""Find out was it a C++ compiler call. Compiler wrapper names; contain the compiler type. C++ compiler wrappers ends with `c++`,; but might have `.exe` extension on windows.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:104,Integrability,wrap,wrappers,104,"""""""Find out was it a C++ compiler call. Compiler wrapper names; contain the compiler type. C++ compiler wrappers ends with `c++`,; but might have `.exe` extension on windows.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:11,Integrability,wrap,wrapped,11,# Call the wrapped method and ignore it's return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:45,Integrability,wrap,wrapper,45,"""""""Set up environment for interpose compiler wrapper.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:125,Availability,Down,Download,125,"/*; SortTable; version 2; 7th April 2007; Stuart Langridge, http://www.kryogenix.org/code/browser/sorttable/. Instructions:; Download this file; Add <script src=""sorttable.js""></script> to your HTML; Add class=""sortable"" to any table you'd like to make sortable; Click on the headers to sort. Thanks to many, many people for contributions and suggestions.; Licenced as X11: http://www.kryogenix.org/code/browser/licence.html; This basically means: do what you want with it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:115,Integrability,depend,depending,115,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:109,Safety,avoid,avoid,109,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:12,Security,hash,hash,12,// create a hash table of event types for the element,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:12,Security,hash,hash,12,// create a hash table of event handlers for each element/event pair,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:34,Security,hash,hash,34,// store the event handler in the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:37,Security,hash,hash,37,// delete the event handler from the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js:26,Security,hash,hash,26,// get a reference to the hash table of event handlers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:125,Availability,Down,Download,125,"/*; SortTable; version 2; 7th April 2007; Stuart Langridge, http://www.kryogenix.org/code/browser/sorttable/. Instructions:; Download this file; Add <script src=""sorttable.js""></script> to your HTML; Add class=""sortable"" to any table you'd like to make sortable; Click on the headers to sort. Thanks to many, many people for contributions and suggestions.; Licenced as X11: http://www.kryogenix.org/code/browser/licence.html; This basically means: do what you want with it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:115,Integrability,depend,depending,115,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:109,Safety,avoid,avoid,109,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:12,Security,hash,hash,12,// create a hash table of event types for the element,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:12,Security,hash,hash,12,// create a hash table of event handlers for each element/event pair,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:34,Security,hash,hash,34,// store the event handler in the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:37,Security,hash,hash,37,// delete the event handler from the hash table,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js:26,Security,hash,hash,26,// get a reference to the hash table of event handlers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py:25,Availability,failure,failures,25,"""""""Generic exception for failures in bug reporting.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py:11,Integrability,interface,interfaces,11,# Reporter interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py:114,Usability,simpl,simple,114,"# Guess the content type based on the file's extension. Encoding; # will be ignored, although we should check for simple things like; # gzip'd or compressed files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py:13,Modifiability,config,config,13,# FIXME: Get config parameters,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/Reporter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:70,Performance,load,load,70,"""""""\; <script language=""javascript"" type=""text/javascript"">; function load(url) {; if (window.XMLHttpRequest) {; req = new XMLHttpRequest();; } else if (window.ActiveXObject) {; req = new ActiveXObject(""Microsoft.XMLHTTP"");; }; if (req != undefined) {; req.open(""GET"", url, true);; req.send("""");; }; }; </script>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:401,Usability,simpl,simple,401,"# Insert report crashes link.; # Disabled for the time being until we decide exactly when this should; # be enabled. Also the radar reporter needs to be fixed to report; # multiple files.; # kReportReplacements.append((re.compile('<!-- REPORTCRASHES -->'),; # '<br>These files will automatically be attached to ' +; # 'reports filed here: <a href=""report_crashes"">Report Crashes</a>.')); ###; # Other simple parameters",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:15,Availability,error,errors,15,# Ignore parse errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:9,Availability,error,errors,9,# Ignore errors (only called on exit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:16,Availability,error,errors,16,# Ignore socket errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:30,Usability,simpl,simplifications,30,"# Borrowed from Quixote, with simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:2,Deployability,Update,Update,2,# Update config defaults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:9,Modifiability,config,config,9,# Update config defaults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:719,Integrability,message,message,719,"""""""; <head>; <title>Bug Submission</title>; <link rel=""stylesheet"" type=""text/css"" href=""/scanview.css"" />; </head>; <body>; <h3>; <a href=""/"">Summary</a> > ; %(reportingFor)s; %(fileBug)s; Submit</h3>; <form name=""form"" action="""">; <table class=""form"">; <tr><td>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Title:</td>; <td class=""form_value"">; <input type=""text"" name=""title"" size=""50"" value=""%(title)s"" disabled>; </td>; </tr>; <tr>; <td class=""form_label"">Description:</td>; <td class=""form_value"">; <textarea rows=""10"" cols=""80"" name=""description"" disabled>; %(description)s; </textarea>; </td>; </table>; </td></tr>; </table>; </form>; <h1 class=""%(statusClass)s"">Submission %(statusName)s</h1>; %(message)s; <p>; <hr>; <a href=""/"">Return to Summary</a>; </body>; </html>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:218,Deployability,update,updateReporterOptions,218,"""""""<html>; <head>; <title>File Bug</title>; <link rel=""stylesheet"" type=""text/css"" href=""/scanview.css"" />; </head>; <script language=""javascript"" type=""text/javascript"">; var reporters = %(reportersArray)s;; function updateReporterOptions() {; index = document.getElementById('reporter').selectedIndex;; for (var i=0; i < reporters.length; ++i) {; o = document.getElementById(reporters[i] + ""ReporterOptions"");; if (i == index) {; o.style.display = """";; } else {; o.style.display = ""none"";; }; }; }; </script>; <body onLoad=""updateReporterOptions()"">; <h3>; <a href=""/"">Summary</a> > ; %(reportingFor)s; File Bug</h3>; <form name=""form"" action=""/report_submit"" method=""post"">; <input type=""hidden"" name=""report"" value=""%(report)s"">. <table class=""form"">; <tr><td>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Title:</td>; <td class=""form_value"">; <input type=""text"" name=""title"" size=""50"" value=""%(title)s"">; </td>; </tr>; <tr>; <td class=""form_label"">Description:</td>; <td class=""form_value"">; <textarea rows=""10"" cols=""80"" name=""description"">; %(description)s; </textarea>; </td>; </tr>. %(attachFileRow)s. </table>; <br>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Method:</td>; <td class=""form_value"">; <select id=""reporter"" name=""reporter"" onChange=""updateReporterOptions()"">; %(reporterSelections)s; </select>; </td>; </tr>; %(reporterOptionsDivs)s; </table>; <br>; </td></tr>; <tr><td class=""form_submit"">; <input align=""right"" type=""submit"" name=""Submit"" value=""Submit"">; </td></tr>; </table>; </form>. %(extraIFrame)s. </body>; </html>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:526,Deployability,update,updateReporterOptions,526,"""""""<html>; <head>; <title>File Bug</title>; <link rel=""stylesheet"" type=""text/css"" href=""/scanview.css"" />; </head>; <script language=""javascript"" type=""text/javascript"">; var reporters = %(reportersArray)s;; function updateReporterOptions() {; index = document.getElementById('reporter').selectedIndex;; for (var i=0; i < reporters.length; ++i) {; o = document.getElementById(reporters[i] + ""ReporterOptions"");; if (i == index) {; o.style.display = """";; } else {; o.style.display = ""none"";; }; }; }; </script>; <body onLoad=""updateReporterOptions()"">; <h3>; <a href=""/"">Summary</a> > ; %(reportingFor)s; File Bug</h3>; <form name=""form"" action=""/report_submit"" method=""post"">; <input type=""hidden"" name=""report"" value=""%(report)s"">. <table class=""form"">; <tr><td>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Title:</td>; <td class=""form_value"">; <input type=""text"" name=""title"" size=""50"" value=""%(title)s"">; </td>; </tr>; <tr>; <td class=""form_label"">Description:</td>; <td class=""form_value"">; <textarea rows=""10"" cols=""80"" name=""description"">; %(description)s; </textarea>; </td>; </tr>. %(attachFileRow)s. </table>; <br>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Method:</td>; <td class=""form_value"">; <select id=""reporter"" name=""reporter"" onChange=""updateReporterOptions()"">; %(reporterSelections)s; </select>; </td>; </tr>; %(reporterOptionsDivs)s; </table>; <br>; </td></tr>; <tr><td class=""form_submit"">; <input align=""right"" type=""submit"" name=""Submit"" value=""Submit"">; </td></tr>; </table>; </form>. %(extraIFrame)s. </body>; </html>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:1286,Deployability,update,updateReporterOptions,1286,"""""""<html>; <head>; <title>File Bug</title>; <link rel=""stylesheet"" type=""text/css"" href=""/scanview.css"" />; </head>; <script language=""javascript"" type=""text/javascript"">; var reporters = %(reportersArray)s;; function updateReporterOptions() {; index = document.getElementById('reporter').selectedIndex;; for (var i=0; i < reporters.length; ++i) {; o = document.getElementById(reporters[i] + ""ReporterOptions"");; if (i == index) {; o.style.display = """";; } else {; o.style.display = ""none"";; }; }; }; </script>; <body onLoad=""updateReporterOptions()"">; <h3>; <a href=""/"">Summary</a> > ; %(reportingFor)s; File Bug</h3>; <form name=""form"" action=""/report_submit"" method=""post"">; <input type=""hidden"" name=""report"" value=""%(report)s"">. <table class=""form"">; <tr><td>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Title:</td>; <td class=""form_value"">; <input type=""text"" name=""title"" size=""50"" value=""%(title)s"">; </td>; </tr>; <tr>; <td class=""form_label"">Description:</td>; <td class=""form_value"">; <textarea rows=""10"" cols=""80"" name=""description"">; %(description)s; </textarea>; </td>; </tr>. %(attachFileRow)s. </table>; <br>; <table class=""form_group"">; <tr>; <td class=""form_clabel"">Method:</td>; <td class=""form_value"">; <select id=""reporter"" name=""reporter"" onChange=""updateReporterOptions()"">; %(reporterSelections)s; </select>; </td>; </tr>; %(reporterOptionsDivs)s; </table>; <br>; </td></tr>; <tr><td class=""form_submit"">; <input align=""right"" type=""submit"" name=""Submit"" value=""Submit"">; </td></tr>; </table>; </form>. %(extraIFrame)s. </body>; </html>""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:2,Deployability,Patch,Patch,2,# Patch file instead,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:2,Deployability,Patch,Patch,2,"# Patch files to add links, but skip binary files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py:30,Modifiability,variab,variables,30,# Allow a very limited set of variables. This is pretty gross.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/ScanView.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/startfile.py:3,Availability,Error,Error,3,# [Error 22] No application is associated with the specified; # file for this operation: '<URL>',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/tools/scan-view/share/startfile.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-view/share/startfile.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/builtin-defines.c:301,Availability,echo,echo,301,"/* ; This is a clang style test case for checking that preprocessor; defines match gcc.; */; /*; RUN: for arch in -m32 -m64; do \; RUN: for lang in -std=gnu89 -ansi -std=c99 -std=gnu99; do \; RUN: for input in c objective-c; do \; RUN: for opts in ""-O0"" ""-O1 -dynamic"" ""-O2 -static"" ""-Os""; do \; RUN: echo ""-- $arch, $lang, $input, $opts --""; \; RUN: for cc in 0 1; do \; RUN: if [ ""$cc"" == 0 ]; then \; RUN: cc_prog=clang; \; RUN: output=%t0; \; RUN: else \; RUN: cc_prog=gcc; \; RUN: output=%t1; \; RUN: fi; \; RUN: $cc_prog $arch $lang $opts -march=core2 -dM -E -x $input %s | sort > $output; \; RUN: done; \; RUN: if (! diff %t0 %t1); then exit 1; fi; \; RUN: done; \; RUN: done; \; RUN: done; \; RUN: done;; */; /* We don't care about this difference */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/builtin-defines.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/builtin-defines.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/builtin-defines.c:27,Testability,test,test,27,"/* ; This is a clang style test case for checking that preprocessor; defines match gcc.; */; /*; RUN: for arch in -m32 -m64; do \; RUN: for lang in -std=gnu89 -ansi -std=c99 -std=gnu99; do \; RUN: for input in c objective-c; do \; RUN: for opts in ""-O0"" ""-O1 -dynamic"" ""-O2 -static"" ""-Os""; do \; RUN: echo ""-- $arch, $lang, $input, $opts --""; \; RUN: for cc in 0 1; do \; RUN: if [ ""$cc"" == 0 ]; then \; RUN: cc_prog=clang; \; RUN: output=%t0; \; RUN: else \; RUN: cc_prog=gcc; \; RUN: output=%t1; \; RUN: fi; \; RUN: $cc_prog $arch $lang $opts -march=core2 -dM -E -x $input %s | sort > $output; \; RUN: done; \; RUN: if (! diff %t0 %t1); then exit 1; fi; \; RUN: done; \; RUN: done; \; RUN: done; \; RUN: done;; */; /* We don't care about this difference */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/builtin-defines.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/builtin-defines.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py:9,Performance,CACHE,CACHE,9,"# print ""CACHE MISS""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ClangDataFormat.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py:9,Security,Hash,Hashing,9,"# FIXME: Hashing for SBTypes does not seem to work correctly, uses the typename instead,; # and not the canonical one unfortunately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ClangDataFormat.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ClangDataFormat.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:1680,Availability,avail,available,1680,""""""" Commands for managing clang diagnostic breakpoints. Syntax: clangdiag enable [<warning>|<diag-name>]; clangdiag disable; clangdiag diagtool [<path>|reset]. The following subcommands are supported:. enable -- Enable clang diagnostic breakpoints.; disable -- Disable all clang diagnostic breakpoints.; diagtool -- Return, set, or reset diagtool path. This command sets breakpoints in clang, and clang based tools, that; emit diagnostics. When a diagnostic is emitted, and clangdiag is; enabled, it will use the appropriate diagtool application to determine; the name of the DiagID, and set breakpoints in all locations that; 'diag::name' appears in the source. Since the new breakpoints are set; after they are encountered, users will need to launch the executable a; second time in order to hit the new breakpoints. For in-tree builds, the diagtool application, used to map DiagID's to; names, is found automatically in the same directory as the target; executable. However, out-or-tree builds must use the 'diagtool'; subcommand to set the appropriate path for diagtool in the clang debug; bin directory. Since this mapping is created at build-time, it's; important for users to use the same version that was generated when; clang was compiled, or else the id's won't match. Notes:; - Substrings can be passed for both <warning> and <diag-name>.; - If <warning> is passed, only enable the DiagID(s) for that warning.; - If <diag-name> is passed, only enable that DiagID.; - Rerunning enable clears existing breakpoints.; - diagtool is used in breakpoint callbacks, so it can be changed; without the need to rerun enable.; - Adding this to your ~.lldbinit file makes clangdiag available at startup:; ""command script import /path/to/clangdiag.py"". """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:1495,Usability,clear,clears,1495,""""""" Commands for managing clang diagnostic breakpoints. Syntax: clangdiag enable [<warning>|<diag-name>]; clangdiag disable; clangdiag diagtool [<path>|reset]. The following subcommands are supported:. enable -- Enable clang diagnostic breakpoints.; disable -- Disable all clang diagnostic breakpoints.; diagtool -- Return, set, or reset diagtool path. This command sets breakpoints in clang, and clang based tools, that; emit diagnostics. When a diagnostic is emitted, and clangdiag is; enabled, it will use the appropriate diagtool application to determine; the name of the DiagID, and set breakpoints in all locations that; 'diag::name' appears in the source. Since the new breakpoints are set; after they are encountered, users will need to launch the executable a; second time in order to hit the new breakpoints. For in-tree builds, the diagtool application, used to map DiagID's to; names, is found automatically in the same directory as the target; executable. However, out-or-tree builds must use the 'diagtool'; subcommand to set the appropriate path for diagtool in the clang debug; bin directory. Since this mapping is created at build-time, it's; important for users to use the same version that was generated when; clang was compiled, or else the id's won't match. Notes:; - Substrings can be passed for both <warning> and <diag-name>.; - If <warning> is passed, only enable the DiagID(s) for that warning.; - If <diag-name> is passed, only enable that DiagID.; - Rerunning enable clears existing breakpoints.; - diagtool is used in breakpoint callbacks, so it can be changed; without the need to rerun enable.; - Adding this to your ~.lldbinit file makes clangdiag available at startup:; ""command script import /path/to/clangdiag.py"". """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:16,Testability,test,test,16,"# Don't need to test this time, since we did that in enable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:29,Availability,error,errors,29,"# Make sure we only consider errors, warnings, and extensions.; # FIXME: Make this configurable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:83,Modifiability,config,configurable,83,"# Make sure we only consider errors, warnings, and extensions.; # FIXME: Make this configurable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:29,Availability,error,errors,29,"# Make sure we only consider errors, warnings, and extensions.; # FIXME: Make this configurable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py:83,Modifiability,config,configurable,83,"# Make sure we only consider errors, warnings, and extensions.; # FIXME: Make this configurable?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/clangdiag.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/clangdiag.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/convert_arm_neon.py:130,Deployability,release,release,130,"#!/usr/bin/env python3; # This script was committed on 20/11/2019 and it would probably make sense to remove; # it after the next release branches.; # This script is pipe based and converts an arm_neon.td (or arm_fp16.td) file; # using the old single-char type modifiers to an equivalent new-style form where; # each modifier is orthogonal and they can be composed.; #; # It was used to directly generate the .td files on main, so if you have any; # local additions I would suggest implementing any modifiers here, and running; # it over your entire pre-merge .td files rather than trying to resolve any; # conflicts manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/convert_arm_neon.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/convert_arm_neon.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:11,Energy Efficiency,Reduce,Reduce,11,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:85,Energy Efficiency,reduce,reduced,85,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:142,Energy Efficiency,reduce,reduced,142,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:161,Energy Efficiency,reduce,reduced,161,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:215,Energy Efficiency,Reduce,Reduce,215,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:177,Testability,test,test,177,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:204,Testability,test,test,204,"""""""Calls C-Reduce to create a minimal reproducer for clang crashes. Output files:; *.reduced.sh -- crash reproducer with minimal arguments; *.reduced.cpp -- the reduced file; *.test.sh -- interestingness test for C-Reduce; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:40,Testability,test,test,40,# Make the path absolute so the creduce test can be run from any directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:20,Availability,error,error,20,# Look for specific error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:26,Integrability,message,messages,26,# Look for specific error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:8,Testability,assert,assert,8,# Linux assert(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:14,Testability,assert,assert,14,# FreeBSD/Mac assert(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:8,Integrability,message,message,8,"# If no message was found, use the top five stack trace functions,; # ignoring some common functions; # Five is a somewhat arbitrary number; the goal is to get a small number; # of identifying functions with some leeway for common functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:48,Safety,avoid,avoid,48,# Disable symbolization if it's not required to avoid slow symbolization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:31,Testability,log,log,31,"""""""#!/bin/bash; %s; if %s >& t.log ; then; exit 1; fi; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:17,Testability,test,test,17,# Check that the test considers the original file interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:90,Testability,test,test,90,"# Check that an empty file is not interesting; # Instead of modifying the filename in the test file, just run the command",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:45,Energy Efficiency,Reduce,Reduce,45,"""""""Simplify clang arguments before running C-Reduce to reduce the time the; interestingness test takes to run.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:55,Energy Efficiency,reduce,reduce,55,"""""""Simplify clang arguments before running C-Reduce to reduce the time the; interestingness test takes to run.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:92,Testability,test,test,92,"""""""Simplify clang arguments before running C-Reduce to reduce the time the; interestingness test takes to run.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:3,Usability,Simpl,Simplify,3,"""""""Simplify clang arguments before running C-Reduce to reduce the time the; interestingness test takes to run.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:62,Testability,test,test,62,# Remove some clang arguments to speed up the interestingness test,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:30,Availability,error,error,30,# Try to make implicit int an error for more sensible test output,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:54,Testability,test,test,54,# Try to make implicit int an error for more sensible test output,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:48,Energy Efficiency,Reduce,Reduce,48,"""""""Minimize the clang arguments after running C-Reduce, to get the smallest; command that reproduces the crash on the reduced file.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:118,Energy Efficiency,reduce,reduced,118,"""""""Minimize the clang arguments after running C-Reduce, to get the smallest; command that reproduces the crash on the reduced file.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:17,Energy Efficiency,Reduce,Reduce,17,# Hack to kill C-Reduce because it jumps into its own pgid,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py:39,Deployability,Update,Update,39,#!/usr/bin/env python; # To use:; # 1) Update the 'decls' list below with your fuzzing configuration.; # 2) Run with the clang binary as the command-line argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/modfuzz.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py:87,Deployability,configurat,configuration,87,#!/usr/bin/env python; # To use:; # 1) Update the 'decls' list below with your fuzzing configuration.; # 2) Run with the clang binary as the command-line argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/modfuzz.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py:87,Modifiability,config,configuration,87,#!/usr/bin/env python; # To use:; # 1) Update the 'decls' list below with your fuzzing configuration.; # 2) Run with the clang binary as the command-line argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/modfuzz.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/modfuzz.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:73,Energy Efficiency,reduce,reduce,73,# There is no reason to cache successful tests because we will; # always reduce the changeset when we see one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:24,Performance,cache,cache,24,# There is no reason to cache successful tests because we will; # always reduce the changeset when we see one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:41,Testability,test,tests,41,# There is no reason to cache successful tests because we will; # always reduce the changeset when we see one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:168,Safety,Avoid,Avoid,168,"# Make sure the initial test passes, if not then (a) either; # the user doesn't expect monotonicity, and we may end up; # doing O(N^2) tests, or (b) the test is wrong. Avoid the; # O(N^2) case unless user requests it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:24,Testability,test,test,24,"# Make sure the initial test passes, if not then (a) either; # the user doesn't expect monotonicity, and we may end up; # doing O(N^2) tests, or (b) the test is wrong. Avoid the; # O(N^2) case unless user requests it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:135,Testability,test,tests,135,"# Make sure the initial test passes, if not then (a) either; # the user doesn't expect monotonicity, and we may end up; # doing O(N^2) tests, or (b) the test is wrong. Avoid the; # O(N^2) case unless user requests it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:153,Testability,test,test,153,"# Make sure the initial test passes, if not then (a) either; # the user doesn't expect monotonicity, and we may end up; # doing O(N^2) tests, or (b) the test is wrong. Avoid the; # O(N^2) case unless user requests it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:45,Testability,test,test,45,# Check empty set first to quickly find poor test functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:9,Energy Efficiency,reduce,reduce,9,"# assert(reduce(set.union, sets, set()) == c); # If there is nothing left we can remove, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:2,Testability,assert,assert,2,"# assert(reduce(set.union, sets, set()) == c); # If there is nothing left we can remove, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:5,Testability,test,test,5,"# If test passes on this subset alone, recurse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:50,Testability,test,test,50,"# Otherwise if we have more than two sets, see if test; # pases without this subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:39,Usability,simpl,simple,39,# Silly programmers refuse to print in simple machine readable; # formats. Whatever.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:26,Performance,cache,cache,26,# Avoid freeing our giant cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:2,Safety,Avoid,Avoid,2,# Avoid freeing our giant cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/token-delta.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:236,Availability,down,downstream,236,"""""""Update Options.td for the flags changes in https://reviews.llvm.org/Dxyz. This script translates Options.td from using Flags to control option visibility; to using Vis instead. It is meant to be idempotent and usable to help update; downstream forks if they have their own changes to Options.td. Usage:; ```sh; % update_options_td_flags.py path/to/Options.td > Options.td.new; % mv Options.td.new path/to/Options.td; ```. This script will be removed after the next LLVM release.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:3,Deployability,Update,Update,3,"""""""Update Options.td for the flags changes in https://reviews.llvm.org/Dxyz. This script translates Options.td from using Flags to control option visibility; to using Vis instead. It is meant to be idempotent and usable to help update; downstream forks if they have their own changes to Options.td. Usage:; ```sh; % update_options_td_flags.py path/to/Options.td > Options.td.new; % mv Options.td.new path/to/Options.td; ```. This script will be removed after the next LLVM release.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:228,Deployability,update,update,228,"""""""Update Options.td for the flags changes in https://reviews.llvm.org/Dxyz. This script translates Options.td from using Flags to control option visibility; to using Vis instead. It is meant to be idempotent and usable to help update; downstream forks if they have their own changes to Options.td. Usage:; ```sh; % update_options_td_flags.py path/to/Options.td > Options.td.new; % mv Options.td.new path/to/Options.td; ```. This script will be removed after the next LLVM release.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:473,Deployability,release,release,473,"""""""Update Options.td for the flags changes in https://reviews.llvm.org/Dxyz. This script translates Options.td from using Flags to control option visibility; to using Vis instead. It is meant to be idempotent and usable to help update; downstream forks if they have their own changes to Options.td. Usage:; ```sh; % update_options_td_flags.py path/to/Options.td > Options.td.new; % mv Options.td.new path/to/Options.td; ```. This script will be removed after the next LLVM release.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:213,Usability,usab,usable,213,"""""""Update Options.td for the flags changes in https://reviews.llvm.org/Dxyz. This script translates Options.td from using Flags to control option visibility; to using Vis instead. It is meant to be idempotent and usable to help update; downstream forks if they have their own changes to Options.td. Usage:; ```sh; % update_options_td_flags.py path/to/Options.td > Options.td.new; % mv Options.td.new path/to/Options.td; ```. This script will be removed after the next LLVM release.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:8,Integrability,wrap,wrapping,8,"# Avoid wrapping the , or ; to the new line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:2,Safety,Avoid,Avoid,2,"# Avoid wrapping the , or ; to the new line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/update_options_td_flags.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:40,Security,access,access,40,# FIXME: Use designated initializers to access non-first; # fields of unions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:45,Modifiability,portab,portably,45,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:2,Security,Access,Access,2,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:57,Security,access,access,57,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:45,Modifiability,portab,portably,45,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:2,Security,Access,Access,2,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:57,Security,access,access,57,# Access in this fashion as a hackish way to portably; # access vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:24,Safety,avoid,avoid,24,"# Fully recursive, just avoid top-level arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:30,Usability,Simpl,Simplifies,30,###; # Countable iteration; # Simplifies some calculations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:2,Safety,Avoid,Avoid,2,# Avoid various singularities,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:2,Testability,assert,assert,2,# assert base(lo) <= N < base(hi),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:2,Usability,Simpl,Simple,2,# Simple case...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:12,Usability,simpl,simplify,12,# Otherwise simplify by assuming W < H,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:63,Integrability,wrap,wrap,63,"# Otherwise, compile line and index from number of times we; # wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:7,Deployability,Toggle,Toggle,7,###; # Toggle to use checked versions of enumeration routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:53,Integrability,rout,routines,53,###; # Toggle to use checked versions of enumeration routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py:3,Modifiability,Flexible,Flexible,3,"""""""Flexible enumeration of C types.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/TypeGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py:34,Modifiability,flexible,flexible,34,"# TODO:; # - struct improvements (flexible arrays, packed &; # unpacked, alignment); # - objective-c qualified id; # - anonymous / transparent unions; # - VLAs; # - block types; # - K&R functions; # - pass arguments of different types (test extension, transparent union); # - varargs; ###; # Actual type types",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/TypeGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py:236,Testability,test,test,236,"# TODO:; # - struct improvements (flexible arrays, packed &; # unpacked, alignment); # - objective-c qualified id; # - anonymous / transparent unions; # - VLAs; # - block types; # - K&R functions; # - pass arguments of different types (test extension, transparent union); # - varargs; ###; # Actual type types",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/ABITest/TypeGen.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/TypeGen.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:368,Deployability,integrat,integrate,368,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:238,Energy Efficiency,monitor,monitor,238,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:368,Integrability,integrat,integrate,368,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:455,Performance,Load,Load,455,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:172,Testability,test,testing,172,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:323,Testability,test,testing,323,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:402,Testability,test,testing,402,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:17,Usability,simpl,simple,17,"""""""; CmpRuns - A simple tool for comparing two static analyzer runs to determine; which reports have been added, removed, or changed. This is designed to support automated testing using the static analyzer, from; two perspectives:; 1. To monitor changes in the static analyzer's reports on real code bases,; for regression testing. 2. For use by end users who want to integrate regular static analyzer testing; into a buildbot like environment. Usage:. # Load the results of both runs, to obtain lists of the corresponding; # AnalysisDiagnostic objects.; #; resultsA = load_results_from_single_run(singleRunInfoA, delete_empty); resultsB = load_results_from_single_run(singleRunInfoB, delete_empty). # Generate a relation from diagnostics in run A to diagnostics in run B; # to obtain a list of triples (a, b, confidence).; diff = compare_results(resultsA, resultsB). """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:175,Energy Efficiency,efficient,efficient,175,# We want to retrieve the clang version even if there are no; # reports. Assume that all reports were created using the same; # clang version (this is always true and is more efficient).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:58,Testability,assert,assertion,58,"# Python 3.10 offers zip(..., strict=True). The following assertion; # mimics it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:7,Performance,Load,Load,7,"""""""; # Load results of the analyzes from a given output folder.; # - info is the SingleRunInfo object; # - delete_empty specifies if the empty plist files should be deleted. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:293,Integrability,depend,depend,293,"# FIXME: Add fuzzy matching. One simple and possible effective idea would; # be to bin the diagnostics, print them in a normalized form (based solely; # on the structure of the diagnostic), compute the diff, then use that as; # the basis for matching. This has the nice property that we don't depend; # in any way on the diagnostic format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:33,Usability,simpl,simple,33,"# FIXME: Add fuzzy matching. One simple and possible effective idea would; # be to bin the diagnostics, print them in a normalized form (based solely; # on the structure of the diagnostic), compute the diff, then use that as; # the basis for matching. This has the nice property that we don't depend; # in any way on the diagnostic format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:386,Testability,log,log,386,"""""""; Compare directories with analysis results and dump results. :param delete_empty: delete empty plist files; :param out: buffer to dump comparison results to.; :param show_stats: compare execution stats as well.; :param stats_only: compare ONLY execution stats.; :param histogram: optional histogram type to plot path differences.; :param verbose_log: optional path to an additional log file.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py:19,Testability,log,log,19,"# Open the verbose log, if given.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/CmpRuns.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:48,Modifiability,rewrite,rewriter,48,"#!/usr/bin/env python; #; # ===- exploded-graph-rewriter.py - ExplodedGraph dump tool -----*- python -*--#; #; # Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; # See https://llvm.org/LICENSE.txt for license information.; # SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; #; # ===-----------------------------------------------------------------------===#",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:15,Integrability,message,messages,15,# Deserialized messages from a single checker in a single program state.; # Basically a list of raw strings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:15,Integrability,message,messages,15,"# Deserialized messages of all checkers, separated by checker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:106,Testability,test,tests,106,"# Allow line breaks by waiting for ';'. This is not valid in; # a .dot file, but it is useful for writing tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:21,Testability,test,tests,21,"# Note: when writing tests you don't need to escape everything,; # even though in a valid dot file everything is escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:7,Safety,avoid,avoids,7,# This avoids pretty-printing huge statements such as CompoundStmt.; # Such statements show up only at [Pre|Post]StmtPurgeDeadSymbols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:43,Deployability,install,installed,43,# The fallback behavior if graphviz is not installed!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py:2,Security,validat,validate,2,# validate that given projects are present in the project map file,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATest.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py:2,Deployability,update,update,2,# update subcommand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATest.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py:2,Testability,benchmark,benchmark,2,# benchmark subcommand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATest.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATest.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:689,Availability,down,download,689,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:758,Availability,down,download,758,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1395,Availability,down,download,1395,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1414,Availability,down,download,1414,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1205,Deployability,patch,patch,1205,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1225,Deployability,patch,patch,1225,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1379,Deployability,patch,patch,1379,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1512,Deployability,Patch,PatchedSource,1512,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1619,Deployability,Patch,PatchedSource,1619,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1659,Deployability,patch,patch,1659,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1270,Energy Efficiency,adapt,adapt,1270,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:636,Modifiability,config,configure,636,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1270,Modifiability,adapt,adapt,1270,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:719,Performance,Cache,CachedSource,719,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:859,Performance,Cache,CachedSource,859,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:907,Performance,Cache,CachedSource,907,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:978,Performance,Cache,CachedSource,978,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1036,Performance,Cache,CachedSource,1036,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1330,Performance,Cache,CachedSource,1330,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1439,Performance,Cache,CachedSource,1439,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1463,Performance,Cache,CachedSource,1463,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:1606,Performance,Cache,CachedSource,1606,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:124,Testability,test,testing,124,"""""""; Static Analyzer qualification infrastructure: adding a new project to; the Repository Directory. Add a new project for testing: build it and add to the Project Map file.; Assumes it's being run from the Repository Directory.; The project directory should be added inside the Repository Directory and; have the same name as the project ID. The project should use the following files for set up:; - cleanup_run_static_analyzer.sh - prepare the build environment.; Ex: make clean can be a part of it.; - run_static_analyzer.cmd - a list of commands to run through scan-build.; Each command should be on a separate line.; Choose from: configure, make, xcodebuild; - download_project.sh - download the project into the CachedSource/; directory. For example, download a zip of; the project source from GitHub, unzip it,; and rename the unzipped directory to; 'CachedSource'. This script is not called; when 'CachedSource' is already present,; so an alternative is to check the; 'CachedSource' directory into the; repository directly.; - CachedSource/ - An optional directory containing the source of the; project being analyzed. If present,; download_project.sh will not be called.; - changes_for_analyzer.patch - An optional patch file for any local; changes; (e.g., to adapt to newer version of clang); that should be applied to CachedSource; before analysis. To construct this patch,; run the download script to download; the project to CachedSource, copy the; CachedSource to another directory (for; example, PatchedSource) and make any; needed modifications to the copied; source.; Then run:; diff -ur CachedSource PatchedSource \; > changes_for_analyzer.patch; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py:27,Testability,test,testing,27,"""""""; Add a new project for testing: build it and add to the Project Map file.; :param name: is a short string used to identify a project.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestAdd.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:401,Integrability,rout,routine,401,"""""""; Static Analyzer qualification infrastructure. This source file contains all the functionality related to benchmarking; the analyzer on a set projects. Right now, this includes measuring; execution time and peak memory usage. Benchmark runs analysis on every; project multiple times to get a better picture about the distribution; of measured values. Additionally, this file includes a comparison routine for two benchmarking; results that plots the result together on one chart.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:110,Testability,benchmark,benchmarking,110,"""""""; Static Analyzer qualification infrastructure. This source file contains all the functionality related to benchmarking; the analyzer on a set projects. Right now, this includes measuring; execution time and peak memory usage. Benchmark runs analysis on every; project multiple times to get a better picture about the distribution; of measured values. Additionally, this file includes a comparison routine for two benchmarking; results that plots the result together on one chart.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:230,Testability,Benchmark,Benchmark,230,"""""""; Static Analyzer qualification infrastructure. This source file contains all the functionality related to benchmarking; the analyzer on a set projects. Right now, this includes measuring; execution time and peak memory usage. Benchmark runs analysis on every; project multiple times to get a better picture about the distribution; of measured values. Additionally, this file includes a comparison routine for two benchmarking; results that plots the result together on one chart.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:417,Testability,benchmark,benchmarking,417,"""""""; Static Analyzer qualification infrastructure. This source file contains all the functionality related to benchmarking; the analyzer on a set projects. Right now, this includes measuring; execution time and peak memory usage. Benchmark runs analysis on every; project multiple times to get a better picture about the distribution; of measured values. Additionally, this file includes a comparison routine for two benchmarking; results that plots the result together on one chart.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:17,Testability,benchmark,benchmarking,17,"""""""; Compare two benchmarking results stored as .csv files; and produce a plot in the specified file.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py:65,Testability,test,tests,65,# TODO: compare data in old and new dataframes using statistical tests; # to check if they belong to the same distribution,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBenchmark.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:123,Availability,failure,failures,123,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:753,Availability,error,error,753,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:783,Availability,error,errors,783,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:853,Availability,failure,failure,853,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1195,Deployability,Release,Release,1195,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1252,Modifiability,variab,variables,1252,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1408,Modifiability,variab,variable,1408,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1496,Modifiability,variab,variable,1496,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:162,Performance,perform,performance,162,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:373,Performance,Perform,Performance,373,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:66,Testability,test,test,66,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:525,Testability,test,test,525,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:768,Testability,log,logs,768,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:972,Testability,log,log,972,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1203,Testability,Assert,Asserts,1203,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1231,Testability,log,logging,1231,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1371,Testability,test,tested,1371,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:1423,Testability,test,testing,1423,"""""""; Static Analyzer qualification infrastructure. The goal is to test the analyzer against different projects,; check for failures, compare results, and measure performance. Repository Directory will contain sources of the projects as well as the; information on how to build them and the expected output.; Repository Directory structure:; - ProjectMap file; - Historical Performance Data; - Project Dir1; - ReferenceOutput; - Project Dir2; - ReferenceOutput; ..; Note that the build tree must be inside the project dir. To test the build of the analyzer one would:; - Copy over a copy of the Repository Directory. (TODO: Prefer to ensure that; the build directory does not pollute the repository to min network; traffic).; - Build all projects, until error. Produce logs to report errors.; - Compare results. The files which should be kept around for failure investigations:; RepositoryCopy/Project DirI/ScanBuildResults; RepositoryCopy/Project DirI/run_static_analyzer.log. Assumptions (TODO: shouldn't need to assume these.):; The script is being run from the Repository Directory.; The compiler for scan-build and scan-build are in the PATH.; export PATH=/Users/zaks/workspace/c2llvm/build/Release+Asserts/bin:$PATH. For more logging, set the env variables:; zaks:TI zaks$ export CCC_ANALYZER_LOG=1; zaks:TI zaks$ export CCC_ANALYZER_VERBOSE=1. The list of checkers tested are hardcoded in the Checkers variable.; For testing additional checkers, use the SA_ADDITIONAL_CHECKERS environment; variable. It should contain a comma separated list.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:37,Integrability,message,messages,37,# TODO: use debug levels for VERBOSE messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:83,Deployability,Configurat,Configuration,83,###############################################################################; # Configuration setup.; ###############################################################################; # Find Clang for static analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:83,Modifiability,Config,Configuration,83,###############################################################################; # Configuration setup.; ###############################################################################; # Find Clang for static analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:60,Availability,down,downloads,60,# Names of the project specific scripts.; # The script that downloads the project.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:45,Integrability,wrap,wrapping,45,# A comment in a build script which disables wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:6,Testability,log,log,6,# The log file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:45,Availability,failure,failures,45,# Summary file - contains the summary of the failures. Ex: This info can be be; # displayed when buildbot detects a build failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:122,Availability,failure,failure,122,# Summary file - contains the summary of the failures. Ex: This info can be be; # displayed when buildbot detects a build failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:106,Safety,detect,detects,106,# Summary file - contains the summary of the failures. Ex: This info can be be; # displayed when buildbot detects a build failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:104,Availability,down,download,104,"# The name of the directory storing the cached project source. If this; # directory does not exist, the download script will be executed.; # That script should create the ""CachedSource"" directory and download the; # project source into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:200,Availability,down,download,200,"# The name of the directory storing the cached project source. If this; # directory does not exist, the download script will be executed.; # That script should create the ""CachedSource"" directory and download the; # project source into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:40,Performance,cache,cached,40,"# The name of the directory storing the cached project source. If this; # directory does not exist, the download script will be executed.; # That script should create the ""CachedSource"" directory and download the; # project source into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:172,Performance,Cache,CachedSource,172,"# The name of the directory storing the cached project source. If this; # directory does not exist, the download script will be executed.; # That script should create the ""CachedSource"" directory and download the; # project source into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:182,Deployability,Patch,PatchedSource,182,"# The name of the directory containing the source code that will be analyzed.; # Each time a project is analyzed, a fresh copy of its CachedSource directory; # will be copied to the PatchedSource directory and then the local patches; # in PATCHFILE_NAME will be applied (if PATCHFILE_NAME exists).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:225,Deployability,patch,patches,225,"# The name of the directory containing the source code that will be analyzed.; # Each time a project is analyzed, a fresh copy of its CachedSource directory; # will be copied to the PatchedSource directory and then the local patches; # in PATCHFILE_NAME will be applied (if PATCHFILE_NAME exists).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:134,Performance,Cache,CachedSource,134,"# The name of the directory containing the source code that will be analyzed.; # Each time a project is analyzed, a fresh copy of its CachedSource directory; # will be copied to the PatchedSource directory and then the local patches; # in PATCHFILE_NAME will be applied (if PATCHFILE_NAME exists).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:18,Deployability,patch,patchfile,18,# The name of the patchfile specifying any changes that should be applied; # to the CachedSource before analyzing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:84,Performance,Cache,CachedSource,84,# The name of the patchfile specifying any changes that should be applied; # to the CachedSource before analyzing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:83,Testability,Test,Test,83,###############################################################################; # Test harness logic.; ###############################################################################,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:96,Testability,log,logic,96,###############################################################################; # Test harness logic.; ###############################################################################,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:50,Performance,Queue,Queue,50,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:133,Performance,queue,queue,133,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:112,Safety,safe,safe,112,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:75,Testability,stub,stub,75,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:340,Testability,stub,stubs-but-not-at-runtime,340,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:48,Testability,test,testing,48,"""""""; A component aggregating all of the project testing.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:2,Testability,Test,Test,2,# Test the projects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:41,Testability,test,tests,41,"""""""; Run all projects.; :return: whether tests have passed.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:71,Testability,test,testing,71,"""""""; Run each project in a separate thread. This is OK despite GIL, as testing is blocked; on launching external processes. :return: whether tests have passed.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:141,Testability,test,tests,141,"""""""; Run each project in a separate thread. This is OK despite GIL, as testing is blocked; on launching external processes. :return: whether tests have passed.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:29,Testability,test,testing,29,"""""""; A component aggregating testing for one project.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:5,Testability,Test,Test,5,"""""""; Test a given project.; :return tests_passed: Whether tests have passed according; to the :param strictness: criteria.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:58,Testability,test,tests,58,"""""""; Test a given project.; :return tests_passed: Whether tests have passed according; to the :param strictness: criteria.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:33,Deployability,patch,patched,33,# Run scan-build from within the patched source directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:105,Modifiability,variab,variables,105,# Custom analyzer invocation specified by project.; # Communicate required information using environment variables; # instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:37,Testability,log,log,37,"# If command did not fail, erase the log file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:5,Availability,Down,Download,5,"""""""; Download the project and apply the local patchfile if it exists.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:46,Deployability,patch,patchfile,46,"""""""; Download the project and apply the local patchfile if it exists.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:71,Availability,down,download,71,"# If the we don't already have the cached source, run the project's; # download script to download it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:90,Availability,down,download,90,"# If the we don't already have the cached source, run the project's; # download script to download it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:35,Performance,cache,cached,35,"# If the we don't already have the cached source, run the project's; # download script to download it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:27,Deployability,patch,patched,27,# Remove potentially stale patched source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:39,Deployability,patch,patches,39,# Copy the cached source and apply any patches to the copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:11,Performance,cache,cached,11,# Copy the cached source and apply any patches to the copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:23,Availability,down,download,23,"""""""; Run the script to download the project, if it exists.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:130,Availability,failure,failure,130,"""""""; :param results_differ: Used to signify that results differ from; the canonical ones.; :param failure_flag: Used to signify a failure during the run.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:94,Availability,failure,failures,94,"""""""; Given the scan-build output directory, checks if the build failed; (by searching for the failures directories). If there are failures, it; creates a summary file in the output directory. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:130,Availability,failure,failures,130,"""""""; Given the scan-build output directory, checks if the build failed; (by searching for the failures directories). If there are failures, it; creates a summary file in the output directory. """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:21,Availability,failure,failures,21,# Check if there are failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:102,Testability,benchmark,benchmark,102,"""""""; Delete html, css, and js files from reference results. These can; include multiple copies of the benchmark source and so get very large.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:13,Testability,log,log,13,# Remove the log file. It leaks absolute path names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:154,Availability,failure,failure,154,"""""""; Compare the warnings produced by scan-build.; strictness defines the success criteria for the test:; 0 - success if there are no crashes or analyzer failure.; 1 - success if there are no difference in the number of reported bugs.; 2 - success if all the bug reports are identical. :return success: Whether tests pass according to the strictness; criteria.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:99,Testability,test,test,99,"""""""; Compare the warnings produced by scan-build.; strictness defines the success criteria for the test:; 0 - success if there are no crashes or analyzer failure.; 1 - success if there are no difference in the number of reported bugs.; 2 - success if all the bug reports are identical. :return success: Whether tests pass according to the strictness; criteria.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:311,Testability,test,tests,311,"""""""; Compare the warnings produced by scan-build.; strictness defines the success criteria for the test:; 0 - success if there are no crashes or analyzer failure.; 1 - success if there are no difference in the number of reported bugs.; 2 - success if all the bug reports are identical. :return success: Whether tests pass according to the strictness; criteria.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:26,Availability,down,down,26,# We have to go one level down the directory tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:2,Testability,Log,Log,2,"# Log folders are also located in the results dir, so ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:99,Modifiability,config,configure,99,# There might be more then one folder underneath - one per each scan-build; # command (Ex: one for configure and one for make).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:15,Testability,log,log,15,# Clean up the log file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUpdateDiffs.py:5,Deployability,Update,Update,5,"""""""; Update reference results for static analyzer.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestUpdateDiffs.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUpdateDiffs.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py:101,Modifiability,variab,variable,101,"""""""which(command, [paths]) - Look up the given command in the paths string; (or the PATH environment variable, if unspecified).""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py:15,Deployability,install,installed,15,"# no formatter installed, let's keep it in bytes",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py:106,Energy Efficiency,consumption,consumption,106,"""""""; Run command with arguments. Wait for command to complete and measure; execution time and peak memory consumption.; If the exit code was zero then return, otherwise raise; CalledProcessError. The CalledProcessError object will have the; return code in the returncode attribute. The arguments are the same as for the call and check_call functions. Return a tuple of execution time and peak memory.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py:49,Deployability,install,installed,49,# back off to subprocess if we don't have psutil installed,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestUtils.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:66,Integrability,wrap,wrapper,66,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:643,Integrability,wrap,wrapper,643,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:725,Integrability,wrap,wrapper,725,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:886,Integrability,wrap,wrapper,886,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1251,Integrability,wrap,wrapper,1251,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1432,Integrability,Wrap,WrapperCheck,1432,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1497,Performance,perform,perform,1497,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1014,Safety,detect,detected,1014,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:78,Testability,test,testing,78,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:318,Testability,test,test,318,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:812,Testability,test,test,812,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:988,Testability,test,test,988,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:20,Modifiability,variab,variable,20,"""""""Returns the PATH variable modified to remove the path to this program.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:2,Testability,Test,Test,2,# Test if it is a source file,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:20,Integrability,depend,dependency,20,# Options to output dependency files for make,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:43,Availability,failure,failure,43,"""""""Runs a step of the compilation. Reports failure as exception.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:20,Performance,perform,perform,20,"""""""Override this to perform the modified compilation and required; checks.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:9,Deployability,configurat,configuration,9,# Create configuration defaults from list of checks,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:9,Modifiability,config,configuration,9,# Create configuration defaults from list of checks,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:25,Integrability,Wrap,WrapperCheck,25,# Find all subclasses of WrapperCheck,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:79,Availability,error,error,79,# Bail out here if we can't apply checks in this case.; # Does not indicate an error.; # Maybe not straight compilation (e.g. -S or --version or -flto); # or maybe > 1 input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:37,Modifiability,config,config,37,"# Run checks, if they are enabled in config and if they are appropriate for; # this command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:8,Availability,failure,failure,8,# Check failure,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:15,Availability,failure,failure,15,# Compile step failure,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:3,Testability,Test,Test,3,"""""""Test internal functions within check_cfc.py.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test removing last thing in path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test removing one entry and leaving others; # Also tests removing repeated path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:53,Testability,test,tests,53,# Test removing one entry and leaving others; # Also tests removing repeated path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test removing non-canonical path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test getting implicit output file,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:13,Integrability,depend,dependency,13,# Outputting dependency files is not a normal compile,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:13,Integrability,depend,dependency,13,# Creating a dependency file as a side effect still outputs an object file,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test output not specified,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test output is specified,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test identifying input file with quotes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py:2,Testability,Test,Test,2,# Test multiple quotes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/test_check_cfc.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py:11,Testability,log,logging,11,# Open the logging file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py:10,Integrability,message,messages,10,# Receive messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/CIndex/completion_logger_server.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:2,Usability,clear,clear,2,"# clear the profile file env, so that we don't generate profdata; # when capturing the cc1 command",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:104,Testability,log,logging,104,"# Extract the list of symbols from the given file, which is assumed to be; # the output of a dtrace run logging either probefunc or ustack(1) and; # nothing else. The dtrace -xdemangle option needs to be used.; #; # This is particular to OS X at the moment, because of the '_' handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:178,Deployability,patch,patched,178,"# If there is a '`' in the line, assume it is a ustack(1) entry in; # the form of <modulename>`<modulefunc>, where <modulefunc> is never; # truncated (but does need the mangling patched).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:111,Modifiability,extend,extend,111,"# Otherwise, we have a symbol name which isn't present in the; # binary. We assume it is truncated, and try to extend it.; # Get all the symbols with this prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:2,Usability,Simpl,Simply,2,"# Simply strategy, just return symbols in order of occurrence, even across; # multiple runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:86,Testability,test,test,86,"# More complicated strategy that tries to respect the call order across all; # of the test cases, instead of giving a huge preference to the first test; # case.; # First, uniq all the lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:147,Testability,test,test,147,"# More complicated strategy that tries to respect the call order across all; # of the test cases, instead of giving a huge preference to the first test; # case.; # First, uniq all the lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py:2,Performance,Load,Load,2,# Load all of the input files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/perf-training/perf-helper.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/perf-helper.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.cpp:203,Usability,simpl,simply,203,"// Decl node names don't end in Decl for historical reasons, and it would; // be somewhat annoying to fix now. Conveniently, this means the ID matches; // is exactly the node name, and the class name is simply that plus Decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h:18,Modifiability,inherit,inherit,18,/// Does the node inherit from the given TableGen class?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h:116,Modifiability,inherit,inherited,116,/// Return a set of properties that are unnecessary when serializing; /// this AST node. Generally this is used for inherited properties; /// that are derived for this subclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ASTTableGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTNodesEmitter.cpp:3,Deployability,Update,Update,3,// Update the range of Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:91,Performance,cache,cache,91,"/// The name of the node hierarchy. Not actually sensitive to IsReader,; /// but useful to cache here anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:99,Availability,error,error,99,"// The existing property is more likely to be associated with a; // derived node, so use it as the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:9,Availability,down,down,9,"// Focus down to the property:; // T prop = <READ>;; // W.find(""prop"").write##ValueType(prop);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:85,Modifiability,variab,variable,85,// Write the property. Note that this will implicitly read the; // kind into a local variable with the right name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:44,Modifiability,variab,variable,44,// Prepare a ReaderWriterInfo with a helper variable that will use; // the sub-reader/writer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:44,Integrability,interface,interface,44,"// Work around MinGW's macro definition of 'interface' to 'struct'. We; // have an attribute argument called 'Interface', so only the lower case; // name conflicts with the macro definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:110,Integrability,Interface,Interface,110,"// Work around MinGW's macro definition of 'interface' to 'struct'. We; // have an attribute argument called 'Interface', so only the lower case; // name conflicts with the macro definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:24,Availability,error,error,24,// FIXME: Emit a proper error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:24,Availability,error,error,24,// FIXME: Emit a proper error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:6,Safety,avoid,avoid,6,"// To avoid printing parentheses around an empty argument list or; // printing spurious commas at the end of an argument list, we need to; // determine where the last provided non-fake argument is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:85,Safety,detect,detect,85,"// FIXME: arg->getIsOmitted() == ""false"" means we haven't implemented; // any way to detect whether the argument was omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:163,Safety,avoid,avoid,163,"// The enumerants are automatically generated based on the variety,; // namespace (if present) and name for each attribute spelling. However,; // care is taken to avoid trampling on the reserved namespace due to; // underscores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:47,Safety,avoid,avoid,47,"// Since we have been stripping underscores to avoid trampling on the; // reserved namespace, we may have inadvertently created duplicate; // enumerant names. These duplicates are not considered part of the; // semantic spelling, and can be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:90,Testability,test,test,90,"// FIXME: #pragma clang attribute does not currently support statement; // attributes, so test whether the subject is one that appertains to a; // declaration node. However, it may be reasonable for support for statement; // attributes to be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:12,Integrability,rout,routines,12,// Generate routines that check the names of sub-rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:310,Availability,error,error,310,"// FIXME: Currently, documentation is generated as-needed due to the fact; // that there is no way to allow a generated project ""reach into"" the docs; // directory (for instance, it may be an out-of-tree build). However, we want; // to ensure that every attribute has a Documentation field, and produce an; // error if it has been neglected. Otherwise, the on-demand generation which; // happens server-side will fail. This code is ensuring that functionality,; // even though this Emitter doesn't technically need the documentation.; // When attribute documentation can be generated as part of the build; // itself, this code can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:37,Integrability,depend,dependent,37,"// When trying to determine if value-dependent expressions can populate; // the attribute without prior instantiation, the decision is made based; // on the assumption that only the last argument is ever variadic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:52,Integrability,depend,dependent,52,// Emit a CreateWithDelayedArgs that takes only the dependent argument; // expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:26,Integrability,rout,routines,26,// Don't write conversion routines for fake arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:73,Testability,Test,Test,73,"// Helper function for GenerateTargetSpecificAttrChecks that alters the 'Test'; // parameter with only a single check type, if applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:178,Testability,Test,Test,178,"// Generate a conditional expression to check if the current target satisfies; // the conditions for a TargetSpecificAttr record, and append the code for; // those checks to the Test string. If the FnName string pointer is non-null,; // append a unique suffix to distinguish this set of target checks from other; // TargetSpecificAttr records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:399,Testability,test,test-recommendations,399,"// C++11-style attributes have specific version information associated with; // them. If the attribute has no scope, the version information must not; // have the default value (1), as that's incorrect. Instead, the unscoped; // attribute version information should be taken from the SD-6 standing; // document, which can be found at:; // https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations; //; // C23-style attributes have the same kind of version information; // associated with them. The unscoped attribute version information should; // be taken from the specification of the attribute in the C Standard.; //; // Clang-specific attributes have the same kind of version information; // associated with them. This version is typically the default value (1).; // These version values are clang-specific and should typically be; // incremented once the attribute changes its syntax and/or semantics in a; // a way that is impactful to the end user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:58,Testability,test,test,58,"// If this is the C++11 variety, also add in the LangOpts test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:26,Integrability,rout,routine,26,// Write generic Traverse routine,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:29,Integrability,depend,dependent,29,// Emits code to instantiate dependent attributes on templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:77,Testability,log,logic,77,"// If the arg is fake, it's the user's job to supply it: general parsing; // logic shouldn't need to know anything about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:98,Testability,log,logic,98,"// If the attribute does not contain a Subjects definition, then use the; // default appertainsTo logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:77,Testability,assert,assertion,77,// We should have sorted all of the subjects into two lists.; // FIXME: this assertion will be wrong if we ever add type attribute subjects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:36,Modifiability,inherit,inherit,36,// Find all of the definitions that inherit from MutualExclusions and include; // the given attribute in the list of exclusions to generate the; // diagMutualExclusion() check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:51,Testability,test,test,51,"// If we discovered any decl or stmt attributes to test for, generate the; // predicates for them now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:40,Testability,log,logic,40,// Generate the ParsedAttrInfo subclass logic for declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:105,Modifiability,inherit,inheritted,105,"// Also generate the declaration attribute merging logic if the current; // attribute is one that can be inheritted on a declaration. It is assumed; // this code will be executed in the context of a function with parameters:; // Sema &S, Decl *D, Attr *A and that returns a bool (false on diagnostic,; // true on success).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:51,Testability,log,logic,51,"// Also generate the declaration attribute merging logic if the current; // attribute is one that can be inheritted on a declaration. It is assumed; // this code will be executed in the context of a function with parameters:; // Sema &S, Decl *D, Attr *A and that returns a bool (false on diagnostic,; // true on success).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:329,Energy Efficiency,allocate,allocate,329,"// Statement attributes are a bit different from declarations. With; // declarations, each attribute is added to the declaration as it is; // processed, and so you can look on the Decl * itself to see if there is a; // conflicting attribute. Statement attributes are processed as a group; // because AttributedStmt needs to tail-allocate all of the attribute nodes; // at once. This means we cannot check whether the statement already contains; // an attribute to check for the conflict. Instead, we need to check whether; // the given list of semantic attributes contain any conflicts. It is assumed; // this code will be executed in the context of a function with parameters:; // Sema &S, const SmallVectorImpl<const Attr *> &C. The code will be within a; // loop which loops over the container C with a loop variable named A to; // represent the current attribute to check for conflicts.; //; // FIXME: it would be nice not to walk over the list of potential attributes; // to apply to the statement more than once, but statements typically don't; // have long lists of attributes on them, so re-walking the list should not; // be an expensive operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:811,Modifiability,variab,variable,811,"// Statement attributes are a bit different from declarations. With; // declarations, each attribute is added to the declaration as it is; // processed, and so you can look on the Decl * itself to see if there is a; // conflicting attribute. Statement attributes are processed as a group; // because AttributedStmt needs to tail-allocate all of the attribute nodes; // at once. This means we cannot check whether the statement already contains; // an attribute to check for the conflict. Instead, we need to check whether; // the given list of semantic attributes contain any conflicts. It is assumed; // this code will be executed in the context of a function with parameters:; // Sema &S, const SmallVectorImpl<const Attr *> &C. The code will be within a; // loop which loops over the container C with a loop variable named A to; // represent the current attribute to check for conflicts.; //; // FIXME: it would be nice not to walk over the list of potential attributes; // to apply to the statement more than once, but statements typically don't; // have long lists of attributes on them, so re-walking the list should not; // be an expensive operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:39,Testability,test,tested,39,// Get the list of architectures to be tested for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:40,Usability,simpl,simply,40,// Only generate if Attr can be handled simply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:89,Performance,perform,performing,89,// This stream is used to collect all of the declaration attribute merging; // logic for performing mutual exclusion checks. This gets emitted at the; // end of the file in a helper function of its own.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:79,Testability,log,logic,79,// This stream is used to collect all of the declaration attribute merging; // logic for performing mutual exclusion checks. This gets emitted at the; // end of the file in a helper function of its own.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:181,Testability,test,test,181,"// TODO: If the attribute's kind appears in the list of duplicates, that is; // because it is a target-specific attribute that appears multiple times.; // It would be beneficial to test whether the duplicates are ""similar; // enough"" to each other to not cause problems. For instance, check that; // the spellings are identical, and custom parsing rules match, etc.; // We need to generate struct instances based off ParsedAttrInfo from; // ParsedAttr.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:43,Testability,log,logic,43,// Write out the declaration merging check logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:41,Testability,log,logic,41,// Write out the statement merging check logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:656,Integrability,depend,depending,656,"// Attribute spellings can be shared between target-specific attributes,; // and can be shared between syntaxes for the same attribute. For; // instance, an attribute can be spelled GNU<""interrupt""> for an ARM-; // specific attribute, or MSP430-specific attribute. Additionally, an; // attribute can be spelled GNU<""dllexport""> and Declspec<""dllexport"">; // for the same semantic attribute. Ultimately, we need to map each of; // these to a single AttributeCommonInfo::Kind value, but the; // StringMatcher class cannot handle duplicate match strings. So we; // generate a list of string to match based on the syntax, and emit; // multiple string matchers depending on the syntax used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:40,Usability,simpl,simply,40,"// If there's only one spelling, we can simply use that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:18,Usability,undo,undocumented,18,"// If it's in the undocumented category, just construct a header by; // concatenating all the spellings. Might not be great, but better than; // nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:43,Availability,error,error,43,"// If the heading is still empty, it is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:43,Integrability,message,message,43,"// If the attribute is deprecated, print a message about it, and possibly; // provide a replacement attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentCommandInfoEmitter.cpp:429,Energy Efficiency,efficient,efficient,429,"//===--- ClangCommentCommandInfoEmitter.cpp - Generate command lists -----====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tablegen backend emits command lists and efficient matchers for command; // names that are used in documentation comments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangCommentCommandInfoEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentCommandInfoEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLNamedCharacterReferenceEmitter.cpp:414,Energy Efficiency,efficient,efficient,414,"//===--- ClangCommentHTMLNamedCharacterReferenceEmitter.cpp -----------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tablegen backend emits an efficient function to translate HTML named; // character references to UTF-8 sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLNamedCharacterReferenceEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLNamedCharacterReferenceEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLTagsEmitter.cpp:411,Energy Efficiency,efficient,efficient,411,"//===--- ClangCommentHTMLTagsEmitter.cpp - Generate HTML tag list for Clang -=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tablegen backend emits efficient matchers for HTML tags that are used; // in documentation comments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLTagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangCommentHTMLTagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp:236,Safety,safe,safely,236,"// If all the diagnostics and subgroups have been marked as being; // covered by -Wpedantic, increment the count of parent groups. Once the; // group's count is equal to the number of subgroups and diagnostics in; // that group, we can safely add this group to -Wpedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp:23,Availability,error,error,23,// Check if this is an error that is accidentally in a warning; // group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp:276,Integrability,message,messages,276,"/// Emit a list of group names.; ///; /// This creates a long string which by itself contains a list of pascal style; /// strings, which consist of a length byte directly followed by the string.; ///; /// \code; /// static const char DiagGroupNames[] = {; /// \000\020#pragma-messages\t#warnings\020CFString-literal""; /// };; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:604,Testability,test,test,604,"//===- ClangOpenCLBuiltinEmitter.cpp - Generate Clang OpenCL Builtin handling; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // These backends consume the definitions of OpenCL builtin functions in; // clang/lib/Sema/OpenCLBuiltins.td and produce builtin handling code for; // inclusion in SemaLookup.cpp, or a test file that calls all declared builtins.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:26,Availability,avail,available,26,"// Contains a list of the available signatures, without the name of the; // function. Each pair consists of a signature and a cumulative index.; // E.g.: <<float, float>, 0>,; // <<float, int, int, 2>>,; // <<float>, 5>,; // ...; // <<double, double>, 35>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:51,Testability,test,test,51,/// Base class for emitting a file (e.g. header or test) from OpenCLBuiltins.td,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:44,Testability,test,testing,44,// Entrypoint to generate the functions for testing all OpenCL builtin; // functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:18,Testability,test,test,18,"// OpenCL builtin test generator. This class processes the same TableGen input; // as BuiltinNameEmitter, but generates a .cl file that contains a call to each; // builtin function described in the .td input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:44,Testability,test,testing,44,// Entrypoint to generate the functions for testing all OpenCL builtin; // functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:109,Usability,simpl,simplifies,109,"// Extract generic types and non-generic types separately, to keep; // gentypes at the end of the enum which simplifies the special handling; // for gentypes in SemaLookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:1424,Availability,avail,available,1424,"R""(; // Image access qualifier.; enum OpenCLAccessQual : unsigned char {; OCLAQ_None,; OCLAQ_ReadOnly,; OCLAQ_WriteOnly,; OCLAQ_ReadWrite; };. // Represents a return type or argument type.; struct OpenCLTypeStruct {; // A type (e.g. float, int, ...).; const OpenCLTypeID ID;; // Vector size (if applicable; 0 for scalars and generic types).; const unsigned VectorWidth;; // 0 if the type is not a pointer.; const bool IsPointer : 1;; // 0 if the type is not const.; const bool IsConst : 1;; // 0 if the type is not volatile.; const bool IsVolatile : 1;; // Access qualifier.; const OpenCLAccessQual AccessQualifier;; // Address space of the pointer (if applicable).; const LangAS AS;; };. // One overload of an OpenCL builtin function.; struct OpenCLBuiltinStruct {; // Index of the signature in the OpenCLTypeStruct table.; const unsigned SigTableIndex;; // Entries between index SigTableIndex and (SigTableIndex + NumTypes - 1) in; // the SignatureTable represent the complete signature. The first type at; // index SigTableIndex is the return type.; const unsigned NumTypes;; // Function attribute __attribute__((pure)); const bool IsPure : 1;; // Function attribute __attribute__((const)); const bool IsConst : 1;; // Function attribute __attribute__((convergent)); const bool IsConv : 1;; // OpenCL extension(s) required for this overload.; const unsigned short Extension;; // OpenCL versions in which this overload is available.; const unsigned short Versions;; };. )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:14,Security,access,access,14,"R""(; // Image access qualifier.; enum OpenCLAccessQual : unsigned char {; OCLAQ_None,; OCLAQ_ReadOnly,; OCLAQ_WriteOnly,; OCLAQ_ReadWrite; };. // Represents a return type or argument type.; struct OpenCLTypeStruct {; // A type (e.g. float, int, ...).; const OpenCLTypeID ID;; // Vector size (if applicable; 0 for scalars and generic types).; const unsigned VectorWidth;; // 0 if the type is not a pointer.; const bool IsPointer : 1;; // 0 if the type is not const.; const bool IsConst : 1;; // 0 if the type is not volatile.; const bool IsVolatile : 1;; // Access qualifier.; const OpenCLAccessQual AccessQualifier;; // Address space of the pointer (if applicable).; const LangAS AS;; };. // One overload of an OpenCL builtin function.; struct OpenCLBuiltinStruct {; // Index of the signature in the OpenCLTypeStruct table.; const unsigned SigTableIndex;; // Entries between index SigTableIndex and (SigTableIndex + NumTypes - 1) in; // the SignatureTable represent the complete signature. The first type at; // index SigTableIndex is the return type.; const unsigned NumTypes;; // Function attribute __attribute__((pure)); const bool IsPure : 1;; // Function attribute __attribute__((const)); const bool IsConst : 1;; // Function attribute __attribute__((convergent)); const bool IsConv : 1;; // OpenCL extension(s) required for this overload.; const unsigned short Extension;; // OpenCL versions in which this overload is available.; const unsigned short Versions;; };. )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:557,Security,Access,Access,557,"R""(; // Image access qualifier.; enum OpenCLAccessQual : unsigned char {; OCLAQ_None,; OCLAQ_ReadOnly,; OCLAQ_WriteOnly,; OCLAQ_ReadWrite; };. // Represents a return type or argument type.; struct OpenCLTypeStruct {; // A type (e.g. float, int, ...).; const OpenCLTypeID ID;; // Vector size (if applicable; 0 for scalars and generic types).; const unsigned VectorWidth;; // 0 if the type is not a pointer.; const bool IsPointer : 1;; // 0 if the type is not const.; const bool IsConst : 1;; // 0 if the type is not volatile.; const bool IsVolatile : 1;; // Access qualifier.; const OpenCLAccessQual AccessQualifier;; // Address space of the pointer (if applicable).; const LangAS AS;; };. // One overload of an OpenCL builtin function.; struct OpenCLBuiltinStruct {; // Index of the signature in the OpenCLTypeStruct table.; const unsigned SigTableIndex;; // Entries between index SigTableIndex and (SigTableIndex + NumTypes - 1) in; // the SignatureTable represent the complete signature. The first type at; // index SigTableIndex is the return type.; const unsigned NumTypes;; // Function attribute __attribute__((pure)); const bool IsPure : 1;; // Function attribute __attribute__((const)); const bool IsConst : 1;; // Function attribute __attribute__((convergent)); const bool IsConv : 1;; // OpenCL extension(s) required for this overload.; const unsigned short Extension;; // OpenCL versions in which this overload is available.; const unsigned short Versions;; };. )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:599,Security,Access,AccessQualifier,599,"R""(; // Image access qualifier.; enum OpenCLAccessQual : unsigned char {; OCLAQ_None,; OCLAQ_ReadOnly,; OCLAQ_WriteOnly,; OCLAQ_ReadWrite; };. // Represents a return type or argument type.; struct OpenCLTypeStruct {; // A type (e.g. float, int, ...).; const OpenCLTypeID ID;; // Vector size (if applicable; 0 for scalars and generic types).; const unsigned VectorWidth;; // 0 if the type is not a pointer.; const bool IsPointer : 1;; // 0 if the type is not const.; const bool IsConst : 1;; // 0 if the type is not volatile.; const bool IsVolatile : 1;; // Access qualifier.; const OpenCLAccessQual AccessQualifier;; // Address space of the pointer (if applicable).; const LangAS AS;; };. // One overload of an OpenCL builtin function.; struct OpenCLBuiltinStruct {; // Index of the signature in the OpenCLTypeStruct table.; const unsigned SigTableIndex;; // Entries between index SigTableIndex and (SigTableIndex + NumTypes - 1) in; // the SignatureTable represent the complete signature. The first type at; // index SigTableIndex is the return type.; const unsigned NumTypes;; // Function attribute __attribute__((pure)); const bool IsPure : 1;; // Function attribute __attribute__((const)); const bool IsConst : 1;; // Function attribute __attribute__((convergent)); const bool IsConv : 1;; // OpenCL extension(s) required for this overload.; const unsigned short Extension;; // OpenCL versions in which this overload is available.; const unsigned short Versions;; };. )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:301,Availability,error,error,301,"// Verify that the combination of GenTypes in a signature is supported.; // To simplify the logic for creating overloads in SemaLookup, only allow; // a signature to contain different GenTypes if these GenTypes represent; // the same number of actual scalar or vector types.; //; // Exit with a fatal error if an unsupported construct is encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:92,Testability,log,logic,92,"// Verify that the combination of GenTypes in a signature is supported.; // To simplify the logic for creating overloads in SemaLookup, only allow; // a signature to contain different GenTypes if these GenTypes represent; // the same number of actual scalar or vector types.; //; // Exit with a fatal error if an unsupported construct is encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:79,Usability,simpl,simplify,79,"// Verify that the combination of GenTypes in a signature is supported.; // To simplify the logic for creating overloads in SemaLookup, only allow; // a signature to contain different GenTypes if these GenTypes represent; // the same number of actual scalar or vector types.; //; // Exit with a fatal error if an unsupported construct is encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:23,Safety,avoid,avoid,23,// Reuse signatures to avoid unnecessary duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:13,Availability,error,error,13,"// Report an error when seeing an entry that is too large for the; // current index type (unsigned short). When hitting this, the type; // of SignatureTable will need to be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:59,Availability,mask,mask,59,// Encode a range MinVersion..MaxVersion into a single bit mask that can be; // checked against LangOpts using isOpenCLVersionContainedInMask().; // This must be kept in sync with OpenCLVersionID in OpenCLOptions.h.; // (Including OpenCLOptions.h here would be a layering violation.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:32,Availability,avail,available,32,// A maximum version of 0 means available in all later versions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:35,Security,access,access-qualified,35,"// Map an image type name to its 3 access-qualified types (RO, WO, RW).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:128,Security,Access,AccessQualifier,128,"// Emit the cases for the image types. For an image type name, there are 3; // corresponding QualTypes (""RO"", ""WO"", ""RW""). The ""AccessQualifier"" field; // tells which one is needed. Emit a switch statement that puts the; // corresponding QualType into ""QT"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:16,Integrability,depend,depends,16,"// If this type depends on an extension, ensure the extension macros are; // defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:15,Testability,test,test,15,// Ensure each test has a unique name by numbering them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:625,Modifiability,config,config,625,"// Emit a package option.; //; // PACKAGE_OPTION(OPTIONTYPE, PACKAGENAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - PACKAGENAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config PACKAGENAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:306,Performance,load,load,306,"// Emit a package option.; //; // PACKAGE_OPTION(OPTIONTYPE, PACKAGENAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - PACKAGENAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config PACKAGENAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:209,Security,validat,validating,209,"// Emit a package option.; //; // PACKAGE_OPTION(OPTIONTYPE, PACKAGENAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - PACKAGENAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config PACKAGENAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:8,Integrability,depend,dependencies,8,"// Emit dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that depends on another checker.; // - DEPENDENCY: The full name of the checker FULLNAME depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:59,Integrability,DEPEND,DEPENDENCY,59,"// Emit dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that depends on another checker.; // - DEPENDENCY: The full name of the checker FULLNAME depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:121,Integrability,depend,depends,121,"// Emit dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that depends on another checker.; // - DEPENDENCY: The full name of the checker FULLNAME depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:155,Integrability,DEPEND,DEPENDENCY,155,"// Emit dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that depends on another checker.; // - DEPENDENCY: The full name of the checker FULLNAME depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:205,Integrability,depend,depends,205,"// Emit dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that depends on another checker.; // - DEPENDENCY: The full name of the checker FULLNAME depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:13,Integrability,depend,dependencies,13,"// Emit weak dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that is supposed to be; // registered first.; // - DEPENDENCY: The full name of the checker FULLNAME weak depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:64,Integrability,DEPEND,DEPENDENCY,64,"// Emit weak dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that is supposed to be; // registered first.; // - DEPENDENCY: The full name of the checker FULLNAME weak depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:172,Integrability,DEPEND,DEPENDENCY,172,"// Emit weak dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that is supposed to be; // registered first.; // - DEPENDENCY: The full name of the checker FULLNAME weak depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:227,Integrability,depend,depends,227,"// Emit weak dependencies.; //; // CHECKER_DEPENDENCY(FULLNAME, DEPENDENCY); // - FULLNAME: The full name of the checker that is supposed to be; // registered first.; // - DEPENDENCY: The full name of the checker FULLNAME weak depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:625,Modifiability,config,config,625,"// Emit a package option.; //; // CHECKER_OPTION(OPTIONTYPE, CHECKERNAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - CHECKERNAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config CHECKERNAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:306,Performance,load,load,306,"// Emit a package option.; //; // CHECKER_OPTION(OPTIONTYPE, CHECKERNAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - CHECKERNAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config CHECKERNAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp:209,Security,validat,validating,209,"// Emit a package option.; //; // CHECKER_OPTION(OPTIONTYPE, CHECKERNAME, OPTIONNAME, DESCRIPTION, DEFAULT); // - OPTIONTYPE: Type of the option, whether it's integer or boolean etc.; // This is important for validating user input. Note that; // it's a string, rather than an actual type: since we can; // load checkers runtime, we can't use template hackery for; // sorting this out compile-time.; // - CHECKERNAME: Name of the package.; // - OPTIONNAME: Name of the option.; // - DESCRIPTION; // - DEFAULT: The default value for this option.; //; // The full option can be specified in the command like this:; // -analyzer-config CHECKERNAME:OPTIONNAME=VALUE",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangSACheckersEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:1811,Availability,reliab,reliably,1811,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:1834,Availability,reliab,reliably,1834,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:2070,Energy Efficiency,efficient,efficiently,2070,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:651,Integrability,Depend,Depending,651,"//=== ClangTypeNodesEmitter.cpp - Generate type node tables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that nev",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:870,Integrability,depend,dependent,870,"//=== ClangTypeNodesEmitter.cpp - Generate type node tables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that nev",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:1546,Integrability,depend,dependent,1546,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:1757,Integrability,depend,dependent,1757,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp:1820,Integrability,depend,dependent,1820,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tblgen backend emits the node table (the .def file) for Clang; // type nodes.; //; // This file defines the AST type info database. Each type node is; // enumerated by providing its name (e.g., ""Builtin"" or ""Enum"") and; // base class (e.g., ""Type"" or ""TagType""). Depending on where in the; // abstract syntax tree the type will show up, the enumeration uses; // one of five different macros:; //; // TYPE(Class, Base) - A type that can show up anywhere in the AST,; // and might be dependent, canonical, or non-canonical. All clients; // will need to understand these types.; //; // ABSTRACT_TYPE(Class, Base) - An abstract class that shows up in; // the type hierarchy but has no concrete instances.; //; // NON_CANONICAL_TYPE(Class, Base) - A type that can show up; // anywhere in the AST but will never be a part of a canonical; // type. Clients that only need to deal with canonical types; // (ignoring, e.g., typedefs and other type aliases used for; // pretty-printing) can ignore these types.; //; // DEPENDENT_TYPE(Class, Base) - A type that will only show up; // within a C++ template that has not been instantiated, e.g., a; // type that is always dependent. Clients that do not need to deal; // with uninstantiated C++ templates can ignore these types.; //; // NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) - A type that; // is non-canonical unless it is dependent. Defaults to TYPE because; // it is neither reliably dependent nor reliably non-canonical.; //; // There is a sixth macro, independent of the others. Most clients; // will not need to use it.; //; // LEAF_TYPE(Class) - A type that never has inner types. Clients; // which can operate on such types more efficiently may wish to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangTypeNodesEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2169,Availability,error,error,2169,"ser-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2897,Availability,error,error,2897,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:3048,Availability,down,downside,3048,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:918,Integrability,depend,depending,918,"//===- MveEmitter.cpp - Generate arm_mve.h for use with clang -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This set of linked tablegen backends is responsible for emitting the bits; // and pieces that implement <arm_mve.h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1224,Integrability,wrap,wrappers,1224,"LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This set of linked tablegen backends is responsible for emitting the bits; // and pieces that implement <arm_mve.h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the u",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1368,Integrability,wrap,wrappers,1368,".h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribut",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1528,Integrability,wrap,wrap,1528,".h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribut",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2175,Integrability,message,messages,2175,"ser-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2903,Integrability,message,message,2903,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:806,Modifiability,polymorphi,polymorphism,806,"//===- MveEmitter.cpp - Generate arm_mve.h for use with clang -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This set of linked tablegen backends is responsible for emitting the bits; // and pieces that implement <arm_mve.h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1096,Modifiability,polymorphi,polymorphic,1096,"LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This set of linked tablegen backends is responsible for emitting the bits; // and pieces that implement <arm_mve.h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the u",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2558,Modifiability,polymorphi,polymorphic,2558,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2842,Modifiability,polymorphi,polymorphic,2842,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:610,Security,access,access,610,"//===- MveEmitter.cpp - Generate arm_mve.h for use with clang -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This set of linked tablegen backends is responsible for emitting the bits; // and pieces that implement <arm_mve.h>, which is defined by the ACLE standard; // and provides a set of types and functions for (more or less) direct access; // to the MVE instruction set, including the scalar shifts as well as the; // vector instructions.; //; // MVE's standard intrinsic functions are unusual in that they have a system of; // polymorphism. For example, the function vaddq() can behave like vaddq_u16(),; // vaddq_f32(), vaddq_s8(), etc., depending on the types of the vector; // arguments you give it.; //; // This constrains the implementation strategies. The usual approach to making; // the user-facing functions polymorphic would be to either use; // __attribute__((overloadable)) to make a set of vaddq() functions that are; // all inline wrappers on the underlying clang builtins, or to define a single; // vaddq() macro which expands to an instance of _Generic.; //; // The inline-wrappers approach would work fine for most intrinsics, except for; // the ones that take an argument required to be a compile-time constant,; // because if you wrap an inline function around a call to a builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2891,Usability,clear,clear,2891,"builtin, the; // constant nature of the argument is not passed through.; //; // The _Generic approach can be made to work with enough effort, but it takes a; // lot of machinery, because of the design feature of _Generic that even the; // untaken branches are required to pass all front-end validity checks such as; // type-correctness. You can work around that by nesting further _Generics all; // over the place to coerce things to the right type in untaken branches, but; // what you get out is complicated, hard to guarantee its correctness, and; // worst of all, gives _completely unreadable_ error messages if the user gets; // the types wrong for an intrinsic call.; //; // Therefore, my strategy is to introduce a new __attribute__ that allows a; // function to be mapped to a clang builtin even though it doesn't have the; // same name, and then declare all the user-facing MVE function names with that; // attribute, mapping each one directly to the clang builtin. And the; // polymorphic ones have __attribute__((overloadable)) as well. So once the; // compiler has resolved the overload, it knows the internal builtin ID of the; // selected function, and can check the immediate arguments against that; and; // if the user gets the types wrong in a call to a polymorphic intrinsic, they; // get a completely clear error message showing all the declarations of that; // function in the header file and explaining why each one doesn't fit their; // call.; //; // The downside of this is that if every clang builtin has to correspond; // exactly to a user-facing ACLE intrinsic, then you can't save work in the; // frontend by doing it in the header file: CGBuiltin.cpp has to do the entire; // job of converting an ACLE intrinsic call into LLVM IR. So the Tablegen; // description for an MVE intrinsic has to contain a full description of the; // sequence of IRBuilder calls that clang will need to make.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:90,Performance,load,load,90,"// MultiVector is used for the {uint,int,float}NxMxK_t types used by the; // interleaving load/store intrinsics v{ld,st}{2,4}q.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:225,Testability,log,logically,225,"// Predicate is used by all the predicated intrinsics. Its C; // representation is mve_pred16_t (which is just an alias for uint16_t).; // But we give more detail here, by indicating that a given predicate; // instruction is logically regarded as a vector of i1 containing the; // same number of lanes as the input vector type. So our Predicate type; // comes with a lane count, which we use to decide which kind of <n x i1>; // we'll invoke the pred_i2v IR intrinsic to translate it into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1448,Energy Efficiency,allocate,allocate,1448,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1076,Modifiability,variab,variable,1076,"// -----------------------------------------------------------------------------; // Class to facilitate merging together the code generation for many intrinsics; // by means of varying a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1228,Modifiability,variab,variables,1228,"; // by means of varying a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input e",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1497,Modifiability,variab,variables,1497,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1588,Modifiability,variab,variable,1588,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1677,Modifiability,variab,variable,1677,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1959,Modifiability,variab,variable,1959,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2109,Modifiability,variab,variables,2109,"ing a few constant or type parameters.; //; // Most obviously, the intrinsics in a single parametrised family will have; // code generation sequences that only differ in a type or two, e.g. vaddq_s8; // and vaddq_u16 will look the same apart from putting a different vector type; // in the call to CGM.getIntrinsic(). But also, completely different intrinsics; // will often code-generate in the same way, with only a different choice of; // _which_ IR intrinsic they lower to (e.g. vaddq_m_s8 and vmulq_m_s8), but; // marshalling the arguments and return values of the IR intrinsic in exactly; // the same way. And others might differ only in some other kind of constant,; // such as a lane index.; //; // So, when we generate the IR-building code for all these intrinsics, we keep; // track of every value that could possibly be pulled out of the code and; // stored ahead of time in a local variable. Then we group together intrinsics; // by textual equivalence of the code that would result if _all_ those; // parameters were stored in local variables. That gives us maximal sets that; // can be implemented by a single piece of IR-building code by changing; // parameter values ahead of time.; //; // After we've done that, we do a second pass in which we only allocate _some_; // of the parameters into local variables, by tracking which ones have the same; // values as each other (so that a single variable can be reused) and which; // ones are the same across the whole set (so that no variable is needed at; // all).; //; // Hence the class below. Its allocParam method is invoked during code; // generation by every method of a Result subclass (see below) that wants to; // give it the opportunity to pull something out into a switchable parameter.; // It returns a variable name for the parameter, or (if it's being used in the; // second pass once we've decided that some parameters don't need to be stored; // in variables after all) it might just return the input expression unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:331,Energy Efficiency,allocate,allocate,331,"// Provided ahead of time in pass 2, to indicate which parameters are being; // assigned to what. This vector contains an entry for each call to; // allocParam expected during code gen (which we counted up in pass 1), and; // indicates the number of the parameter variable that should be returned, or; // -1 if this call shouldn't allocate a parameter variable at all.; //; // We rely on the recursive code generation working identically in passes 1; // and 2, so that the same list of calls to allocParam happen in the same; // order. That guarantees that the parameter numbers recorded in pass 1 will; // match the entries in this vector that store what EmitterBase::EmitBuiltinCG; // decided to do about each one in pass 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:264,Modifiability,variab,variable,264,"// Provided ahead of time in pass 2, to indicate which parameters are being; // assigned to what. This vector contains an entry for each call to; // allocParam expected during code gen (which we counted up in pass 1), and; // indicates the number of the parameter variable that should be returned, or; // -1 if this call shouldn't allocate a parameter variable at all.; //; // We rely on the recursive code generation working identically in passes 1; // and 2, so that the same list of calls to allocParam happen in the same; // order. That guarantees that the parameter numbers recorded in pass 1 will; // match the entries in this vector that store what EmitterBase::EmitBuiltinCG; // decided to do about each one in pass 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:352,Modifiability,variab,variable,352,"// Provided ahead of time in pass 2, to indicate which parameters are being; // assigned to what. This vector contains an entry for each call to; // allocParam expected during code gen (which we counted up in pass 1), and; // indicates the number of the parameter variable that should be returned, or; // -1 if this call shouldn't allocate a parameter variable at all.; //; // We rely on the recursive code generation working identically in passes 1; // and 2, so that the same list of calls to allocParam happen in the same; // order. That guarantees that the parameter numbers recorded in pass 1 will; // match the entries in this vector that store what EmitterBase::EmitBuiltinCG; // decided to do about each one in pass 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:42,Energy Efficiency,allocate,allocated,42,// Internally track how many things we've allocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:53,Modifiability,variab,variable,53,"// In pass 1, unconditionally assign a new parameter variable to every; // value we're asked to process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:75,Modifiability,variab,variable,75,"// In pass 2, consult the map provided by the caller to find out which; // variable we should be keeping things in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:12,Energy Efficiency,allocate,allocated,12,"// If we've allocated a new parameter variable for the first time, store; // its type and value to be retrieved after codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:38,Modifiability,variab,variable,38,"// If we've allocated a new parameter variable for the first time, store; // its type and value to be retrieved after codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:45,Modifiability,variab,variables,45,// Unimaginative naming scheme for parameter variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:308,Performance,load,loads,308,"// -----------------------------------------------------------------------------; // System of classes that represent all the intermediate values used during; // code-generation for an intrinsic.; //; // The base class 'Result' can represent a value of the LLVM type 'Value', or; // sometimes 'Address' (for loads/stores, including an alignment requirement).; //; // In the case where the Tablegen provides a value in the codegen dag as a; // plain integer literal, the Result object we construct here will be one that; // returns true from hasIntegerConstantValue(). This allows the generated C++; // code to use the constant directly in contexts which can take a literal; // integer, such as Builder.CreateExtractValue(thing, 1), without going to the; // effort of calling llvm::ConstantInt::get() and then pulling the constant; // back out of the resulting llvm:Value later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:50,Integrability,depend,dependency,50,"// Mostly, when a code-generation operation has a dependency on prior; // operations, it's because it uses the output values of those operations as; // inputs. But there's one exception, which is the use of 'seq' in Tablegen; // to indicate that operations have to be performed in sequence regardless of; // whether they use each others' output values.; //; // So, the actual generation of code is done by depth-first search, using the; // prerequisites() method to get a list of all the other Results that have to; // be computed before this one. That method divides into the 'predecessor',; // set by setPredecessor() while processing a 'seq' dag node, and the list; // returned by 'morePrerequisites', which each subclass implements to return; // a list of the Results it uses as input to whatever its own computation is; // doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:268,Performance,perform,performed,268,"// Mostly, when a code-generation operation has a dependency on prior; // operations, it's because it uses the output values of those operations as; // inputs. But there's one exception, which is the use of 'seq' in Tablegen; // to indicate that operations have to be performed in sequence regardless of; // whether they use each others' output values.; //; // So, the actual generation of code is done by depth-first search, using the; // prerequisites() method to get a list of all the other Results that have to; // be computed before this one. That method divides into the 'predecessor',; // set by setPredecessor() while processing a 'seq' dag node, and the list; // returned by 'morePrerequisites', which each subclass implements to return; // a list of the Results it uses as input to whatever its own computation is; // doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:34,Modifiability,variab,variable,34,"// Each Result will be assigned a variable name in the output code, but not; // all those variable names will actually be used (e.g. the return value of; // Builder.CreateStore has void type, so nobody will want to refer to it). To; // prevent annoying compiler warnings, we track whether each Result's; // variable name was ever actually mentioned in subsequent statements, so; // that it can be left out of the final generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:90,Modifiability,variab,variable,90,"// Each Result will be assigned a variable name in the output code, but not; // all those variable names will actually be used (e.g. the return value of; // Builder.CreateStore has void type, so nobody will want to refer to it). To; // prevent annoying compiler warnings, we track whether each Result's; // variable name was ever actually mentioned in subsequent statements, so; // that it can be left out of the final generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:307,Modifiability,variab,variable,307,"// Each Result will be assigned a variable name in the output code, but not; // all those variable names will actually be used (e.g. the return value of; // Builder.CreateStore has void type, so nobody will want to refer to it). To; // prevent annoying compiler warnings, we track whether each Result's; // variable name was ever actually mentioned in subsequent statements, so; // that it can be left out of the final generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:199,Modifiability,variab,variable,199,"// Result subclass that retrieves one of the arguments to the clang builtin; // function. In cases where the argument has pointer type, we call; // EmitPointerWithAlignment and store the result in a variable of type Address,; // so that load and store IR nodes can know the right alignment. Otherwise, we; // call EmitScalarExpr.; //; // There are aggregate parameters in the MVE intrinsics API, but we don't deal; // with them in this Tablegen back end: they only arise in the vld2q/vld4q and; // vst2q/vst4q family, which is few enough that we just write the code by hand; // for those in CGBuiltin.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:237,Performance,load,load,237,"// Result subclass that retrieves one of the arguments to the clang builtin; // function. In cases where the argument has pointer type, we call; // EmitPointerWithAlignment and store the result in a variable of type Address,; // so that load and store IR nodes can know the right alignment. Otherwise, we; // call EmitScalarExpr.; //; // There are aggregate parameters in the MVE intrinsics API, but we don't deal; // with them in this Tablegen back end: they only arise in the vld2q/vld4q and; // vst2q/vst4q family, which is few enough that we just write the code by hand; // for those in CGBuiltin.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:201,Integrability,depend,depending,201,"// Result subclass for an integer literal appearing in Tablegen. This may need; // to be turned into an llvm::Result by means of llvm::ConstantInt::get(), or; // it may be used directly as an integer, depending on which IRBuilder method; // it's being passed to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:7,Modifiability,polymorphi,polymorphic,7,"// For polymorphic intrinsics, FullName is the explicit name that uniquely; // identifies this variant of the intrinsic, and ShortName is the name it; // shares with at least one other intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:51,Modifiability,polymorphi,polymorphic,51,// A very small number of intrinsics _only_ have a polymorphic; // variant (vuninitializedq taking an unevaluated argument).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:29,Integrability,wrap,wrapper,29,"// Pass to a subfield of any wrapper records. We don't expect more than one; // of these: immediate operands are used as plain numbers rather than as; // llvm::Value, so it's meaningless to promote their type anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:26,Modifiability,polymorphi,polymorphic,26,"// Derive the intrinsic's polymorphic name, by removing components from the; // full name as specified by its 'pnt' member ('polymorphic name type'),; // which indicates how many type suffixes to remove, and any other piece of; // the name that should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:125,Modifiability,polymorphi,polymorphic,125,"// Derive the intrinsic's polymorphic name, by removing components from the; // full name as specified by its 'pnt' member ('polymorphic name type'),; // which indicates how many type suffixes to remove, and any other piece of; // the name that should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:87,Modifiability,variab,variable-name,87,"// The argument will usually have a name in the arguments dag, which goes; // into the variable-name scope that the code gen will refer to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:107,Integrability,depend,depended-on,107,"// Finally, go through the codegen dag and translate it into a Result object; // (with an arbitrary DAG of depended-on Results hanging off it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:116,Modifiability,variab,variables,116,"// Or, if it's the special case of CustomCodegen, just accumulate; // a list of parameters we're going to assign to variables before; // breaking from the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:6,Integrability,wrap,wrapper,6,"/// A wrapper on raw_string_ostream that contains its own buffer rather than; /// having to point it at one elsewhere. (In other words, it works just like; /// std::ostringstream; also, this makes it convenient to declare a whole array; /// of them at once.); ///; /// We have to set this up using multiple inheritance, to ensure that the; /// string member has been constructed before raw_string_ostream's constructor; /// is given a pointer to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:307,Modifiability,inherit,inheritance,307,"/// A wrapper on raw_string_ostream that contains its own buffer rather than; /// having to point it at one elsewhere. (In other words, it works just like; /// std::ostringstream; also, this makes it convenient to declare a whole array; /// of them at once.); ///; /// We have to set this up using multiple inheritance, to ensure that the; /// string member has been constructed before raw_string_ostream's constructor; /// is given a pointer to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:277,Modifiability,variab,variables,277,"// Machinery for the grouping of intrinsics by similar codegen.; //; // The general setup is that 'MergeableGroup' stores the things that a set of; // similarly shaped intrinsics have in common: the text of their code; // generation, and the number and type of their parameter variables.; // MergeableGroup is the key in a std::map whose value is a set of; // OutputIntrinsic, which stores the ways in which a particular intrinsic; // specializes the MergeableGroup's generic description: the function name and; // the _values_ of the parameter variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:545,Modifiability,variab,variables,545,"// Machinery for the grouping of intrinsics by similar codegen.; //; // The general setup is that 'MergeableGroup' stores the things that a set of; // similarly shaped intrinsics have in common: the text of their code; // generation, and the number and type of their parameter variables.; // MergeableGroup is the key in a std::map whose value is a set of; // OutputIntrinsic, which stores the ways in which a particular intrinsic; // specializes the MergeableGroup's generic description: the function name and; // the _values_ of the parameter variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:134,Modifiability,variab,variable,134,// Pass 1: generate code for all the intrinsics as if every type or constant; // that can possibly be abstracted out into a parameter variable will be.; // This identifies the sets of intrinsics we'll group together into a single; // piece of code generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:60,Modifiability,variab,variable,60,"// Pass 2: for each of those groups, optimize the parameter variable set by; // eliminating 'parameters' that are the same for all intrinsics in the; // group, and merging together pairs of parameter variables that take the; // same values as each other for all intrinsics in the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:200,Modifiability,variab,variables,200,"// Pass 2: for each of those groups, optimize the parameter variable set by; // eliminating 'parameters' that are the same for all intrinsics in the; // group, and merging together pairs of parameter variables that take the; // same values as each other for all intrinsics in the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:37,Performance,optimiz,optimize,37,"// Pass 2: for each of those groups, optimize the parameter variable set by; // eliminating 'parameters' that are the same for all intrinsics in the; // group, and merging together pairs of parameter variables that take the; // same values as each other for all intrinsics in the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:49,Modifiability,variab,variable,49,"// If so, record it as -1, meaning 'no parameter variable needed'. Then; // the corresponding call to allocParam in pass 2 will not generate a; // variable at all, and just use the value inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:147,Modifiability,variab,variable,147,"// If so, record it as -1, meaning 'no parameter variable needed'. Then; // the corresponding call to allocParam in pass 2 will not generate a; // variable at all, and just use the value inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:244,Modifiability,variab,variables,244,"// Otherwise, make a list of the values this parameter takes for each; // intrinsic, and see if that value vector matches anything we already; // have. We also record the parameter type, so that we don't accidentally; // match up two parameter variables with different types. (Not that; // there's much chance of them having textually equivalent values, but in; // _principle_ it could happen.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:30,Modifiability,variab,variable,30,"// Yes, an existing parameter variable can be reused for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:31,Modifiability,variab,variable,31,"// No, we need a new parameter variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:77,Energy Efficiency,reduce,reduced,77,"// Now we're ready to do the pass 2 code generation, which will emit the; // reduced set of parameter variables we've just worked out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:102,Modifiability,variab,variables,102,"// Now we're ready to do the pass 2 code generation, which will emit the; // reduced set of parameter variables we've just worked out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:31,Modifiability,variab,variables,31,"// If we've got some parameter variables, then emit their declarations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:76,Modifiability,polymorphi,polymorphic,76,// Build a sorted table of:; // - intrinsic id number; // - full name; // - polymorphic name or -1,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:89,Modifiability,polymorphi,polymorphic,89,"// We generate each intrinsic twice, under its full unambiguous; // name and its shorter polymorphic name (if the latter exists).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:131,Safety,safe,safe,131,"// We also generate each intrinsic under a name like __arm_vfooq; // (which is in C language implementation namespace, so it's; // safe to define in any conforming user program) and a shorter; // one like vfooq (which is in user namespace, so a user might; // reasonably have used it for something already). If so, they; // can #define __ARM_MVE_PRESERVE_USER_NAMESPACE before; // including the header, which will suppress the shorter names; // and leave only the implementation-namespace ones. Then they; // have to write __arm_vfooq everywhere, of course.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:757,Availability,error,error,757,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1164,Availability,error,error,1164,"provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1896,Availability,error,error,1896,"/ was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually readable; // type signatures for vfooq(), and here's why each one didn't; // match your call"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2222,Availability,error,error,2222,"/ was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually readable; // type signatures for vfooq(), and here's why each one didn't; // match your call"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:696,Integrability,wrap,wrapper,696,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:763,Integrability,message,message,763,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:786,Integrability,wrap,wrapper,786,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:995,Integrability,wrap,wrapper,995,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1170,Integrability,message,messages,1170,"provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1906,Integrability,message,messages,1906,"/ was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually readable; // type signatures for vfooq(), and here's why each one didn't; // match your call"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:2228,Integrability,message,message,2228,"/ was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually readable; // type signatures for vfooq(), and here's why each one didn't; // match your call"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1249,Modifiability,polymorphi,polymorphic,1249,"fined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually r",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:1975,Modifiability,polymorphi,polymorphic,1975,"/ was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this way, clang will print just; // the _final_ line of each declaration in the header, to show; // the type signatures that would have been legal. So all the; // confusing machinery with __attribute__ is left out of the; // error message, and the user sees something that's more or; // less self-documenting: ""here's a list of actually readable; // type signatures for vfooq(), and here's why each one didn't; // match your call"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:737,Safety,avoid,avoids,737,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:197,Modifiability,polymorphi,polymorphic,197,"// -----------------------------------------------------------------------------; // Class that describes an ACLE intrinsic implemented as a macro.; //; // This class is used when the intrinsic is polymorphic in 2 or 3 types, but we; // want to avoid a combinatorial explosion by reinterpreting the arguments to; // fixed types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:245,Safety,avoid,avoid,245,"// -----------------------------------------------------------------------------; // Class that describes an ACLE intrinsic implemented as a macro.; //; // This class is used when the intrinsic is polymorphic in 2 or 3 types, but we; // want to avoid a combinatorial explosion by reinterpreting the arguments to; // fixed types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:89,Modifiability,polymorphi,polymorphic,89,"// We generate each intrinsic twice, under its full unambiguous; // name and its shorter polymorphic name (if the latter exists).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:549,Integrability,interface,interface,549,"//===- NeonEmitter.cpp - Generate arm_neon.h for use with clang -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tablegen backend is responsible for emitting arm_neon.h, which includes; // a declaration and definition of each function specified by the ARM NEON; // compiler interface. See ARM document DUI0348B.; //; // Each NEON instruction is implemented in terms of 1 or more functions which; // are suffixed with the element type of the input vectors. Functions may be; // implemented in terms of generic vector operations such as +, *, -, etc. or; // by calling a __builtin_-prefixed function which will be handled by clang's; // CodeGen library.; //; // Additional validation code can be generated by this file when runHeader() is; // called, rather than the normal run() entry point.; //; // See also the documentation in include/clang/Basic/arm_neon.td.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:946,Security,validat,validation,946,"//===- NeonEmitter.cpp - Generate arm_neon.h for use with clang -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tablegen backend is responsible for emitting arm_neon.h, which includes; // a declaration and definition of each function specified by the ARM NEON; // compiler interface. See ARM document DUI0348B.; //; // Each NEON instruction is implemented in terms of 1 or more functions which; // are suffixed with the element type of the input vectors. Functions may be; // implemented in terms of generic vector operations such as +, *, -, etc. or; // by calling a __builtin_-prefixed function which will be handled by clang's; // CodeGen library.; //; // Additional validation code can be generated by this file when runHeader() is; // called, rather than the normal run() entry point.; //; // See also the documentation in include/clang/Basic/arm_neon.td.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:58,Performance,perform,perform,58,"// While globals are generally bad, this one allows us to perform assertions; // liberally and somehow still trace them back to the def they indirectly; // came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
