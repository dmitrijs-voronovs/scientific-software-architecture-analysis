id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.6/changelog.html:37194,Integrability,depend,dependent,37194,"lure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-calculated numpy array that specifies the values of the; Qobj-coefficients for each time step.; New functions for working with different superoperator representations,; including Kraus and Chi representation.; New functions for visualizing quantum states using Qubism and Schimdt plots:; plot_qubism and plot_schmidt.; Dynamics solver now support taking argument e_ops (expectation value; operators) in dictionary form.; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been re",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:39489,Integrability,depend,dependent,39489," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:39552,Integrability,depend,depend,39552," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40533,Integrability,integrat,integration,40533,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:41450,Integrability,depend,dependent,41450,"rk scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.;",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:42647,Integrability,depend,dependence,42647,"sed on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and para",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43074,Integrability,rout,routines,43074,"es as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43339,Integrability,depend,dependent,43339,"turns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43415,Integrability,depend,dependent,43415,"s.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum obj",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43530,Integrability,depend,dependent,43530,"now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can h",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43854,Integrability,depend,dependent,43854,"ermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single functi",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:5406,Modifiability,config,configuration,5406," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:12056,Modifiability,config,configuration,12056,"nings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X,",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:19281,Modifiability,refactor,refactored,19281,"Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propag",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:22970,Modifiability,variab,variable,22970,"w properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad di",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:24189,Modifiability,config,configuration,24189,"sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:27990,Modifiability,enhance,enhancements,27990,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:30439,Modifiability,config,configuration,30439,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:33139,Modifiability,variab,variables,33139,"operties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplo",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:34516,Modifiability,enhance,enhanced,34516,"ult in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40784,Modifiability,variab,variable,40784,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:2145,Performance,perform,performance,2145,"sion 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:11990,Performance,load,loading,11990,"o the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna an",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:12370,Performance,perform,performance,12370,"eduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:26127,Performance,optimiz,optimization,26127,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:26413,Performance,load,loading,26413,"operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:27978,Performance,perform,performance,27978,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:29044,Performance,perform,performs,29044,"er optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is n",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:35198,Performance,perform,performance,35198,"r counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:38645,Performance,concurren,concurrence,38645,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Imp",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:39702,Performance,optimiz,optimized,39702,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40368,Performance,perform,performance,40368,"; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualizat",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:41275,Performance,perform,performance,41275,"nstances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:42996,Performance,perform,performance,42996,"es as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:44485,Performance,optimiz,optimized,44485,"ed to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:44711,Performance,concurren,concurrence,44711,"t; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are ze",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:46527,Performance,concurren,concurrence,46527," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:46719,Performance,load,loading,46719,"em.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:3845,Safety,sanity check,sanity checks,3845,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:17316,Safety,unsafe,unsafe,17316," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:17350,Safety,unsafe,unsafe,17350," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:26586,Safety,safe,safety,26586,"n of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:27889,Safety,avoid,avoid,27889," Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:30811,Safety,avoid,avoided,30811,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:33256,Safety,avoid,avoid,33256,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; St",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:39795,Safety,avoid,avoiding,39795,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:2980,Testability,test,testing,2980," Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad init",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:4312,Testability,test,tested,4312,"much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions du",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:4326,Testability,test,test,4326,"much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions du",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:5047,Testability,test,tests,5047,"olve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitC",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:7079,Testability,test,test,7079,"1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:7263,Testability,test,tests,7263,"ixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:7281,Testability,test,test,7281,"ixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:7872,Testability,test,tests,7872,"6 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X impor",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:7974,Testability,test,test,7974,"iP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:8050,Testability,test,tests,8050,"by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:8106,Testability,test,tests,8106,"erators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a c",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:8762,Testability,test,test,8762,"ndabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:8873,Testability,test,tests,8873,"ded tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:13812,Testability,test,tests,13812,"uit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by Jake Lishman); Fix the trace norm being incorrectly reported as 0 for small matrices. (by Jake Lishman); Fix issues with dnorm when using CVXPy 1.1 with sparse matrices. (by Felipe Bivort Haiek); Fix segfaults in mesolve when passed a bad initial Qobj as the state. (by Jake Lishman); Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by Drew Parsons); Fix zspmv_openmp.cpp missing from the pip sdist. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:15295,Testability,test,tests,15295,"st. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add supp",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:15317,Testability,test,testing,15317,"st. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add supp",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:15546,Testability,test,testing,15546," Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:18162,Testability,test,tests,18162,"x issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:18254,Testability,test,testing,18254," of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke d",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:18636,Testability,test,testing,18636,"ction for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nath",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:18694,Testability,test,testing,18694,"2 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:18736,Testability,test,test,18736,"2 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:19126,Testability,test,tests,19126,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:19143,Testability,test,tests,19143,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:19152,Testability,test,testing,19152,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:19189,Testability,benchmark,benchmarking,19189,"ac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checkin",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:20533,Testability,test,tests,20533,"as Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new meth",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:27687,Testability,test,tests,27687,"sue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:32446,Testability,test,tests,32446,"g_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decomp_curr now _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as Qobj). fidcomp properties. uses_evo_t2end now uses_onwd_evo; uses_evo_t2targ now uses_onto_evo; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:32797,Testability,test,tests,32797,"w _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as Qobj). fidcomp properties. uses_evo_t2end now uses_onwd_evo; uses_evo_t2targ now uses_onto_evo; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list a",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:34405,Testability,log,logging,34405,"y set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady sta",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:34441,Testability,log,logging,34441,"nd Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now su",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40545,Testability,test,tests,40545,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40894,Testability,log,logarithmic,40894,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:44988,Testability,test,tests,44988,"and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEAS",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:3069,Usability,simpl,simple,3069," for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:6089,Usability,guid,guide,6089,"ts for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). D",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:6191,Usability,guid,guide,6191,"sly when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Gig",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:6851,Usability,guid,guide,6851,"ims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#166",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:6948,Usability,guid,guide,6948,"uère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:15416,Usability,simpl,simplify,15416,"cuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:29694,Usability,simpl,simplified,29694,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:34658,Usability,progress bar,progress bars,34658,"rnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-depende",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:40313,Usability,simpl,simplified,40313," for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner c",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:42851,Usability,progress bar,progress bar,42851,"ctions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent argumen",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/changelog.html:43663,Usability,simpl,simplifying,43663,"time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method in",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
https://qutip.org/docs/4.6/contributors.html:2253,Deployability,update,updated,2253,"Alex Pitchford; Nathan Shammah; Shahnawaz Ahmed; Neill Lambert; Eric Giguère; Boxi Li; Jake Lishman; Simon Cross. Past Lead Developers¶. Robert Johansson (RIKEN); Paul Nation (Korea University); Chris Granade; Arne Grimsmo. Contributors¶. Note; Anyone is welcome to contribute to QuTiP.; If you are interested in helping, please let us know!. Abhisek Upadhyaya; Adriaan; Alexander Pitchford; Alexios-xi; Amit; Anubhav Vardhan; Arie van Deursen; Arne Grimsmo; Arne Hamann; Asier Galicia Martinez; Ben Bartlett; Ben Criger; Ben Jones; Bo Yang; Boxi Li; Canoming; Christoph Gohlke; Christopher Granade; Craig Gidney; Denis Vasilyev; Dominic Meiser; Drew Parsons; Eric Giguère; Eric Hontz; Felipe Bivort Haiek; Florestan Ziem; Gilbert Shih; Harry Adams; Ivan Carvalho; Jake Lishman; Jevon Longdell; Johannes Feist; Jonas Hoersch; Jonas Neergaard-Nielsen; Jonathan A. Gross; Julian Iacoponi; Kevin Fischer; Laurence Stant; Louis Tessler; Lucas Verney; Marco David; Marek; Markus Baden; Martín Sande; Mateo Laguna; Matthew O’Brien; Michael Goerz; Michael V. DePalatis; Moritz Oberhauser; Nathan Shammah; Neill Lambert; Nicolas Quesada; Nikolas Tezak; Nithin Ramu; Paul Nation; Peter Kirton; Philipp Schindler; Piotr Migdal; Rajiv-B; Ray Ganardi; Reinier Heeres; Richard Brierley; Robert Johansson; Sam Griffiths; Samesh Lakhotia; Sebastian Krämer; Shahnawaz Ahmed; Sidhant Saraogi; Simon Cross; Simon Humpohl; Simon Whalen; Stefan Krastanov; Tarun Raheja; Thomas Walker; Viacheslav Ostroukh; Vlad Negnevitsky; Wojciech Rzadkowski; Xiaodong Qi; Xiaoliang Wu; Yariv Yanay; YouWei Zhao; alex; eliegenois; essence-of-waqf; fhenneke; gecrooks; jakobjakobson13; maij; sbisw002; yuri@FreeBSD; Élie Gouzien. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/contributors.html
https://qutip.org/docs/4.6/frontmatter.html:565,Availability,avail,available,565,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:1455,Availability,down,downloaded,1455,"ains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the sy",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:3424,Availability,avail,available,3424,"tical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantu",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:5838,Availability,error,error,5838," a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:929,Deployability,release,release,929,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4626,Deployability,release,release,4626,"tions.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:6960,Deployability,update,updated,6960," them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:2804,Energy Efficiency,efficient,efficiently,2804,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4060,Integrability,depend,dependence,4060,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum informat",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4108,Integrability,depend,dependent,4108,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4698,Integrability,depend,depend,4698,"e generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for workin",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:5186,Integrability,interface,interfaces,5186,"tially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for sim",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:5500,Integrability,interface,interface,5500,"ox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our us",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:6016,Integrability,protocol,protocols,6016," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:1903,Modifiability,coupling,coupling,1903,"iguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:2041,Modifiability,coupling,coupling,2041,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4778,Modifiability,plugin,plugin,4778,"are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4810,Modifiability,coupling,coupling,4810,"are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:1996,Performance,perform,performed,1996,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4197,Performance,perform,performance,4197,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:3808,Testability,test,tested,3808,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a comput",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:6011,Testability,test,test,6011," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:472,Usability,guid,guide,472,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:4359,Usability,learn,learning,4359," framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQ",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/frontmatter.html:6412,Usability,guid,guide,6412," them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
https://qutip.org/docs/4.6/genindex.html:34253,Deployability,update,update,34253,). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). to_chi() (in module qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_list() (QobjEvo method). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.operations.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:35627,Deployability,update,updated,35627,".metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). X. x() (Lattice1d method). Z. zero_ket() (in module qutip.states). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:3318,Energy Efficiency,charge,charge,3318,e qutip.metrics). B. basis() (in module qutip.states). (Lattice1d method). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module quti,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:29126,Energy Efficiency,schedul,schedule,29126,optimization() (Optimizer method). (OptimizerBFGS method). (OptimizerCrabFmin method). (OptimizerLBFGSB method). run_state() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). run_statistics() (CircuitSimulator method). (QubitCircuit method). rx() (in module qutip.qip.operations.gates). rx_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). ry() (in module qutip.qip.operations.gates). rz() (in module qutip.qip.operations.gates). rz_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). S. save() (Bloch method). save_amps() (Dynamics method). save_coeff() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). save_qasm() (in module qutip.qip.qasm). scattering_probability() (in module qutip.scattering). schedule() (Scheduler method). Scheduler (class in qutip.qip.compiler). serial_map() (in module qutip.parallel). sesolve() (in module qutip.sesolve). set_all_tlist() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). set_label_convention() (Bloch method). set_optim_var_vals() (PulseGenCrab method). set_phase_option() (FidCompUnitary method). set_total_time() (Stats method). set_up_ops() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). set_up_params() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). shape() (in module qutip.qobj). show() (Bloch method). sigmam() (in module qutip.operators). sigmap() (in module qutip.operators). sigmax() (in module qutip.operators). sigmay() (in module qutip.operators). sigmaz() (in module qutip.operators). simdi,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:5232,Modifiability,config,configure,5232, (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:5191,Performance,concurren,concurrence,5191, property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19493,Performance,optimiz,optimizer,19493,mul_mat() (QobjEvo method). mul_vec() (QobjEvo method). N. n_thermal() (in module qutip.utilities). Noise (class in qutip.qip.noise). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). ,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19780,Performance,optimiz,optimizer,19780,method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stocha,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19830,Performance,optimiz,optimizer,19830,um() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19880,Performance,optimiz,optimizer,19880,amics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19934,Performance,optimiz,optimizer,19934,_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:19986,Performance,optimiz,optimizer,19986,) (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_energy_levels() (in module qutip.visualization). plo,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/genindex.html:3837,Usability,clear,clear,3837,brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
https://qutip.org/docs/4.6/index.html:4897,Deployability,release,released,4897," Bug Fixes; Documentation Improvements; Developer Changes. Version 4.6.2 (June 2, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.1 (May 4, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.0 (April 11, 2021); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.3 (February 19, 2021); Improvements. Version 4.5.2 (July 14, 2020); Improvements; Bug Fixes; Developer Changes. Version 4.5.1 (May 15, 2020); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:5872,Deployability,release,release,5872,"7); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Git workflow; Documentation build; Build release distribution and deploy; Making a release on GitHub; Website; Conda-forge. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:6227,Deployability,release,release,6227,"7); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Git workflow; Documentation build; Build release distribution and deploy; Making a release on GitHub; Website; Conda-forge. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:6252,Deployability,deploy,deploy,6252,"7); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Git workflow; Documentation build; Build release distribution and deploy; Making a release on GitHub; Website; Conda-forge. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:6269,Deployability,release,release,6269,"7); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Git workflow; Documentation build; Build release distribution and deploy; Making a release on GitHub; Website; Conda-forge. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:6574,Deployability,update,updated,6574,"7); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Git workflow; Documentation build; Build release distribution and deploy; Making a release on GitHub; Website; Conda-forge. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:1578,Integrability,depend,dependent,1578,"lling with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and p",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:2640,Performance,load,loading,2640, Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/index.html:2675,Performance,load,loading,2675, Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
https://qutip.org/docs/4.6/installation.html:3199,Availability,avail,available,3199,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4645,Availability,avail,available,4645,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4664,Availability,down,download,4664,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4739,Availability,avail,available,4739,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5340,Availability,avail,available,5340,"-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6288,Availability,error,error-prone,6288,"d QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library suppo",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7055,Availability,avail,available,7055,"_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7923,Availability,avail,available,7923,"the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stand",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8614,Availability,down,download,8614,"al folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10218,Availability,failure,failures,10218,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10230,Availability,error,errors,10230,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:688,Deployability,install,install,688,"﻿. Installation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfai",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:728,Deployability,install,install,728,"﻿. Installation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfai",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1157,Deployability,install,installation,1157,"channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packag",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1191,Deployability,install,installation,1191,"channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packag",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2586,Deployability,integrat,integrated,2586," provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channe",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3006,Deployability,install,install,3006," LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have on",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3223,Deployability,install,install,3223,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3251,Deployability,install,install,3251,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3276,Deployability,install,install,3276,"d text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This wi",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3387,Deployability,install,install,3387,"runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You act",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3550,Deployability,install,install,3550,"ogether.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3924,Deployability,install,installed,3924,"s that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4005,Deployability,install,install,4005,"s that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4044,Deployability,install,installed,4044,".; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more contro",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4119,Deployability,install,install,4119,".; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more contro",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4325,Deployability,install,install,4325,"es. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package availabl",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4481,Deployability,install,install,4481,"nda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4536,Deployability,install,install,4536,"nda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4623,Deployability,release,releases,4623,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:4831,Deployability,release,release,4831,"packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5016,Deployability,install,install,5016,"vironment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in th",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5384,Deployability,install,install,5384,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5436,Deployability,install,installation,5436,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5470,Deployability,install,install,5470,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5557,Deployability,install,install,5557,"pyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5609,Deployability,install,install,5609,"pyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5677,Deployability,install,installs,5677,"e code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5775,Deployability,install,install,5775,"e code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6258,Deployability,install,installation,6258,"d QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library suppo",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6409,Deployability,install,installed,6409,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6544,Deployability,release,release,6544,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6583,Deployability,install,installed,6583,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6603,Deployability,install,install,6603,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6783,Deployability,install,installed,6783,"pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6907,Deployability,install,installations,6907,"rce code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Pyth",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6959,Deployability,install,install,6959,"erating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without n",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7016,Deployability,install,install,7016,"hing like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Not",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7028,Deployability,install,install,7028,"_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7088,Deployability,install,install,7088,"file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7683,Deployability,install,install,7683,"ng 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual St",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8168,Deployability,install,install,8168," suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Stud",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8279,Deployability,install,installing,8279," suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Stud",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8426,Deployability,install,install,8426,"o external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to in",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8796,Deployability,install,installing,8796," the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:8973,Deployability,install,installation,8973," needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it i",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9219,Deployability,install,installation,9219,"ruser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optiona",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9407,Deployability,install,install,9407," install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9602,Deployability,install,installation,9602,"ll need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Versi",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9720,Deployability,install,installing,9720,"r toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about().",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9748,Deployability,install,installation,9748,"r toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about().",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10178,Deployability,install,installed,10178,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10271,Deployability,install,installed,10271,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10352,Deployability,install,installed,10352,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10685,Deployability,install,installed,10685,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10973,Deployability,update,updated,10973,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1113,Integrability,depend,dependencies,1113,"ion. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test sui",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1301,Integrability,depend,depends,1301,"Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interprete",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1783,Integrability,depend,dependent,1783,"hon environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outpu",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:1965,Integrability,depend,dependence,1965," other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that su",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2215,Integrability,depend,dependencies,2215,"e, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2498,Integrability,interface,interface,2498,"3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2586,Integrability,integrat,integrated,2586," provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channe",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3084,Integrability,depend,dependency,3084," LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have on",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3303,Integrability,depend,dependences,3303,"d text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This wi",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5402,Integrability,depend,dependencies,5402,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5498,Integrability,depend,dependencies,5498,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:5918,Integrability,depend,depend,5918,"use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operati",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:6396,Integrability,depend,dependencies,6396,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7195,Integrability,depend,depends,7195,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9893,Integrability,depend,depending,9893,"s for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo,",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10192,Integrability,depend,dependencies,10192,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10384,Integrability,depend,dependencies,10384,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10511,Integrability,message,message,10511,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10672,Integrability,depend,dependencies,10672,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2790,Modifiability,enhance,enhanced,2790,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:3594,Modifiability,config,config,3594,"ogether.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7517,Modifiability,config,configure,7517,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9081,Modifiability,variab,variable,9081,"ruser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optiona",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7132,Performance,load,load,7132,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7816,Performance,load,load,7816,"the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stand",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2692,Safety,detect,detect,2692,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:2030,Testability,test,test,2030,"s this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9571,Testability,test,test,9571,"ll need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Versi",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9652,Testability,test,tests,9652,"a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9696,Testability,test,testing,9696,"a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9821,Testability,test,testing,9821,"e following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9836,Testability,test,testing,9836,"components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:9938,Testability,test,testing,9938,"ource section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10000,Testability,test,tests,10000,"ource section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10080,Testability,test,tests,10080,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10131,Testability,test,tests,10131,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:10408,Testability,test,tests,10408,"onment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/installation.html:7445,Usability,guid,guides,7445,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
https://qutip.org/docs/4.6/py-modindex.html:1646,Deployability,update,updated,1646,". Python Module Index — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.dimensions.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.lattice.    ; qutip.matplotlib_utilities.    ; qutip.mcsolve.    ; qutip.measurement.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.operations.gates.    ; qutip.qip.qasm.    ; qutip.qip.qubits.    ; qutip.qobj.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.semidefinite.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.topology.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/py-modindex.html
https://qutip.org/docs/4.6/search.html:515,Deployability,update,updated,515,". Search — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Search. Please activate JavaScript to enable the search functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/search.html
https://qutip.org/docs/4.7/biblio.html:3470,Deployability,update,updated,3470,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
https://qutip.org/docs/4.7/biblio.html:2498,Performance,optimiz,optimization,2498," Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
https://qutip.org/docs/4.7/biblio.html:2669,Performance,optimiz,optimization,2669,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
https://qutip.org/docs/4.7/biblio.html:2703,Security,access,access,2703,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
https://qutip.org/docs/4.7/changelog.html:3331,Availability,error,error,3331,"icensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:6329,Availability,error,error,6329," match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for pass",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:9313,Availability,error,errors,9313," Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (#1275 and #1802 by NS2 Group at LPS and Simon Cross); Added a color_style option to the hinton plotting function. (#1595 by Cassandra Granade); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#1248 by Camille Le Calonnec, Jake Lishman and Eric Giguère); Removed linspace_with and view_methods from qutip.utilities. For the former it is far better to use numpy.linspace and for the later Python’s in-built help function or other tools. (#1680 by Eric Giguère); Added support for passing callable functions as e_ops to mesolve and sesolve. (#1655 by Marek Narożniak); Added the function steadystate_floquet, which returns the “effective” steadystate of a periodic driven system. (#1660 by Alberto Mercurio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_diction",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:10234,Availability,error,error,10234,"); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#1248 by Camille Le Calonnec, Jake Lishman and Eric Giguère); Removed linspace_with and view_methods from qutip.utilities. For the former it is far better to use numpy.linspace and for the later Python’s in-built help function or other tools. (#1680 by Eric Giguère); Added support for passing callable functions as e_ops to mesolve and sesolve. (#1655 by Marek Narożniak); Added the function steadystate_floquet, which returns the “effective” steadystate of a periodic driven system. (#1660 by Alberto Mercurio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_dictionaries now returns a list for idx2state. (#1604 by Johannes Feist); Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new qutip.QFunc class, instead of the qutip.qfunc function. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix ci",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:11582,Availability,toler,tolerance,11582,"unction. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1d instances and their unit cells. Previously calling them raised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the se",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:12958,Availability,error,errors,12958,"aised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:15276,Availability,fault,faults,15276,"complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:17443,Availability,error,errors,17443,"olve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitC",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:18288,Availability,fault,fault,18288,"emoved qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23650,Availability,error,errors,23650," handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:25293,Availability,error,error,25293,"ding using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests f",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:26351,Availability,toler,tolerance,26351,"uit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by Jake Lishman); Fix the trace norm being incorrectly reported as 0 for small matrices. (by Jake Lishman); Fix issues with dnorm when using CVXPy 1.1 with sparse matrices. (by Felipe Bivort Haiek); Fix segfaults in mesolve when passed a bad initial Qobj as the state. (by Jake Lishman); Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by Drew Parsons); Fix zspmv_openmp.cpp missing from the pip sdist. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29366,Availability,error,error,29366,"py 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29541,Availability,error,errors,29541,"d ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in fa",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29972,Availability,error,error,29972,"ern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:32668,Availability,error,error,32668," (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (Au",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:33358,Availability,error,error,33358,"uère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (T",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35144,Availability,avail,available,35144,"dows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed b",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35365,Availability,avail,available,35365,"ng after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) whic",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:37981,Availability,error,error,37981,"s, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling wi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38005,Availability,error,error,38005,"s, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling wi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:39200,Availability,error,error,39200," now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Ver",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40049,Availability,robust,robust,40049,"sue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x fast",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:45563,Availability,error,error,45563,"o; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAM",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:46949,Availability,avail,available,46949,"ciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True);",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47457,Availability,error,errors,47457,"ersion 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator re",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:48740,Availability,failure,failure,48740,"turing. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:51488,Availability,avail,available,51488,"spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52447,Availability,avail,available,52447,"and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity fo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:59538,Availability,toler,tolerance,59538,"o tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:1583,Deployability,release,released,1583,"022). Improvements; Bug Fixes; Documentation Improvements; Developer Changes; Version 4.6.2 (June 2, 2021). Improvements; Bug Fixes; Developer Changes; Version 4.6.1 (May 4, 2021). Improvements; Bug Fixes; Developer Changes; Version 4.6.0 (April 11, 2021). Improvements; Bug Fixes; Deprecations; Developer Changes; Version 4.5.3 (February 19, 2021). Improvements; Version 4.5.2 (July 14, 2020). Improvements; Bug Fixes; Developer Changes; Version 4.5.1 (May 15, 2020). Improvements; Bug Fixes; Deprecations; Developer Changes; Version 4.5.0 (January 31, 2020). Improvements; Bug Fixes; Version 4.4.1 (August 29, 2019). Improvements; Bug Fixes; Version 4.4.0 (July 03, 2019). Improvements; Bug Fixes; Version 4.3.0 (July 14, 2018). Improvements; Bug Fixes; Version 4.2.0 (July 28, 2017). Improvements; Bug Fixes; Version 4.1.0 (March 10, 2017). Improvements; Bug Fixes; Version 4.0.2 (January 5, 2017). Bug Fixes; Version 4.0.0 (December 22, 2016). Improvements; Bug Fixes; Version 3.2.0 (Never officially released). New Features; Improvements; Bug Fixes; Version 3.1.0 (January 1, 2015). New Features; Bug Fixes; Version 3.0.1 (Aug 5, 2014). Bug Fixes; Version 3.0.0 (July 17, 2014). New Features; Improvements; Version 2.2.0 (March 01, 2013). New Features; Bug Fixes; Version 2.1.0 (October 05, 2012). New Features; Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:2422,Deployability,release,release,2422,". Improvements; Bug Fixes; Version 4.0.2 (January 5, 2017). Bug Fixes; Version 4.0.0 (December 22, 2016). Improvements; Bug Fixes; Version 3.2.0 (Never officially released). New Features; Improvements; Bug Fixes; Version 3.1.0 (January 1, 2015). New Features; Bug Fixes; Version 3.0.1 (Aug 5, 2014). Bug Fixes; Version 3.0.0 (July 17, 2014). New Features; Improvements; Version 2.2.0 (March 01, 2013). New Features; Bug Fixes; Version 2.1.0 (October 05, 2012). New Features; Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserv",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:3783,Deployability,release,release,3783,"d by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4506,Deployability,release,release,4506,"ute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its tra",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4581,Deployability,release,release,4581,"density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account al",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:5056,Deployability,integrat,integration,5056,"gvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to buil",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:5293,Deployability,update,updates,5293,"ciear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError inste",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:6757,Deployability,release,release,6757,"uffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are includ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:7833,Deployability,release,releases,7833,"n the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:7861,Deployability,release,releases,7861,".nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting i",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:8083,Deployability,release,release,8083," rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (#1275 an",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:10898,Deployability,install,installed,10898,"urio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_dictionaries now returns a list for idx2state. (#1604 by Johannes Feist); Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new qutip.QFunc class, instead of the qutip.qfunc function. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:10923,Deployability,install,installed,10923,"ot storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_dictionaries now returns a list for idx2state. (#1604 by Johannes Feist); Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new qutip.QFunc class, instead of the qutip.qfunc function. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1d instances and their unit cells. Previously ca",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13758,Deployability,configurat,configuration,13758," Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14248,Deployability,update,updated,14248,"verted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s wer",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14348,Deployability,release,release,14348,"t. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14427,Deployability,release,release,14427,"w used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improve",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14515,Deployability,release,release,14515,"ip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destr",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:16099,Deployability,release,released,16099,"ctionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed q",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:17894,Deployability,configurat,configuration,17894," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:17926,Deployability,release,release,17926," (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:18879,Deployability,install,installation,18879,"ation in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20560,Deployability,install,installed,20560,"by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:21522,Deployability,release,release,21522,"1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian wi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22717,Deployability,release,release,22717,"rsions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cros",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22789,Deployability,release,release,22789,"ting QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22889,Deployability,install,installed,22889,"ting QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22986,Deployability,install,install,22986,"elative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install q",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23013,Deployability,install,install,23013,"elative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install q",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23034,Deployability,install,installs,23034,"elative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install q",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23135,Deployability,install,install,23135,"otlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The supp",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23406,Deployability,install,installed,23406,"on tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-suppo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23758,Deployability,release,release,23758,"s, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, incl",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23949,Deployability,release,release,23949,"l]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23983,Deployability,release,releases,23983,"l]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24019,Deployability,install,install,24019,"l]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24544,Deployability,configurat,configuration,24544,"nings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X,",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:25161,Deployability,install,installation,25161,"ed in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:25229,Deployability,install,installations,25229,"d considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:27537,Deployability,release,release,27537,"Py 1.1 with sparse matrices. (by Felipe Bivort Haiek); Fix segfaults in mesolve when passed a bad initial Qobj as the state. (by Jake Lishman); Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by Drew Parsons); Fix zspmv_openmp.cpp missing from the pip sdist. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.;",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28350,Deployability,patch,patch,28350,"eved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishma",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28356,Deployability,release,release,28356,"eved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishma",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28671,Deployability,install,installing,28671,"utable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenB",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28697,Deployability,install,installation,28697,"utable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenB",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28928,Deployability,install,installation,28928,"y list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28996,Deployability,install,installations,28996,"r specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29111,Deployability,release,release,29111,"vis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary fil",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29386,Deployability,install,installation,29386,"py 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:36677,Deployability,configurat,configuration,36677,"sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:37410,Deployability,install,installed,37410,"the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40829,Deployability,release,released,40829,"reated up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that expe",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42927,Deployability,configurat,configuration,42927,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47445,Deployability,integrat,integration,47445,"ersion 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator re",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53010,Deployability,continuous,continuous,53010,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53021,Deployability,integrat,integration,53021,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:54305,Deployability,install,installation,54305,"ns for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55644,Deployability,release,release,55644,"ename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The qu",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55951,Deployability,install,installed,55951,"s.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum obj",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:57500,Deployability,install,installation,57500,"and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEAS",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:59817,Deployability,release,release,59817,"o tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:59922,Deployability,update,updated,59922,"o tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4795,Energy Efficiency,adapt,adaptive,4795,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4908,Energy Efficiency,reduce,reduced,4908,"rough of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4975,Energy Efficiency,efficient,efficient,4975,"rough of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:15921,Energy Efficiency,power,power,15921,"s removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and th",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23824,Energy Efficiency,schedul,scheduler,23824,"s, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, incl",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24603,Energy Efficiency,schedul,scheduler,24603,"x warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refacto",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24626,Energy Efficiency,schedul,scheduler,24626,"(by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. F",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24708,Energy Efficiency,schedul,scheduling,24708,"6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:34999,Energy Efficiency,efficient,efficiently,34999," (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35320,Energy Efficiency,efficient,efficient,35320,"ed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42132,Energy Efficiency,power,power,42132,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42467,Energy Efficiency,charge,charge,42467,"xpm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more effic",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:43474,Energy Efficiency,efficient,efficient,43474,"charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decomp_curr now _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47885,Energy Efficiency,power,power,47885,"ntract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic wi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:51242,Energy Efficiency,power,power,51242,"w; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which n",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:56523,Energy Efficiency,efficient,efficient,56523," of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:5056,Integrability,integrat,integration,5056,"gvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to buil",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:5403,Integrability,depend,dependent,5403,"d); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:8408,Integrability,wrap,wrapper,8408," callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (#1275 and #1802 by NS2 Group at LPS and Simon Cross); Added a color_style option to the hinton plotting function. (#1595 by Cassandra Granade); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#12",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13485,Integrability,depend,dependabot,13485,"by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14126,Integrability,depend,dependabot,14126,"y Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19936,Integrability,depend,dependabot,19936," (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20036,Integrability,depend,dependabot,20036,"mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cros",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20138,Integrability,depend,dependabot,20138,"on solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cf",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20242,Integrability,depend,dependabot,20242,"nal references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:21626,Integrability,depend,dependent,21626,"1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian wi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22527,Integrability,depend,depending,22527,"21)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip re",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:22604,Integrability,depend,dependent,22604,"in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:23087,Integrability,depend,dependencies,23087,"elative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install q",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24403,Integrability,depend,dependencies,24403,"not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information.",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:25299,Integrability,message,message,25299,"ding using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests f",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29372,Integrability,message,messages,29372,"py 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29978,Integrability,message,messages,29978,"ern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:32126,Integrability,message,message,32126," Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot s",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:32364,Integrability,depend,dependent,32364,"ine non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:32985,Integrability,depend,depending,32985,"as Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new meth",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:34492,Integrability,depend,dependant,34492," and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35162,Integrability,depend,dependant,35162,"dows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed b",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35528,Integrability,depend,dependant,35528,"mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:36745,Integrability,depend,dependent,36745," user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:36901,Integrability,depend,dependent,36901,"it, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-no",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38105,Integrability,depend,dependent,38105," Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when input",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38194,Integrability,depend,dependent,38194,"tion values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not w",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38427,Integrability,depend,dependent,38427,"g that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38457,Integrability,rout,routines,38457,"g that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38878,Integrability,depend,dependent,38878,"operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:39139,Integrability,depend,dependence,39139,"n of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:39543,Integrability,depend,dependent,39543,"e in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codeg",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40566,Integrability,depend,dependent,40566,"ion now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build ze",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:41519,Integrability,rout,routine,41519,"er optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is n",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42034,Integrability,depend,dependent,42034,"state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42505,Integrability,depend,dependent,42505,"and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The i",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42910,Integrability,depend,depending,42910,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:45348,Integrability,depend,dependent,45348,"es. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as Qobj). fidcomp properties. uses_evo_t2end now uses_onwd_evo; uses_evo_t2targ now uses_onto_evo; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrec",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47190,Integrability,depend,dependent,47190,"d_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in co",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47445,Integrability,integrat,integration,47445,"ersion 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator re",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47554,Integrability,depend,dependent,47554,"quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories w",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47790,Integrability,depend,dependent,47790,"operator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:48151,Integrability,depend,dependent,48151,"Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equati",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:48575,Integrability,depend,dependent,48575,"an now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for w",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:49682,Integrability,depend,dependent,49682,"lure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-calculated numpy array that specifies the values of the; Qobj-coefficients for each time step.; New functions for working with different superoperator representations,; including Kraus and Chi representation.; New functions for visualizing quantum states using Qubism and Schimdt plots:; plot_qubism and plot_schmidt.; Dynamics solver now support taking argument e_ops (expectation value; operators) in dictionary form.; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been re",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:51977,Integrability,depend,dependent,51977," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52040,Integrability,depend,depend,52040," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53021,Integrability,integrat,integration,53021,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53938,Integrability,depend,dependent,53938,"rk scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.;",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55135,Integrability,depend,dependence,55135,"sed on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and para",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55562,Integrability,rout,routines,55562,"es as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55827,Integrability,depend,dependent,55827,"turns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55903,Integrability,depend,dependent,55903,"s.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum obj",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:56018,Integrability,depend,dependent,56018,"now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can h",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:56342,Integrability,depend,dependent,56342,"ermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single functi",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4795,Modifiability,adapt,adaptive,4795,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:7198,Modifiability,flexible,flexible,7198,"; Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:7704,Modifiability,enhance,enhancements,7704,". Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13758,Modifiability,config,configuration,13758," Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:17894,Modifiability,config,configuration,17894," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24544,Modifiability,config,configuration,24544,"nings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X,",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31769,Modifiability,refactor,refactored,31769,"Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propag",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:35458,Modifiability,variab,variable,35458,"w properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad di",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:36677,Modifiability,config,configuration,36677,"sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40478,Modifiability,enhance,enhancements,40478,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42927,Modifiability,config,configuration,42927,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:45627,Modifiability,variab,variables,45627,"operties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplo",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47004,Modifiability,enhance,enhanced,47004,"ult in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53272,Modifiability,variab,variable,53272,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:5808,Performance,load,loaded,5808,"daptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new so",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:7351,Performance,load,loading,7351,"24); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP an",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14633,Performance,perform,performance,14633,"ated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24478,Performance,load,loading,24478,"o the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna an",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:24858,Performance,perform,performance,24858,"eduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38615,Performance,optimiz,optimization,38615,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:38901,Performance,load,loading,38901,"operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40466,Performance,perform,performance,40466,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:41532,Performance,perform,performs,41532,"er optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is n",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47686,Performance,perform,performance,47686,"r counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:51133,Performance,concurren,concurrence,51133,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Imp",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52190,Performance,optimiz,optimized,52190,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52856,Performance,perform,performance,52856,"; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualizat",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53763,Performance,perform,performance,53763,"nstances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55484,Performance,perform,performance,55484,"es as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum obje",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:56973,Performance,optimiz,optimized,56973,"ed to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:57199,Performance,concurren,concurrence,57199,"t; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are ze",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:59015,Performance,concurren,concurrence,59015," to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. .",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:59207,Performance,load,loading,59207,"o tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:16333,Safety,sanity check,sanity checks,16333,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29804,Safety,unsafe,unsafe,29804," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:29838,Safety,unsafe,unsafe,29838," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:39074,Safety,safe,safety,39074,"n of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40377,Safety,avoid,avoid,40377," Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:43299,Safety,avoid,avoided,43299,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:45744,Safety,avoid,avoid,45744,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; St",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52283,Safety,avoid,avoiding,52283,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:2941,Testability,test,tests,2941,"Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:4699,Testability,log,logger,4699," in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of p",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:6410,Testability,test,tests,6410,"perators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13335,Testability,test,test,13335,"e, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishm",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13530,Testability,test,tests,13530,"ross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds supp",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13611,Testability,test,tests,13611,"c Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14145,Testability,test,tests,14145,"y Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:15468,Testability,test,testing,15468,"ctual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad init",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:16800,Testability,test,tested,16800,"much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions du",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:16814,Testability,test,test,16814,"much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions du",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:17535,Testability,test,tests,17535,"olve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitC",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19567,Testability,test,test,19567,"1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19751,Testability,test,tests,19751,"ixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19769,Testability,test,test,19769,"ixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20360,Testability,test,tests,20360,"6 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X impor",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20462,Testability,test,test,20462,"iP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20538,Testability,test,tests,20538,"by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:20594,Testability,test,tests,20594,"erators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a c",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:21250,Testability,test,test,21250,"ndabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:21361,Testability,test,tests,21361,"ded tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (#1797 by Simon Cross); Add building of wheels for Python 3.10 to the cibuildwheel job. (#1796 by Simon Cross). Version 4.6.2 (June 2, 2021)¶; This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in mesolve and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres.; It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:26300,Testability,test,tests,26300,"uit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by Jake Lishman); Fix the trace norm being incorrectly reported as 0 for small matrices. (by Jake Lishman); Fix issues with dnorm when using CVXPy 1.1 with sparse matrices. (by Felipe Bivort Haiek); Fix segfaults in mesolve when passed a bad initial Qobj as the state. (by Jake Lishman); Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by Drew Parsons); Fix zspmv_openmp.cpp missing from the pip sdist. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:27783,Testability,test,tests,27783,"st. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add supp",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:27805,Testability,test,testing,27805,"st. (by Christoph Gohlke); Fix correlation functions throwing away imaginary components. (by Asier Galicia Martinez); Fix QubitCircuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add supp",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:28034,Testability,test,testing,28034," Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:30650,Testability,test,tests,30650,"x issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:30742,Testability,test,testing,30742," of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke d",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31124,Testability,test,testing,31124,"ction for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nath",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31182,Testability,test,testing,31182,"2 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31224,Testability,test,test,31224,"2 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31614,Testability,test,tests,31614,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31631,Testability,test,tests,31631,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31640,Testability,test,testing,31640,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:31677,Testability,benchmark,benchmarking,31677,"ac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checkin",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:33021,Testability,test,tests,33021,"as Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new meth",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:40175,Testability,test,tests,40175,"sue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:44934,Testability,test,tests,44934,"g_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decomp_curr now _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as Qobj). fidcomp properties. uses_evo_t2end now uses_onwd_evo; uses_evo_t2targ now uses_onto_evo; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:45285,Testability,test,tests,45285,"w _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as Qobj). fidcomp properties. uses_evo_t2end now uses_onwd_evo; uses_evo_t2targ now uses_onto_evo; set_phase_option function now property phase_option. propcomp properties. grad_exact (now read only). propcomp functions. compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:46893,Testability,log,logging,46893,"y set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady sta",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:46929,Testability,log,logging,46929,"nd Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now su",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53033,Testability,test,tests,53033,"back functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to th",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:53382,Testability,log,logarithmic,53382,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:57476,Testability,test,tests,57476,"and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying the installation.; Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012)¶. Bug Fixes¶. Fixed bug pointed out by Brendan Abolins.; Qobj.tr() returns zero-dim ndarray instead of float or complex.; Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011)¶. New Functions¶. Allow custom naming of Bloch sphere. Bug Fixes¶. Fixed text alignment issues in AboutBox.; Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEAS",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:11969,Usability,simpl,simple,11969,"Live. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1d instances and their unit cells. Previously calling them raised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor gra",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:12981,Usability,guid,guide,12981,"aised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:13206,Usability,guid,guide,13206,"ot displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14219,Usability,guid,guidelines,14219,"verted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s wer",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:14286,Usability,guid,guidelines,14286,"verted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s wer",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:15557,Usability,simpl,simple,15557," for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:18577,Usability,guid,guide,18577,"ts for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). D",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:18679,Usability,guid,guide,18679,"sly when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Gig",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19339,Usability,guid,guide,19339,"ims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#166",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:19436,Usability,guid,guide,19436,"uère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:27904,Usability,simpl,simplify,27904,"cuit.add_circuit() for SWAP gate. (by Canoming); Fix the broken LaTeX image conversion. (by Jake Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:42182,Usability,simpl,simplified,42182,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:47146,Usability,progress bar,progress bars,47146,"rnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-depende",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:52801,Usability,simpl,simplified,52801," for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner c",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:55339,Usability,progress bar,progress bar,55339,"ctions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent argumen",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/changelog.html:56151,Usability,simpl,simplifying,56151,"time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012)¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method in",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
https://qutip.org/docs/4.7/contributors.html:2179,Deployability,update,updated,2179,"ght and Licensing. QuTiP: Quantum Toolbox in Python. »; Developers. Developers¶. Lead Developers¶. Alex Pitchford; Nathan Shammah; Shahnawaz Ahmed; Neill Lambert; Eric Giguère; Boxi Li; Jake Lishman; Simon Cross. Past Lead Developers¶. Robert Johansson (RIKEN); Paul Nation (Korea University); Chris Granade; Arne Grimsmo. Contributors¶. Note; Anyone is welcome to contribute to QuTiP.; If you are interested in helping, please let us know!. Abhisek Upadhyaya; Adriaan; Alexander Pitchford; Alexios-xi; Amit; Anubhav Vardhan; Arie van Deursen; Arne Grimsmo; Arne Hamann; Asier Galicia Martinez; Ben Bartlett; Ben Criger; Ben Jones; Bo Yang; Boxi Li; Canoming; Christoph Gohlke; Christopher Granade; Craig Gidney; Denis Vasilyev; Dominic Meiser; Drew Parsons; Eric Giguère; Eric Hontz; Felipe Bivort Haiek; Florestan Ziem; Gilbert Shih; Harry Adams; Ivan Carvalho; Jake Lishman; Jevon Longdell; Johannes Feist; Jonas Hoersch; Jonas Neergaard-Nielsen; Jonathan A. Gross; Julian Iacoponi; Kevin Fischer; Laurence Stant; Louis Tessler; Lucas Verney; Marco David; Marek Narozniak; Markus Baden; Martín Sande; Mateo Laguna; Matthew O’Brien; Michael Goerz; Michael V. DePalatis; Moritz Oberhauser; Nathan Shammah; Neill Lambert; Nicolas Quesada; Nikolas Tezak; Nithin Ramu; Paul Nation; Peter Kirton; Philipp Schindler; Piotr Migdal; Rajiv-B; Ray Ganardi; Reinier Heeres; Richard Brierley; Robert Johansson; Sam Griffiths; Samesh Lakhotia; Sebastian Krämer; Shahnawaz Ahmed; Sidhant Saraogi; Simon Cross; Simon Humpohl; Simon Whalen; Stefan Krastanov; Tarun Raheja; Thomas Walker; Viacheslav Ostroukh; Vlad Negnevitsky; Wojciech Rzadkowski; Xiaodong Qi; Xiaoliang Wu; Yariv Yanay; YouWei Zhao; alex; eliegenois; essence-of-waqf; fhenneke; gecrooks; jakobjakobson13; maij; sbisw002; yuri@FreeBSD; Élie Gouzien. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/contributors.html
https://qutip.org/docs/4.7/copyright-1.html:829,Availability,avail,available,829,". Copyright and Licensing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. QuTiP: Quantum Toolbox in Python. »; Copyright and Licensing. Copyright and Licensing¶; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text¶; The canonical form of this license is available at https://creativecommons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived fro",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:3099,Availability,avail,available,3099,"ce of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5736,Availability,avail,available,5736," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:15222,Deployability,release,release,15222,"IAL,; INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES.; Termination. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License.; Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:19648,Deployability,update,updated,19648,"ht law includes additional rights not granted; under this License, such additional rights are deemed to be included in; the License; this License is not intended to restrict the license of any; rights under applicable law. License Terms for Source Code of QuTiP and Code Samples¶; Copyright (c) 2011 to 2021 inclusive, QuTiP developers and contributors.; All rights reserved.; Redistribution and use in source and binary forms, with or without modification,; are permitted provided that the following conditions are met:. Redistributions of source code must retain the above copyright notice, this; list of conditions and the following disclaimer.; Redistributions in binary form must reproduce the above copyright notice,; this list of conditions and the following disclaimer in the documentation; and/or other materials provided with the distribution.; Neither the name of the copyright holder nor the names of its contributors; may be used to endorse or promote products derived from this software without; specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR; ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON; ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1704,Energy Efficiency,adapt,adaptation,1704,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1866,Energy Efficiency,adapt,adaptations,1866,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1946,Energy Efficiency,adapt,adapted,1946,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:6495,Energy Efficiency,reduce,reduce,6495,"municate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:16561,Energy Efficiency,charge,charged,16561,"cense), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and enforceable.; No term or provision of this License shall be deemed waived and no breach; consented to unless such waiver or consent shall be in writing and signed; by the party to be charged with such waiver or consent.; This License constitutes the entire agreement between the parties with; respect to the Work licensed here. There are no understandings,; agreements or representations with respect to the Work not specified; here. Licensor shall not be bound by any additional provisions that may; appear in any communication from You. This License may not be modified; without the mutual written agreement of the Licensor and You.; The rights granted under, and the subject matter referenced, in this; License were drafted utilizing the terminology of the Berne Convention; for the Protection of Literary and Artistic Works (as amended on; September 28, 1979), the Rome Convention of 1961, the WIPO Copyright; Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and; the Universal Copyright Convention (as revised on July 24, 1971). These; rights and subject matter take effect in the relevant ju",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:2231,Integrability,synchroniz,synchronization,2231,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1704,Modifiability,adapt,adaptation,1704,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1866,Modifiability,adapt,adaptations,1866,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1946,Modifiability,adapt,adapted,1946,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:1825,Performance,perform,performance,1825,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:2201,Performance,perform,performance,2201,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:2485,Performance,perform,performances,2485,"; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; an",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:3603,Performance,perform,performance,3603,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:3741,Performance,perform,perform,3741,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:3916,Performance,perform,performance,3916,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:4973,Performance,perform,performance,4973,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5101,Performance,perform,performed,5101,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5134,Performance,perform,performer,5134,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5534,Performance,perform,perform,5534," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5714,Performance,perform,performances,5714," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5892,Performance,perform,perform,5892," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5991,Performance,perform,performances,5991," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:6046,Performance,perform,performance,6046," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:6365,Performance,perform,performance,6365,"nse; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherw",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:2146,Safety,avoid,avoidance,2146,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:7677,Safety,avoid,avoidance,7677,"ht law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,; Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all media and form",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:12115,Safety,avoid,avoidance,12115,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:5812,Security,access,access,5812," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:12338,Testability,assert,assert,12338,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:13380,Testability,assert,assert,13380,"imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will waive or not assert, as appropriate, this Section, to the; fullest extent permitted by the applicable national law, to enable You to; reasonably exercise Your right under Section 3(b) of this License (right; to make Adaptations) but not otherwise. Representations, Warranties and Disclaimer; UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR; OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND; CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING,; WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A; PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER; DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT; DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED; WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN; NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright-1.html:7256,Usability,clear,clearly,7256,"eans to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing s",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
https://qutip.org/docs/4.7/copyright.html:829,Availability,avail,available,829,". Copyright and Licensing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. QuTiP: Quantum Toolbox in Python. »; Copyright and Licensing. Copyright and Licensing¶; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text¶; The canonical form of this license is available at https://creativecommons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived fro",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:3099,Availability,avail,available,3099,"ce of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5736,Availability,avail,available,5736," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:15222,Deployability,release,release,15222,"IAL,; INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES.; Termination. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License.; Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:19648,Deployability,update,updated,19648,"ht law includes additional rights not granted; under this License, such additional rights are deemed to be included in; the License; this License is not intended to restrict the license of any; rights under applicable law. License Terms for Source Code of QuTiP and Code Samples¶; Copyright (c) 2011 to 2021 inclusive, QuTiP developers and contributors.; All rights reserved.; Redistribution and use in source and binary forms, with or without modification,; are permitted provided that the following conditions are met:. Redistributions of source code must retain the above copyright notice, this; list of conditions and the following disclaimer.; Redistributions in binary form must reproduce the above copyright notice,; this list of conditions and the following disclaimer in the documentation; and/or other materials provided with the distribution.; Neither the name of the copyright holder nor the names of its contributors; may be used to endorse or promote products derived from this software without; specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR; ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON; ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1704,Energy Efficiency,adapt,adaptation,1704,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1866,Energy Efficiency,adapt,adaptations,1866,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1946,Energy Efficiency,adapt,adapted,1946,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:6495,Energy Efficiency,reduce,reduce,6495,"municate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:16561,Energy Efficiency,charge,charged,16561,"cense), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and enforceable.; No term or provision of this License shall be deemed waived and no breach; consented to unless such waiver or consent shall be in writing and signed; by the party to be charged with such waiver or consent.; This License constitutes the entire agreement between the parties with; respect to the Work licensed here. There are no understandings,; agreements or representations with respect to the Work not specified; here. Licensor shall not be bound by any additional provisions that may; appear in any communication from You. This License may not be modified; without the mutual written agreement of the Licensor and You.; The rights granted under, and the subject matter referenced, in this; License were drafted utilizing the terminology of the Berne Convention; for the Protection of Literary and Artistic Works (as amended on; September 28, 1979), the Rome Convention of 1961, the WIPO Copyright; Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and; the Universal Copyright Convention (as revised on July 24, 1971). These; rights and subject matter take effect in the relevant ju",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:2231,Integrability,synchroniz,synchronization,2231,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1704,Modifiability,adapt,adaptation,1704,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1866,Modifiability,adapt,adaptations,1866,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1946,Modifiability,adapt,adapted,1946,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:1825,Performance,perform,performance,1825,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:2201,Performance,perform,performance,2201,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:2485,Performance,perform,performances,2485,"; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; an",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:3603,Performance,perform,performance,3603,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:3741,Performance,perform,perform,3741,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:3916,Performance,perform,performance,3916,"ctual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:4973,Performance,perform,performance,4973,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5101,Performance,perform,performed,5101,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5134,Performance,perform,performer,5134,"s, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recit",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5534,Performance,perform,perform,5534," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5714,Performance,perform,performances,5714," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5892,Performance,perform,perform,5892," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5991,Performance,perform,performances,5991," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:6046,Performance,perform,performance,6046," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:6365,Performance,perform,performance,6365,"nse; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherw",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:2146,Safety,avoid,avoidance,2146,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:7677,Safety,avoid,avoidance,7677,"ht law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,; Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all media and form",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:12115,Safety,avoid,avoidance,12115,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:5812,Security,access,access,5812," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:12338,Testability,assert,assert,12338,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:13380,Testability,assert,assert,13380,"imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will waive or not assert, as appropriate, this Section, to the; fullest extent permitted by the applicable national law, to enable You to; reasonably exercise Your right under Section 3(b) of this License (right; to make Adaptations) but not otherwise. Representations, Warranties and Disclaimer; UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR; OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND; CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING,; WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A; PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER; DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT; DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED; WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN; NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/copyright.html:7256,Usability,clear,clearly,7256,"eans to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing s",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
https://qutip.org/docs/4.7/frontmatter.html:591,Availability,avail,available,591,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:1708,Availability,down,downloaded,1708,"P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the ",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:3679,Availability,avail,available,3679,"tical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantu",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:6093,Availability,error,error,6093," a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:955,Deployability,release,release,955,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4881,Deployability,release,release,4881,"tions.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:7226,Deployability,update,updated,7226," Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:3059,Energy Efficiency,efficient,efficiently,3059,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4315,Integrability,depend,dependence,4315,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum informat",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4363,Integrability,depend,dependent,4363,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4953,Integrability,depend,depend,4953,"e generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for workin",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:5441,Integrability,interface,interfaces,5441,"tially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantu",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:5755,Integrability,interface,interface,5755,"ox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instruct",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:6271,Integrability,protocol,protocols,6271," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29,",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:2158,Modifiability,coupling,coupling,2158,"nd the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:2296,Modifiability,coupling,coupling,2296,"This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:5033,Modifiability,plugin,plugin,5033,"are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomo",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:5065,Modifiability,coupling,coupling,5065,"are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomo",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:2251,Performance,perform,performed,2251,"This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4452,Performance,perform,performance,4452,"ted Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4063,Testability,test,tested,4063,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a comput",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:6266,Testability,test,test,6266," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29,",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:498,Usability,guid,guide,498,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:4614,Usability,learn,learning,4614," framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQ",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/frontmatter.html:6787,Usability,guid,guide,6787," Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
https://qutip.org/docs/4.7/genindex.html:35824,Deployability,update,update,35824,ule qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_list() (QobjEvo method). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.operations.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). types (BathExponent attribute). U. UnderDampedBath (class in qutip.nonmarkov.heom). unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity() (in module qutip.metrics). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:37089,Deployability,update,updated,37089,"trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). types (BathExponent attribute). U. UnderDampedBath (class in qutip.nonmarkov.heom). unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity() (in module qutip.metrics). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). X. x() (Lattice1d method). Z. zero_ket() (in module qutip.states). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:3613,Energy Efficiency,charge,charge,3613,_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). BosonicBath (class in qutip.nonmarkov.heom). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (Bloch3d method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:30452,Energy Efficiency,schedul,schedule,30452,timizer method). (OptimizerBFGS method). (OptimizerCrabFmin method). (OptimizerLBFGSB method). run_state() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). run_statistics() (CircuitSimulator method). (QubitCircuit method). rx() (in module qutip.qip.operations.gates). rx_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). ry() (in module qutip.qip.operations.gates). rz() (in module qutip.qip.operations.gates). rz_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). S. save() (Bloch method). (Bloch3d method). save_amps() (Dynamics method). save_coeff() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). save_qasm() (in module qutip.qip.qasm). scattering_probability() (in module qutip.scattering). schedule() (Scheduler method). Scheduler (class in qutip.qip.compiler). serial_map() (in module qutip.parallel). sesolve() (in module qutip.sesolve). set_all_tlist() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). set_label_convention() (Bloch method). set_optim_var_vals() (PulseGenCrab method). set_phase_option() (FidCompUnitary method). set_total_time() (Stats method). set_up_ops() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). set_up_params() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). shape() (in module qutip.qobj). show() (Bloch method). (Bloch3d method). sigmam() (in module qutip.operators). sigmap() (in module qutip.operators). sigmax() (in module qutip.operators). sigmay() (in module qutip.operators). sigmaz() (in module qutip,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:5583,Modifiability,config,configure,5583,erty). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:5542,Performance,concurren,concurrence,5542,y). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:20702,Performance,optimiz,optimizer,20702,_vec() (QobjEvo method). N. n_thermal() (in module qutip.utilities). next() (HierarchyADOs method). Noise (class in qutip.qip.noise). norm() (Qobj method). normalize_gradient_PSU() (FidCompUnitary method). normalize_gradient_SU() (FidCompUnitary method). normalize_PSU() (FidCompUnitary method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). ,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:20989,Performance,optimiz,optimizer,20989,method). normalize_SU() (FidCompUnitary method). num() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stocha,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:21039,Performance,optimiz,optimizer,21039,um() (in module qutip.operators). num_ctrls() (Dynamics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:21089,Performance,optimiz,optimizer,21089,amics property). (DynamicsUnitary property). num_dicke_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:21143,Performance,optimiz,optimizer,21143,_ladders() (in module qutip.piqs). num_dicke_states() (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:21195,Performance,optimiz,optimizer,21195,) (in module qutip.piqs). num_tls() (in module qutip.piqs). O. ode2es() (in module qutip.essolve). onto_evo() (Dynamics property). onwd_evo() (Dynamics property). operator_at_cells() (Lattice1d method). operator_between_cells() (Lattice1d method). operator_to_vector() (in module qutip.superoperator). opt_pulse_crab() (in module qutip.control.pulseoptim). opt_pulse_crab_unitary() (in module qutip.control.pulseoptim). OptimDump (class in qutip.control.dump). OptimIterSummary (class in qutip.control.optimizer). optimize_circuit() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). optimize_pulse() (in module qutip.control.pulseoptim). optimize_pulse_unitary() (in module qutip.control.pulseoptim). Optimizer (class in qutip.control.optimizer). OptimizerBFGS (class in qutip.control.optimizer). OptimizerCrab (class in qutip.control.optimizer). OptimizerCrabFmin (class in qutip.control.optimizer). OptimizerLBFGSB (class in qutip.control.optimizer). OptimResult (class in qutip.control.optimresult). Options (class in qutip.solver). OptPulseProcessor (class in qutip.qip.device). orbital() (in module qutip.orbital). outfieldcorr() (MemoryCascade method). outfieldpropagator() (MemoryCascade method). overlap() (Qobj method). P. parallel_map() (in module qutip.ipynbtools). (in module qutip.parallel). parfor() (in module qutip.ipynbtools). (in module qutip.parallel). partial_transpose() (in module qutip.partial_transpose). permute() (Qobj method). (QobjEvo method). phase() (in module qutip.operators). phase_application() (Dynamics property). phase_basis() (in module qutip.states). phasegate() (in module qutip.qip.operations.gates). photocurrent_mesolve() (in module qutip.stochastic). photocurrent_sesolve() (in module qutip.stochastic). Pim (class in qutip.piqs). pisolve() (Dicke method). plot_berry_curvature() (in module qutip.topology). plot_dispersion() (Lattice1d method). plot_energy_levels() (in module qutip.visualization). plo,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/genindex.html:4132,Usability,clear,clear,4132,brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (Bloch3d method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). co,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
https://qutip.org/docs/4.7/index.html:5494,Deployability,release,release,5494,"r Changes; Improvements; Bug Fixes; Documentation Improvements; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Bug Fixes; Improvements; Bug Fixes; New Features; Improvements; Bug Fixes; New Features; Bug Fixes; Bug Fixes; New Features; Improvements; New Features; Bug Fixes; New Features; Bug Fixes; New Features; Bug Fixes; New Functions; Bug Fixes; Bug Fixes; New Functions; Bug Fixes; New Functions; Bug Fixes. Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; Completed Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Setting Up The Release Branch; Build Release Distribution and Deploy; Getting the Built Documentation; Making a Release on GitHub; Website; Conda Forge. Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
https://qutip.org/docs/4.7/index.html:6254,Deployability,update,updated,6254,"r Changes; Improvements; Bug Fixes; Documentation Improvements; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Bug Fixes; Improvements; Bug Fixes; New Features; Improvements; Bug Fixes; New Features; Bug Fixes; Bug Fixes; New Features; Improvements; New Features; Bug Fixes; New Features; Bug Fixes; New Features; Bug Fixes; New Functions; Bug Fixes; Bug Fixes; New Functions; Bug Fixes; New Functions; Bug Fixes. Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; Completed Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Setting Up The Release Branch; Build Release Distribution and Deploy; Getting the Built Documentation; Making a Release on GitHub; Website; Conda Forge. Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
https://qutip.org/docs/4.7/index.html:1632,Integrability,depend,dependent,1632,"a; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis pro",MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
https://qutip.org/docs/4.7/index.html:2826,Performance,load,loading,2826,nic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
https://qutip.org/docs/4.7/index.html:2861,Performance,load,loading,2861,nic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
https://qutip.org/docs/4.7/installation.html:3224,Availability,avail,available,3224,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4670,Availability,avail,available,4670,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4689,Availability,down,download,4689,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4764,Availability,avail,available,4764,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5365,Availability,avail,available,5365,"-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6313,Availability,error,error-prone,6313,"d QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library suppo",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7080,Availability,avail,available,7080,"_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7948,Availability,avail,available,7948,"the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stand",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8639,Availability,down,download,8639,"al folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10243,Availability,failure,failures,10243,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10255,Availability,error,errors,10255,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:713,Deployability,install,install,713,"﻿. Installation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence.",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:753,Deployability,install,install,753,"﻿. Installation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence.",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1182,Deployability,install,installation,1182,"nments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packag",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1216,Deployability,install,installation,1216,"nments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packag",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2611,Deployability,integrat,integrated,2611," provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channe",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3031,Deployability,install,install,3031," LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have on",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3248,Deployability,install,install,3248,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3276,Deployability,install,install,3276,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3301,Deployability,install,install,3301,"d text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This wi",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3412,Deployability,install,install,3412,"runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You act",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3575,Deployability,install,install,3575,"ogether.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3949,Deployability,install,installed,3949,"s that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4030,Deployability,install,install,4030,"s that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4069,Deployability,install,installed,4069,".; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more contro",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4144,Deployability,install,install,4144,".; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more contro",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4350,Deployability,install,install,4350,"es. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package availabl",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4506,Deployability,install,install,4506,"nda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4561,Deployability,install,install,4561,"nda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4648,Deployability,release,releases,4648,"later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command inst",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:4856,Deployability,release,release,4856,"packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5041,Deployability,install,install,5041,"vironment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in th",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5409,Deployability,install,install,5409,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5461,Deployability,install,installation,5461,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5495,Deployability,install,install,5495,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5582,Deployability,install,install,5582,"pyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5634,Deployability,install,install,5634,"pyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5702,Deployability,install,installs,5702,"e code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5800,Deployability,install,install,5800,"e code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6283,Deployability,install,installation,6283,"d QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library suppo",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6434,Deployability,install,installed,6434,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6569,Deployability,release,release,6569,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6608,Deployability,install,installed,6608,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6628,Deployability,install,install,6628,"o qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6808,Deployability,install,installed,6808,"pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6932,Deployability,install,installations,6932,"rce code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Pyth",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6984,Deployability,install,install,6984,"erating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without n",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7041,Deployability,install,install,7041,"hing like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Not",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7053,Deployability,install,install,7053,"_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7113,Deployability,install,install,7113,"file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7708,Deployability,install,install,7708,"ng 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual St",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8193,Deployability,install,install,8193," suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Stud",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8304,Deployability,install,installing,8304," suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Stud",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8451,Deployability,install,install,8451,"o external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to in",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8821,Deployability,install,installing,8821," the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:8998,Deployability,install,installation,8998," needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it i",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9244,Deployability,install,installation,9244,"ruser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optiona",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9432,Deployability,install,install,9432," install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9627,Deployability,install,installation,9627,"ll need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Versi",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9745,Deployability,install,installing,9745,"r toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about().",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9773,Deployability,install,installation,9773,"r toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about().",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10203,Deployability,install,installed,10203,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10296,Deployability,install,installed,10296,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10377,Deployability,install,installed,10377,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10710,Deployability,install,installed,10710,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10889,Deployability,update,updated,10889,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1138,Integrability,depend,dependencies,1138,"ox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test sui",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1326,Integrability,depend,depends,1326,"n; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interprete",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1808,Integrability,depend,dependent,1808,"hon environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outpu",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:1990,Integrability,depend,dependence,1990," other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that su",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2240,Integrability,depend,dependencies,2240,"e, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2523,Integrability,interface,interface,2523,"3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2611,Integrability,integrat,integrated,2611," provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channe",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3109,Integrability,depend,dependency,3109," LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have on",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3328,Integrability,depend,dependences,3328,"d text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This wi",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5427,Integrability,depend,dependencies,5427,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5523,Integrability,depend,dependencies,5523,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:5943,Integrability,depend,depend,5943,"use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operati",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:6421,Integrability,depend,dependencies,6421,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7220,Integrability,depend,depends,7220,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9918,Integrability,depend,depending,9918,"s for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 20",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10217,Integrability,depend,dependencies,10217,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10409,Integrability,depend,dependencies,10409,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10536,Integrability,message,message,10536,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10697,Integrability,depend,dependencies,10697,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2815,Modifiability,enhance,enhanced,2815,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:3619,Modifiability,config,config,3619,"ogether.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7542,Modifiability,config,configure,7542,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9106,Modifiability,variab,variable,9106,"ruser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optiona",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7157,Performance,load,load,7157,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7841,Performance,load,load,7841,"the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stand",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2717,Safety,detect,detect,2717,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:2055,Testability,test,test,2055,"s this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9596,Testability,test,test,9596,"ll need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Versi",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9677,Testability,test,tests,9677,"a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9721,Testability,test,testing,9721,"a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9846,Testability,test,testing,9846,"e following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP de",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9861,Testability,test,testing,9861,"components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers an",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:9963,Testability,test,testing,9963,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10025,Testability,test,tests,10025,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10105,Testability,test,tests,10105,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10156,Testability,test,tests,10156,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:10433,Testability,test,tests,10433,"low the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the pytest testing library.; After installing QuTiP, leave the installation directory, run Python (or IPython), and call:; import qutip.testing; qutip.testing.run(). This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked “xfail” in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the QuTiP Discussion Board or the GitHub issues page and post a message detailing your particular issue. Checking Version Information¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:; import qutip; qutip.about(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/installation.html:7470,Usability,guid,guides,7470,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
https://qutip.org/docs/4.7/py-modindex.html:1586,Deployability,update,updated,1586,". Python Module Index — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.dimensions.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.krylovsolve.    ; qutip.lattice.    ; qutip.matplotlib_utilities.    ; qutip.mcsolve.    ; qutip.measurement.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.operations.gates.    ; qutip.qip.qasm.    ; qutip.qip.qubits.    ; qutip.qobj.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.semidefinite.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.topology.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/py-modindex.html
https://qutip.org/docs/4.7/search.html:431,Deployability,update,updated,431,". Search — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Search. Please activate JavaScript to enable the search functionality.; . © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/search.html
https://qutip.org/docs/3.0.0/apidoc/apidoc.html:230,Deployability,install,installation,230,". API documentation — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Ten",MatchSource.WIKI,docs/3.0.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/apidoc.html
https://qutip.org/docs/3.0.0/apidoc/apidoc.html:2793,Deployability,update,updated,2793,"Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/apidoc.html
https://qutip.org/docs/3.0.0/apidoc/apidoc.html:2419,Integrability,depend,dependent,2419,"Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/apidoc.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:4854,Availability,toler,tolerance,4854,"a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:5651,Availability,toler,tolerance,5651,"h, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that cont",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:7658,Availability,avail,available,7658,"aluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError :. Quantum operator is not square. extract_states(states_inds, normalize=False)¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experi",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:9212,Availability,toler,tolerance,9212," in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Paramet",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:10574,Availability,toler,tolerance,10574,"rements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError :. Can only calculate overlap between a bra and ket quantum objects. permute(order)¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. i :. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Return",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:12380,Availability,toler,tolerance,12380,"qobj. Permuted quantum object. i :. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper: qobj :. Quantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sqrtm(sparse=False, tol=0, maxiter=100000)¶; Sqrt of a quantum operator.; Operator must be square. Parameters:sparse : bool. Use sparse eigenvalue/vector solver. tol : float. Tolerance used by sparse solver (0 = machine precision). maxiter : int. Maximum number of iterations used by sparse solver. Returns:oper: qobj :. Matrix square root of operator. Raises:TypeError :. Quantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=None)¶; Removes small elements from the quantum object. Parameters:atol : float. Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns:oper: qobj :. Quantum object with small elements removed. tr()¶; Trace of a quantum object. Returns:trace: float :. Returns real if operator is Hermitian, returns complex; otherwise. trans()¶; Transposed operator. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does no",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:23886,Availability,toler,tolerance,23886," of output image. Default is ‘png’. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:23926,Availability,toler,tolerance,23926," : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback sign",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:220,Deployability,install,installation,220,". Classes — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. « API documentatio... Functions ». Classes¶. Qobj¶. class Qobj(inpt=None, dims=, [[][]]shape=, []type=None, isherm=None, fast=False, superrep=None)¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operati",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:24012,Deployability,integrat,integrator,24012,"lot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filename; str; Name for compiled Cython file. store_final_state; bool {False, True}; Wheth",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:33184,Deployability,update,update,33184,"the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. update(state)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum p",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:33661,Deployability,update,update,33661,"given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. update(state)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:33853,Deployability,update,update,33853,"nerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. update(state)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: List :. Specific qubits for applying gates. arg_value: Float :. Argument value(phi). arg_label: String :. Label for gate representation. add_circuit(qc, start=0)¶; Adds a block of a qubit circuit to the mai",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:40990,Deployability,update,updated,40990,"rix obtained from the physical implementation. class SpinChain(N, correct_global_phase=True, sx=None, sz=None, sxsy=None)¶; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system.; Methods. adjacent_gates(qc, setup='linear')¶; Method to resolve 2 qubit gates with non-adjacent control/s or target/s; in terms of gates with adjacent interactions for linear/circular spin; chain system. Parameters:qc: QubitCircuit :. The circular spin chain circuit to be resolved. setup: Boolean :. Linear of Circular spin chain setup. Returns:qc: QubitCircuit :. Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. class LinearSpinChain(N, correct_global_phase=True, sx=None, sz=None, sxsy=None)¶; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a linear; formation. It is a sub-class of SpinChain.; Methods. class CircularSpinChain(N, correct_global_phase=True, sx=None, sz=None, sxsy=None)¶; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a circular; formation. It is a sub-class of SpinChain.; Methods. class DispersivecQED(N, correct_global_phase=True, Nres=None, deltamax=None, epsmax=None, w0=None, eps=None, delta=None, g=None)¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system.; Methods. dispersive_gate_correction(qc1, rwa=True)¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:qc: Qobj :. The circular spin chain circuit to be resolved. rwa: Boolean :. Specify if RWA is used or not. Returns:qc: QubitCircuit :. Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:31425,Energy Efficiency,reduce,reduced,31425,"ess_bar; qutip.ui.BaseProgressBar; Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=, []xlabels=[])¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : mat",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:31825,Energy Efficiency,reduce,reduced-dimensionality,31825," class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:6798,Integrability,depend,dependent,6798,"of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectiv",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:7124,Integrability,depend,dependent,7124,"normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError :. Q",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:7200,Integrability,depend,dependent,7200,"d. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError :. Quantum operator is not square. extract_states(states_inds, normalize=False)¶; Qobj w",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:7310,Integrability,depend,dependent,7310,"/ False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError :. Quantum operator is not square. extract_states(states_inds, normalize=False)¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:13734,Integrability,depend,dependent,13734,"or. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter: int :. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array(, []dtype=float64), s=array(, []dtype=float64))¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; ndarray; Array of amplitudes for exponential series. rates; ndarray; Array of rates for exponential series. dims; list; Dimensions of exponential series components. shape; list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)¶; Returns a tidier version of exponential series. value(tlist)¶; Evaluates an exponential series at the times listed in tlist. Parameters:tlist : ndarray. Times at which to evaluate exponential s",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:24012,Integrability,integrat,integrator,24012,"lot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filename; str; Name for compiled Cython file. store_final_state; bool {False, True}; Wheth",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:32237,Integrability,depend,depending,32237,"ys that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Metho",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:34454,Modifiability,variab,variable,34454,"tcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: List :. Specific qubits for applying gates. arg_value: Float :. Argument value(phi). arg_label: String :. Label for gate representation. add_circuit(qc, start=0)¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc: QubitCircuit :. The circuit block to be added to the main circuit. start: Integer :. The qubit on which the first gate is applied. add_gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Adds a gate with specified parameters to the circuit. Parameters:name: String :. Gate name. targets: List :. Gate targets. controls: List :. Gate controls. arg_value: Float :. Argument value(phi). arg_label: String :. Label f",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:3596,Performance,perform,performing,3596,"; str; Representation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:4924,Performance,perform,performed,4924," maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:5721,Performance,perform,performed,5721," eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:9282,Performance,perform,performed,9282,"ld be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:10644,Performance,perform,performed,10644,"x element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError :. Can only calculate overlap between a bra and ket quantum objects. permute(order)¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. i :. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper: qobj :. Quantum object representing partial trace with selected components; remaini",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:13506,Performance,perform,performed,13506," elements removed. tr()¶; Trace of a quantum object. Returns:trace: float :. Returns real if operator is Hermitian, returns complex; otherwise. trans()¶; Transposed operator. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not affect other norms. tol : float. Tolerance used by sparse eigensolver. maxiter: int :. Number of maximum iterations performed by sparse eigensolver. Returns:oper : qobj. Normalized quantum object. eseries¶. class eseries(q=array(, []dtype=float64), s=array(, []dtype=float64))¶; Class representation of an exponential-series expansion of; time-dependent quantum objects.; Attributes. ampl; ndarray; Array of amplitudes for exponential series. rates; ndarray; Array of rates for exponential series. dims; list; Dimensions of exponential series components. shape; list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:wlist : array_like. Array/list of frequenies. Returns:val_list : ndarray. Values of exponential series at frequencies in wlist. tidyup(*args)¶; Returns a tidier versi",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:16255,Usability,simpl,simple,16255,"ha; float {0.1}; Sets transparency of Bloch sphere frame. frame_color; str {‘gray’}; Color of sphere wireframe. frame_width; int {1}; Width of wireframe. point_color; list {[“b”,”r”,”g”,”#CC6600”]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (‘b’). point_marker; list {[“o”,”s”,”d”,”^”]}; List of point marker shapes to cycle through. point_size; list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alpha; float {0.2}; Transparency of Bloch sphere itself. sphere_color; str {‘#FFDDDD’}; Color of Bloch sphere. figsize; list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_color; list {[“g”,”#CC6600”,”b”,”r”]}; List of vector colors to cycle through. vector_width; int {5}; Width of displayed vectors. vector_style; str {‘-|>’, ‘simple’, ‘fancy’, ‘’}; Vector arrowhead style (from matplotlib’s arrow style). vector_mutation; int {20}; Width of vectors arrowhead. view; list {[-60,30]}; Azimuthal and Elevation viewing angles. xlabel; list {[“$x$”,”“]}; List of strings corresponding to +x and -x axes labels, respectively. xlpos; list {[1.1,-1.1]}; Positions of +x and -x labels respectively. ylabel; list {[“$y$”,”“]}; List of strings corresponding to +y and -y axes labels, respectively. ylpos; list {[1.2,-1.2]}; Positions of +y and -y labels respectively. zlabel; list {[r’$left|0right>$’,r’$left|1right>$’]}; List of strings corresponding to +z and -z axes labels, respectively. zlpos; list {[1.2,-1.2]}; Positions of +z and -z labels respectively. Methods. add_annotation(state_or_vector, text, **kwargs)¶; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters:state_or_vector : Qobj/array/list/tuple. Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/unicode. Annot",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:18108,Usability,clear,clear,18108,"arameters:state_or_vector : Qobj/array/list/tuple. Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/unicode. Annotation text.; You can use LaTeX, but remember to use raw string; e.g. r”$langle x rangle$”; or escape backslashes; e.g. “$\langle x \rangle$”. **kwargs : :. Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(points, meth='s')¶; Add a list of data points to bloch sphere. Parameters:points : array/list. Collection of data points. meth : str {‘s’, ‘m’, ‘l’}. Type of points to plot, use ‘m’ for multicolored, ‘l’ for points; connected with a line. add_states(state, kind='vector')¶; Add a state vector Qobj to Bloch sphere. Parameters:state : qobj. Input state vector. kind : str {‘vector’,’point’}. Type of object to plot. add_vectors(vectors)¶; Add a list of vectors to Bloch sphere. Parameters:vectors : array/list. Array with vectors of unit length or smaller. clear()¶; Resets Bloch sphere data sets to empty. make_sphere()¶; Plots Bloch sphere and data sets. render(fig=None, axes=None)¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None)¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:name : str. Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. format : str. Format of output image. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. set_label_convention(convention)¶; Set x, y and z labels according to one of conventions. Parameters:convention : string. One of the following:; - “original”; - “xyz”; - “sx sy sz”; - “01”; - “polarization jones”; - “polarization jones letters”. see also: http://en.wikipedia.org/wiki/Jones_calculus. “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters.",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:19325,Usability,simpl,simple,19325,"ure and axes. save(name=None, format='png', dirc=None)¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:name : str. Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. format : str. Format of output image. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. set_label_convention(convention)¶; Set x, y and z labels according to one of conventions. Parameters:convention : string. One of the following:; - “original”; - “xyz”; - “sx sy sz”; - “01”; - “polarization jones”; - “polarization jones letters”. see also: http://en.wikipedia.org/wiki/Jones_calculus. “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()¶; Display Bloch sphere and corresponding data sets. vector_mutation = None¶; Sets the width of the vectors arrowhead. vector_style = None¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width = None¶; Width of Bloch vectors, default = 5. class Bloch3d(fig=None)¶; Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem).; Notes; The use of mayavi for 3D rendering of the Bloch sphere comes with; a few limitations: I) You can not embed a Bloch3d figure into a; matplotlib window. II) The use of LaTex is not supported by the; mayavi rendering engine. Therefore all labels must be defined using; standard text. Of course you can post-process the generated figures; later to add LaTeX using other software if needed.; Attributes. fig; instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere. font_color; str {‘black’}; Color of font used for Bloch sphere labels. font_scale; float {0.08}; Scale for font used for Bloch sphere labels. frame; bool {True}; Draw f",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:22375,Usability,clear,clear,22375," axes labels, respectively. xlpos; list {[1.07,-1.07]}; Positions of +x and -x labels respectively. ylabel; list {[‘|y>’, ‘’]}; List of strings corresponding to +y and -y axes labels, respectively. ylpos; list {[1.07,-1.07]}; Positions of +y and -y labels respectively. zlabel; list {[‘|0>’, ‘|1>’]}; List of strings corresponding to +z and -z axes labels, respectively. zlpos; list {[1.07,-1.07]}; Positions of +z and -z labels respectively. Methods. add_points(points, meth='s')¶; Add a list of data points to bloch sphere. Parameters:points : array/list. Collection of data points. meth : str {‘s’,’m’}. Type of points to plot, use ‘m’ for multicolored. add_states(state, kind='vector')¶; Add a state vector Qobj to Bloch sphere. Parameters:state : qobj. Input state vector. kind : str {‘vector’,’point’}. Type of object to plot. add_vectors(vectors)¶; Add a list of vectors to Bloch sphere. Parameters:vectors : array/list. Array with vectors of unit length or smaller. clear()¶; Resets the Bloch sphere data sets to empty. make_sphere()¶; Plots Bloch sphere and data sets. plot_points()¶; Plots points on the Bloch sphere. plot_vectors()¶; Plots vectors on the Bloch sphere. save(name=None, format='png', dirc=None)¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:name : str. Name of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. format : str. Format of output image. Default is ‘png’. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/classes.html:30462,Usability,progress bar,progress bar,30462,"me of the solver method to use for solving the stochastic; equations. Valid values are: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘milstein’, ‘fast-milstein’, ‘platen’. method; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution; string (‘normal’, ‘poission’); The name of the distribution used for the stochastic increments. store_measurements; bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise; array; Vector specifying the noise. normalize; bool (default True); Whether or not to normalize the wave function during the evolution. options; qutip.solver.Options; Generic solver options. progress_bar; qutip.ui.BaseProgressBar; Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=, []xlabels=[])¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution.",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:18303,Availability,error,error,18303," Returns:oper : qutip.qobj.Qobj. Squeezing operator. phase(N, phi0=0)¶; Single-mode Pegg-Barnett phase operator. Parameters:N : int. Number of basis states in Hilbert space. phi0 : float. Reference phase. Returns:oper : qobj. Phase operator with respect to reference phase. Notes; The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25343,Availability,mask,mask,25343," 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. Expectation Values¶. expect(oper, state)¶; Calculates the expectation value for operator(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25427,Availability,mask,mask,25427," 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. Expectation Values¶. expect(oper, state)¶; Calculates the expectation value for operator(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25563,Availability,mask,mask,25563,"or(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25660,Availability,mask,mask,25660,"/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25826,Availability,mask,mask,25826,"alue. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:25849,Availability,mask,mask,25849,"; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. V",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:75001,Availability,error,error,75001,"h options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:222,Deployability,install,installation,222,". Functions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Sch",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:19966,Deployability,configurat,configuration,19966,"eters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix repr",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:20055,Deployability,configurat,configurations,20055,"ault is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvill",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:29280,Deployability,continuous,continuous,29280,"n & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. tol : float. Tolerance used by sparse eigensolver, if used. (0=Machine precision). sparse : {False, True}. Use sparse eigensolver. Returns:tracedist : float. Trace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> tracedist(x,y); 0.9705143161472971. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:basis : list of qutip.qobj.Qobj. List of operators that defines the basis for the correlation matrix. rho : qutip.qobj.Qobj. Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat: *array* :. A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \la",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:33727,Deployability,integrat,integrating,33727,". Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:35477,Deployability,integrat,integrating,35477,"on values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:37765,Deployability,integrat,integrator,37765,"t.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with option",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:38102,Deployability,integrat,integrator,38102,"ent for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:70967,Deployability,install,installing,70967,"‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’NATURAL’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘NATURAL and ‘COLAMD’.; If not using RCM then this is set to ‘COLAMD’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:111116,Deployability,update,updated,111116," in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/array. list or array of qobjs representing commuting Hermitian; operators. Returns:eigs : tuple. Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:45728,Energy Efficiency,power,power,45728,". List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:47588,Energy Efficiency,power,power,47588,"ions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops, e_ops=, []spectra_cb=, []T=None, args={}, options=<qutip.solver.Options instance at 0x2ac686946518>, floquet_basis=True, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the time",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:48044,Energy Efficiency,energy,energy,48044,"rue, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sor",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:66893,Energy Efficiency,power,power,66893," wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:spectrum: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2ac686929cf8>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of coll",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:67249,Energy Efficiency,power,power,67249,", b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2ac686929cf8>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (‘me’, ‘mc’, ‘es’). Returns:g1, G2: tuble of *array* :. The normalized and unnormalized first-order coherence function. coherence_function_g2(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:69762,Energy Efficiency,power,power,69762," \(\tau\). c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (currently only ‘me’). Returns:g2, G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’, ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace co",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:70013,Energy Efficiency,power,power,70013,"G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’, ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:70027,Energy Efficiency,power,power,70027,"G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’, ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:72437,Energy Efficiency,reduce,reduced,72437," bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no preconditioner is; given and use_precond=True, then one is generated automatically. fill_factor : float, optional, default=10. ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default=1e-3. ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default=None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default=’smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:76661,Energy Efficiency,efficient,efficient,76661,"lues representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘iterative’, ‘laguerre’, ‘fft’}. Select method ‘iterative’, ‘laguerre’, or ‘fft’, where ‘iterative’ uses; an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘fft’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). parfor : bool {False, True}. Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:W : array. Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array. FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabe",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:80060,Energy Efficiency,energy,energy,80060," histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:80127,Energy Efficiency,energy,energy,80127,"ars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:80174,Energy Efficiency,energy,energy,80174,"lize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shi",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:80493,Energy Efficiency,energy,energy,80493,"two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shift : float. Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -5e-3). invert : bool. Invert the color scheme for negative values so that smaller negative; values have darker color. Returns:R",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:80559,Energy Efficiency,energy,energy,80559,": a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shift : float. Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -5e-3). invert : bool. Invert the color scheme for negative values so that smaller negative; values have darker color. Returns:Returns a Matplotlib colormap instance for use in plotting. :. Notes; The ‘shi",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:105901,Energy Efficiency,energy,energy,105901,"Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : st",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:105973,Energy Efficiency,energy,energy,105973,"Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:106190,Energy Efficiency,energy,energy,106190,"amples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:108484,Energy Efficiency,schedul,scheduling,108484,"thon notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Retu",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:108833,Energy Efficiency,schedul,scheduled,108833," and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; argume",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:2103,Integrability,depend,dependent,2103,"ettings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. « Classes. Change Log ». Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:33727,Integrability,integrat,integrating,33727,". Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:34184,Integrability,depend,dependent,34184,"x. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:34509,Integrability,depend,dependent,34509,"ressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:35477,Integrability,integrat,integrating,35477,"on values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:35976,Integrability,depend,dependent,35976,"n and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:36020,Integrability,depend,dependent,36020,"n and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:36546,Integrability,depend,dependent,36546,"the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using meso",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:37160,Integrability,depend,dependent,37160,"ime; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. s",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:37765,Integrability,integrat,integrator,37765,"t.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with option",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:38102,Integrability,integrat,integrator,38102,"ent for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:38248,Integrability,depend,dependent,38248,"n evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=Non",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:38658,Integrability,depend,dependent,38658,"ion: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:39577,Integrability,depend,dependent,39577,"nary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Par",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:39683,Integrability,depend,dependent,39683,"nary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Par",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:39806,Integrability,depend,dependent,39806,"or the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : a",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:39892,Integrability,depend,dependent,39892,"or the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : a",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:39982,Integrability,depend,dependent,39982,"or the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given in place of operators for; which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : a",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:40110,Integrability,depend,dependent,40110,"ate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=<qutip.solver.Options instance at 0x2ac685b5cd40>)¶; Monte-Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:41025,Integrability,depend,dependent,41025,"stant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H=[H0,[H1,H1_coeff]]. c_op_list=[C0,[C1,C1_coeff]]. args={'a':A,'w':W}. or in String (Cython) format we could write:; H=[H0,[H1,'sin(w*t)']]. c_op_list=[C0,[C1,'exp(-a*t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) mat",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:41510,Integrability,depend,dependence,41510,"t)']]. args={'a':A,'w':W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. Returns:results : Result. Object storing all results from simulation. mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory beco",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:43798,Integrability,depend,dependent,43798,"nglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns:results : Result. Object storing all results from simulation. Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:H : qobj/function_type. System Hamiltonian. rho0 : qutip.qobj. Initial state density matrix. tlist : list/array. list of times for \(t\). c_op_list : list of qutip.qobj. list of qutip.qobj collapse operators. e_ops : list of qutip.qobj. list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array : array. Expectation values of wavefunctions/density matrices for the; times specified in tlist. .. note:: This solver does not support time-dependent Hamiltonians. :. ode2es(L, rho0)¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=, []spectra_cb=, []args={}, options=<qutip.solver.Options instance at 0x2ac6869466c8>)¶; Solve the dynamics for the system using the Bloch-Redfeild master equation. Note; This solver does not currently support time-dependent Hamiltonian or; collapse operators. Parameters:H : qutip.qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.qobj` :. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:44472,Integrability,depend,dependent,44472,"op_list : list of qutip.qobj. list of qutip.qobj collapse operators. e_ops : list of qutip.qobj. list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array : array. Expectation values of wavefunctions/density matrices for the; times specified in tlist. .. note:: This solver does not support time-dependent Hamiltonians. :. ode2es(L, rho0)¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=, []spectra_cb=, []args={}, options=<qutip.solver.Options instance at 0x2ac6869466c8>)¶; Solve the dynamics for the system using the Bloch-Redfeild master equation. Note; This solver does not currently support time-dependent Hamiltonian or; collapse operators. Parameters:H : qutip.qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.qobj` :. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the syst",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:44948,Integrability,depend,dependent,44948,"r) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=, []spectra_cb=, []args={}, options=<qutip.solver.Options instance at 0x2ac6869466c8>)¶; Solve the dynamics for the system using the Bloch-Redfeild master equation. Note; This solver does not currently support time-dependent Hamiltonian or; collapse operators. Parameters:H : qutip.qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.qobj` :. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Re",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:47702,Integrability,depend,dependence,47702,"ip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops, e_ops=, []spectra_cb=, []T=None, args={}, options=<qutip.solver.Options instance at 0x2ac686946518>, floquet_basis=True, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floque",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:47877,Integrability,depend,dependent,47877,"_ops, e_ops=, []spectra_cb=, []T=None, args={}, options=<qutip.solver.Options instance at 0x2ac686946518>, floquet_basis=True, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:49097,Integrability,depend,dependent,49097,"le, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with v",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:49225,Integrability,depend,dependence,49225,"re = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:49391,Integrability,depend,dependent,49391,"er. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spannin",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50035,Integrability,depend,dependent,50035,"es or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50163,Integrability,depend,dependence,50163," required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50716,Integrability,depend,dependent,50716,"ulate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Param",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50775,Integrability,depend,dependence,50775,"ing the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:51128,Integrability,depend,dependence,51128,"iod T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args :",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:51392,Integrability,depend,dependence,51392,"g the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:51957,Integrability,depend,dependent,51957,"e in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposi",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:52016,Integrability,depend,dependence,52016,"kup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction ps",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:52708,Integrability,depend,dependent,52708,"s. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:52767,Integrability,depend,dependence,52767,"initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:53596,Integrability,depend,dependent,53596,"function. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:53971,Integrability,depend,dependence,53971,"nergies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:54860,Integrability,depend,depending,54860,"ch time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: :class:`qutip.solver.SolverResult` :. An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs)¶; Solve stochasti",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:55926,Integrability,depend,depending,55926,"obj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: :class:`qutip.solver.SolverResult` :. An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs)¶; Solve stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. psi0 : qutip.Qobj. Initial state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj. Single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: :class:`qutip.solver.SolverResult` :. An instance of the class qutip.solver.SolverResult. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix. times : l",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:73613,Integrability,depend,dependent,73613,"t_thresh : float, optional, default=None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default=’smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:73880,Integrability,depend,dependent,73880,"ncomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automa",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:74292,Integrability,depend,dependent,74292," U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:74677,Integrability,depend,dependent,74677,"ike. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the spec",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:75052,Integrability,depend,dependent,75052,")\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinat",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:103200,Integrability,rout,routines,103200,"qft(N=1)¶; Quantum Fourier Transform operator on N qubits. Parameters:N : int. Number of qubits. Returns:QFT: qobj :. Quantum Fourier transform operator. qft_steps(N=1, swapping=True)¶; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters:N: int :. Number of qubits. swap: boolean :. Flag indicating sequence of swap gates to be applied at the end or not. Returns:U_step_list: list of qobj :. List of Hadamard and controlled rotation gates implementing QFT. qft_gate_sequence(N=1, swapping=True)¶; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters:N: int :. Number of qubits. swap: boolean :. Flag indicating sequence of swap gates to be applied at the end or not. Returns:qc: instance of QubitCircuit :. Gate sequence of Hadamard and controlled rotation gates implementing; QFT. Utilitiy Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:A : csc_matrix, csr_matrix. Input graph in CSC or CSR matrix format. start : int. Staring node for BFS traversal. Returns:order : array. Order in which nodes are traversed from starting node. levels : array. Level of the nodes in the order that they are traversed. graph_degree(A)¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:A : qobj, csr_matrix, csc_matrix. Input quantum object or csr_matrix. Returns:degree : array. Array of integers giving the degree for each node (row). Utility Functions¶; This module contains utility functions t",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:109273,Integrability,depend,dependencies,109273,"sk function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:109594,Integrability,depend,dependencies,109594,"which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the o",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:19966,Modifiability,config,configuration,19966,"eters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix repr",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:20055,Modifiability,config,configurations,20055,"ault is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvill",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:29291,Modifiability,variab,variable,29291,"n & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. tol : float. Tolerance used by sparse eigensolver, if used. (0=Machine precision). sparse : {False, True}. Use sparse eigensolver. Returns:tracedist : float. Trace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> tracedist(x,y); 0.9705143161472971. Continous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:basis : list of qutip.qobj.Qobj. List of operators that defines the basis for the correlation matrix. rho : qutip.qobj.Qobj. Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:corr_mat: *array* :. A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \la",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:35609,Modifiability,evolve,evolved,35609,"ver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3c10>)¶; Master equation evolution of a density matrix for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_op_list), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; Time-dependent operators; For problems with time-dependent problems H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a numpy ar",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:45474,Modifiability,coupling,coupling,45474,"the Bloch-Redfeild master equation. Note; This solver does not currently support time-dependent Hamiltonian or; collapse operators. Parameters:H : qutip.qobj. System Hamiltonian. rho0 / psi0: :class:`qutip.qobj` :. Initial density matrix or state vector (ket). tlist : list / array. List of times for \(t\). a_ops : list of qutip.qobj. List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:49157,Modifiability,variab,variables,49157,"ture is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-de",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50095,Modifiability,variab,variables,50095,"ent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:50841,Modifiability,variab,variables,50841,"t of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:52082,Modifiability,variab,variables,52082,"modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:52833,Modifiability,variab,variables,52833,"et energies. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : list. A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A list of initial Floquet modes (for time \(t=0\)). f_energies : array. The Floquet energies. f_coeff : array. The coefficients for Floquet decomposition of the initial wavefunction. t : float. The time for which to evaluate the Floquet states. H : qutip.qobj. System Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Returns:output : qutip.qobj. The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is e",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:54037,Modifiability,variab,variables,54037,"ate) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:f_states : list of qutip.qobj (kets). A list of Floquet modes. f_energies : array. The Floquet energies. psi : qutip.qobj. The wavefunction to decompose in the Floquet state basis. Returns:output : array. The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=, []T=None, args={}, Tsteps=100)¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:H : qutip.qobj.Qobj. System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj. Initial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / arr",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:75134,Modifiability,config,config,75134,"applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘f",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:105470,Modifiability,coupling,coupling,105470,"r\). Parameters:w : float or array. Frequency of the oscillator. w_th : float. The temperature in units of frequency (or the same units as w). Returns:n_avg : float or array. Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. linspace_with(start, stop, num=50, elems=[])¶; Return an array of numbers sampled over specified interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:109673,Modifiability,variab,variable,109673,"iew(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and Mat",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:110003,Modifiability,variab,variables,110003,"duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/array. list or array of qobjs representing commuting Hermitian; operators. Returns:eigs : tuple. Tuple of arrays representing eigvecs and eigvals of quantum objects; cor",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:110063,Modifiability,variab,variables,110063,"value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved: :; num_cpus : int. Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:result : list. A list with length equal to number of input parameters; containing the output from func. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/array. list or array of qobjs representing commuting Hermitian; operators. Returns:eigs : tuple. Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Back to top. © Copyright 2011 and later, P.D. Nation, J",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:26202,Performance,concurren,concurrence,26202," : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual i",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:26235,Performance,concurren,concurrence,26235," : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual i",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:54662,Performance,optimiz,optimizing,54662,"ial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arg",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:54689,Performance,perform,performance,54689,"ial state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. Dictionary with variables required to evaluate H. Tsteps : integer. The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:output : qutip.solver.Result. An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains experimental functions for solving stochastic schrodinger; and master equations. The API should not be considered stable, and is subject; to change when we work more on optimizing this module for performance and; features.; Todo:. parallelize. smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs)¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arg",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:71067,Performance,perform,perform,71067,"rue. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’NATURAL’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘NATURAL and ‘COLAMD’.; If not using RCM then this is set to ‘COLAMD’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no preconditioner is; given and use_precond=True, then one is generated automatically. fill_factor : float",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:107100,Performance,load,loaded,107100," name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. Th",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:107850,Performance,load,load-balanced,107850,"itten data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, name='qutip_data')¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:data : instance/array_like. Input Python object to be stored. filename : str. Name of output data file. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; clus",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:108543,Performance,load,load-balanced,108543,"show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing v",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:21190,Safety,avoid,avoids,21190," \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj :. Superoperator formed from input quantum object. lindblad_dissipator(a, b=None, data_only=False)¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters:a : qobj. Left part of collapse operator. b : qobj (optiona",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:87550,Security,access,access,87550,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options: ‘pairs’ - typical coordinates, ‘pairs_skewed’ - for; ferromagnetic/antriferromagnetic plots, ‘before_after’ - related to; Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:26791,Testability,log,logarithm,26791,"ho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Para",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:27562,Testability,log,logarithm,27562,"s the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Parameters:rho : qobj. Density matrix. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:entropy : float. Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x=fock_dm(5,3); >>> y",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:27849,Testability,log,logarithm,27849,"Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Parameters:rho : qobj. Density matrix. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:entropy : float. Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:32900,Testability,log,logarithmic,32900,"ix of operators. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None)¶; Calculate the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:a1 : qutip.qobj.Qobj. Field operator for mode 1. a2 : qutip.qobj.Qobj. Field operator for mode 2. R : array. The quadrature correlation matrix. rho : qutip.qobj.Qobj. Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:33196,Testability,log,logarithmic,33196,"^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:a1 : qutip.qobj.Qobj. Field operator for mode 1. a2 : qutip.qobj.Qobj. Field operator for mode 2. R : array. The quadrature correlation matrix. rho : qutip.qobj.Qobj. Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial densi",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:42295,Usability,simpl,simply,42295,"<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix. calc_entropy : boolean. If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns:results : Result. Object storing all results from simulation. Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:75108,Usability,clear,clears,75108,"applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘f",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/apidoc/functions.html:108951,Usability,progress bar,progress bar,108951,"ameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Parameters:func : function_type. A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:1910,Availability,avail,available,1910," Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:9730,Availability,error,error,9730,"e needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> q * x; TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Exponential; Q.expm(); Matrix exponential of operator. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matrix Element; Q.matrix_element(bra,ket); Matrix element <bra|Q|ket>. Norm; Q.norm(); Returns L2 norm for states,; trace norm for operators. Pa",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:248,Deployability,install,installation,248,". Basic Operations on Quantum Objects — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:1757,Deployability,install,installation,1757,"elation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:13805,Deployability,update,updated,13805,"0.14620658 0.14614018 0.10374209 0.05810197 0.035077 ]; [ 0.08826704 0.08822695 0.06263061 0.035077 0.0211765 ]]. In [29]: coherent_dm(5, 1).diag(); Out[29]: array([ 0.36791117, 0.36757705, 0.18523331, 0.05810197, 0.0211765 ]). In [30]: coherent_dm(5, 1).full(); Out[30]: ; array([[ 0.36791117+0.j, 0.36774407+0.j, 0.26105441+0.j, 0.14620658+0.j,; 0.08826704+0.j],; [ 0.36774407+0.j, 0.36757705+0.j, 0.26093584+0.j, 0.14614018+0.j,; 0.08822695+0.j],; [ 0.26105441+0.j, 0.26093584+0.j, 0.18523331+0.j, 0.10374209+0.j,; 0.06263061+0.j],; [ 0.14620658+0.j, 0.14614018+0.j, 0.10374209+0.j, 0.05810197+0.j,; 0.03507700+0.j],; [ 0.08826704+0.j, 0.08822695+0.j, 0.06263061+0.j, 0.03507700+0.j,; 0.02117650+0.j]]). In [31]: coherent_dm(5, 1).norm(); Out[31]: 1.0000000000000002. In [32]: coherent_dm(5, 1).sqrtm(); Out[32]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0.36791119 +0.00000000e+00j 0.36774406 +0.00000000e+00j; 0.26105440 +0.00000000e+00j 0.14620658 +0.00000000e+00j; 0.08826704 +0.00000000e+00j]; [ 0.36774406 +0.00000000e+00j 0.36757705 +4.97355349e-13j; 0.26093584 -4.95568446e-12j 0.14614018 -4.38433154e-12j; 0.08822695 +1.98468419e-11j]; [ 0.26105440 +0.00000000e+00j 0.26093584 -4.95568446e-12j; 0.18523332 +4.93787964e-11j 0.10374209 +4.36857948e-11j; 0.06263061 -1.97755360e-10j]; [ 0.14620658 +0.00000000e+00j 0.14614018 -4.38433154e-12j; 0.10374209 +4.36857948e-11j 0.05810197 +3.86491532e-11j; 0.03507701 -1.74955663e-10j]; [ 0.08826704 +0.00000000e+00j 0.08822695 +1.98468419e-11j; 0.06263061 -1.97755360e-10j 0.03507701 -1.74955663e-10j; 0.02117650 +7.91983303e-10j]]. In [33]: coherent_dm(5, 1).tr(); Out[33]: 1.0. In [34]: (basis(4, 2) + basis(4, 1)).unit(); Out[34]: ; Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket; Qobj data =; [[ 0. ]; [ 0.70710678]; [ 0.70710678]; [ 0. ]]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:8555,Integrability,message,message,8555,"f a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:2586,Modifiability,variab,variables,2586,"ction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank `Qobj` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:1784,Performance,load,load,1784," and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:1889,Performance,load,load,1889," Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:2254,Performance,load,loaded,2254,"on 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank `Qobj` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. H",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:7393,Security,access,accessed,7393,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:8679,Security,access,access,8679,"on, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompa",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:9803,Testability,log,logic,9803,"ns on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> q * x; TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Exponential; Q.expm(); Matrix exponential of operator. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matrix Element; Q.matrix_element(bra,ket); Matrix element <bra|Q|ket>. Norm; Q.norm(); Returns L2 norm for states,; trace norm for operators. Partial Trace; Q.ptrace(sel); Partial trace returning components; selected using ‘sel’ parameter. Permute; Q.permu",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-basics.html:4289,Usability,clear,clear,4289," objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 2.]; [ 3.]; [ 4.]; [ 5.]]. In [5]: x = array([[1, 2, 3, 4, 5]]). In [6]: Qobj(x); Out[6]: ; Quantum object: dims = [[1], [5]], shape = [1, 5], type = bra; Qobj data =; [[ 1. 2. 3. 4. 5.]]. In [7]: r = np.random.rand(4, 4). In [8]: Qobj(r); Out[8]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0.2809971 0.97255146 0.71730328 0.00521497]; [ 0.21618564 0.59474207 0.0897929 0.67690883]; [ 0.64495791 0.98742768 0.2892686 0.29891427]; [ 0.19186651 0.4029137 0.22928811 0.10506436]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m) / fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alph",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:7700,Availability,down,down,7700," [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [40]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [41]: zp=zeros(20). In [42]: pnts=[xp,yp,zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz=zeros(20). In [46]: yz=[sin(th) for th in linspace(0,pi,20)]. In [47]: zz=[cos(th) for th in linspace(0,pi,20)]. In [48]: b.add_points([xz,yz,zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:241,Deployability,install,installation,241,". Plotting on the Bloch Sphere — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:16148,Deployability,install,installing,16148," * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:16312,Deployability,install,install,16312,"t angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:17094,Deployability,update,updated,17094,"t angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:14934,Modifiability,evolve,evolve,14934,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly sim",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:2527,Performance,load,load,2527,"Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multipl",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:2609,Performance,load,loads,2609,"ons. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:12817,Security,access,accessed,12817," ‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:2699,Usability,simpl,simply,2699,"ctly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:3555,Usability,clear,clear,3555,":; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc (default=cwd); output directory; Saves Bloch sphere to a file. show();  ; Generates Bloch sphere with given data. As an example, we can add a single data point:; In [6]: pnt=[1/sqrt(3),1/sqrt(3),1/sqrt(3)]. In [7]: b.add_points(pnt). In [8]: b.show(). and then a single vector:; In [9]: vec=[0,1,0]. In [10]: b.add_vectors(vec). In [11]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [12]: up=basis(2,0). In [13]: b.add_states(up). In [14]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; >>> b=Bloch(); >>> pnt=[1/sqrt(3),1/sqrt(3),1/sqrt(3)]; >>> b.add_points(pnt); >>> #b.show(); >>> vec=[0,1,0]",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:4995,Usability,clear,clear,4995,"ctors(vec). In [11]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [12]: up=basis(2,0). In [13]: b.add_states(up). In [14]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; >>> b=Bloch(); >>> pnt=[1/sqrt(3),1/sqrt(3),1/sqrt(3)]; >>> b.add_points(pnt); >>> #b.show(); >>> vec=[0,1,0]; >>> b.add_vectors(vec); >>> #b.show(); >>> up=basis(2,0); >>> b.add_states(up); >>> b.show(). where we have commented out the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [15]: b.clear(). In [16]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [17]: x=(basis(2,0)+(1+0j)*basis(2,1)).unit(). In [18]: y=(basis(2,0)+(0+1j)*basis(2,1)).unit(). In [19]: z=(basis(2,0)+(0+0j)*basis(2,1)).unit(). In [20]: b.add_states([x,y,z]). In [21]: b.show(). a similar method works for adding vectors:; In [22]: b.clear(). In [23]: vec=[[1,0,0],[0,1,0],[0,0,1]]. In [24]: b.add_vectors(vec). In [25]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [27]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [28]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [29]: zp=zeros(20). In [30]: pnts=[xp,yp,zp]. In [31]: b.add_points(pnts). In [32]: b.show(). Notice that, in contrast to states or v",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:5108,Usability,clear,clear,5108,"\left|\rm up \right>\) state:; In [12]: up=basis(2,0). In [13]: b.add_states(up). In [14]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; >>> b=Bloch(); >>> pnt=[1/sqrt(3),1/sqrt(3),1/sqrt(3)]; >>> b.add_points(pnt); >>> #b.show(); >>> vec=[0,1,0]; >>> b.add_vectors(vec); >>> #b.show(); >>> up=basis(2,0); >>> b.add_states(up); >>> b.show(). where we have commented out the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [15]: b.clear(). In [16]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [17]: x=(basis(2,0)+(1+0j)*basis(2,1)).unit(). In [18]: y=(basis(2,0)+(0+1j)*basis(2,1)).unit(). In [19]: z=(basis(2,0)+(0+0j)*basis(2,1)).unit(). In [20]: b.add_states([x,y,z]). In [21]: b.show(). a similar method works for adding vectors:; In [22]: b.clear(). In [23]: vec=[[1,0,0],[0,1,0],[0,0,1]]. In [24]: b.add_vectors(vec). In [25]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [27]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [28]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [29]: zp=zeros(20). In [30]: pnts=[xp,yp,zp]. In [31]: b.add_points(pnts). In [32]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because a",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:5496,Usability,clear,clear,5496,"3),1/sqrt(3),1/sqrt(3)]; >>> b.add_points(pnt); >>> #b.show(); >>> vec=[0,1,0]; >>> b.add_vectors(vec); >>> #b.show(); >>> up=basis(2,0); >>> b.add_states(up); >>> b.show(). where we have commented out the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [15]: b.clear(). In [16]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [17]: x=(basis(2,0)+(1+0j)*basis(2,1)).unit(). In [18]: y=(basis(2,0)+(0+1j)*basis(2,1)).unit(). In [19]: z=(basis(2,0)+(0+0j)*basis(2,1)).unit(). In [20]: b.add_states([x,y,z]). In [21]: b.show(). a similar method works for adding vectors:; In [22]: b.clear(). In [23]: vec=[[1,0,0],[0,1,0],[0,0,1]]. In [24]: b.add_vectors(vec). In [25]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [27]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [28]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [29]: zp=zeros(20). In [30]: pnts=[xp,yp,zp]. In [31]: b.add_points(pnts). In [32]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [33]: xz=zeros(20)",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:5778,Usability,clear,clear,5778,"e above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [15]: b.clear(). In [16]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [17]: x=(basis(2,0)+(1+0j)*basis(2,1)).unit(). In [18]: y=(basis(2,0)+(0+1j)*basis(2,1)).unit(). In [19]: z=(basis(2,0)+(0+0j)*basis(2,1)).unit(). In [20]: b.add_states([x,y,z]). In [21]: b.show(). a similar method works for adding vectors:; In [22]: b.clear(). In [23]: vec=[[1,0,0],[0,1,0],[0,0,1]]. In [24]: b.add_vectors(vec). In [25]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [27]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [28]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [29]: zp=zeros(20). In [30]: pnts=[xp,yp,zp]. In [31]: b.add_points(pnts). In [32]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [33]: xz=zeros(20). In [34]: yz=[sin(th) for th in linspace(0,pi,20)]. In [35]: zz=[cos(th) for th in linspace(0,pi,20)]. In [36]: b.add_points([xz,yz,zz]). In [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:7182,Usability,clear,clear,7182,"pond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [33]: xz=zeros(20). In [34]: yz=[sin(th) for th in linspace(0,pi,20)]. In [35]: zz=[cos(th) for th in linspace(0,pi,20)]. In [36]: b.add_points([xz,yz,zz]). In [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [40]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [41]: zp=zeros(20). In [42]: pnts=[xp,yp,zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz=zeros(20). In [46]: yz=[sin(th) for th in linspace(0,pi,20)]. In [47]: zz=[cos(th) for th in linspace(0,pi,20)]. In [48]: b.add_points([xz,yz,zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloc",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:13743,Usability,clear,clear,13743,"xis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperatur",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:15748,Usability,clear,clear,15748," c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:15987,Usability,simpl,simple,15987,"put = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting mov",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-bloch.html:16608,Usability,clear,clear,16608,"t angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:3356,Availability,avail,available,3356,"= {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\end{split}\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is show in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a ",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:244,Deployability,install,installation,244,"﻿. Two-time correlation functions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is t",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:13047,Deployability,update,updated,13047,"^{(2)}(\tau) = 1\), for a thermal state \(g^{(2)}(\tau=0) = 2\) and it decreases as a function of time (bunched photons, they tend to appear together), and for a Fock state with \(n\) photons \(g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1\) and it increases with time (anti-bunched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_4op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(\tau)D(0)\right>\) (four operators, one delay-time vector).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and fock state.; import pylab as plt; from qutip import *; from scipy import *. N = 25; taus = linspace(0, 25.0, 200); a = destroy(N); H = 2 * pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag()]. states = [{'state': coherent_dm(N, sqrt(2.0)), 'label': ""coherent state""},; {'state': thermal_dm(N, 2.0), 'label': ""thermal state""},; {'state': fock_dm(N, 2), 'label': ""Fock state""}]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = correlation_4op_1t(H, rho0, taus, c_ops, a.dag(), a.dag(), a, a); g2 = G2 / (n[0] * n). ax.plot(taus, real(g2), label=state['label']). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). (Source code, png, hires.png, pdf). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5269,Energy Efficiency,power,power,5269,"orrelation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5884,Energy Efficiency,power,power,5884,"; corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:6983,Energy Efficiency,power,power,6983,"= 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum_ss, which internally uses essolve; # to solve for the dynamics; wlist2 = linspace(0.25, 1.75, 200) * 2 * pi; spec2 = spectrum_ss(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*pi), wlist2[-1]/(2*pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t_1\) ",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:1861,Modifiability,evolve,evolved,1861,"um States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:6094,Modifiability,coupling,coupling,6094,")\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum_ss, which internally uses essolve; # to solve for the dynamics; wlist2 = linspace(0.25, 1",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5583,Performance,perform,performs,5583,"leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to mak",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
https://qutip.org/docs/3.0.0/guide/guide-dynamics.html:255,Deployability,install,installation,255,". Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-d",MatchSource.WIKI,docs/3.0.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html
https://qutip.org/docs/3.0.0/guide/guide-dynamics.html:2558,Deployability,update,updated,2558," Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html
https://qutip.org/docs/3.0.0/guide/guide-dynamics.html:2000,Integrability,depend,dependent,2000," Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:245,Deployability,install,installation,245,". An Overview of the Eseries Class — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that t",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:8797,Deployability,update,updated,8797,"2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[-1. 0.]; [ 0. 1.]]; Exponent #1 = 0j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. or by evaluating it and arbitrary points in time (here at 0.0 and 1.0):; In [21]: es.value([0.0, 1.0]); Out[21]: ; array([ Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 0. 1.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.63212056 0. ]; [ 0. 0.36787944]]], dtype=object). and the expectation value of the exponential series can be calculated using the qutip.expect function:; In [22]: es_expect = expect(sigmaz(), es). The result es_expect is now an exponential series with c-numbers as amplitudes, which easily can be evaluated at arbitrary times:; In [23]: es_expect.value([0.0, 1.0, 2.0, 3.0]); Out[23]: array([-1. , 0.26424112, 0.72932943, 0.90042586]). In [24]: times = linspace(0.0, 10.0, 100). In [25]: sz_expect = es_expect.value(times). In [26]: from pylab import *. In [27]: plot(times, sz_expect, lw=2);. In [28]: xlabel(""Time"", fontsize=16); ....: ylabel(""Expectation value of sigma-z"", fontsize=16);; ....: . In [30]: title(""The expectation value of the $\sigma_{z}$ operator"", fontsize=16);. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1511,Integrability,depend,dependent,1511,"; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an in",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1696,Integrability,depend,dependent,1696," on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1815,Integrability,depend,dependent,1815," on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:2746,Integrability,depend,dependent,2746,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [6]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [7]: es2; Out[7]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum obj",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:4686,Integrability,depend,dependent,4686," =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [8]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[8]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [9]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [10]: esval(es2, times) # equivalent to es2.value(times); Out[10]: ; array([ Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [11]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ....: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ....: . In [12]: rho = fock_dm(2, 1). In [13]: es3_expect = expect(rho, es3). In [14]: es3_expect; Out[14]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the ",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1921,Modifiability,parameteriz,parameterized,1921,"TiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6214,Modifiability,evolve,evolve,6214,"]: es3_expect; Out[14]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by pri",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6343,Modifiability,evolve,evolved,6343,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:6429,Performance,perform,performed,6429,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-eseries.html:2836,Usability,simpl,simply,2836,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [6]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [7]: es2; Out[7]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we c",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:2342,Availability,avail,available,2342,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:228,Deployability,install,installation,228,"﻿. Guide Overview — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:2579,Deployability,update,updated,2579,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:2408,Security,access,accessible,2408,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:2469,Security,access,accessible,2469,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:1520,Usability,guid,guide,1520," and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:1609,Usability,guid,guide,1609,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:1820,Usability,guid,guide,1820,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-overview.html:1956,Usability,guid,guide,1956,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:5172,Availability,avail,available,5172,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:241,Deployability,install,installation,241,". Running Problems in Parallel — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in par",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4416,Deployability,configurat,configurations,4416,"1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:5043,Deployability,install,installed,5043,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:5534,Deployability,update,updated,5534,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4711,Energy Efficiency,power,powerful,4711,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2182,Modifiability,variab,variables,2182," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2224,Modifiability,variab,variable,2224," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2531,Modifiability,variab,variable,2531,"putations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. N",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4416,Modifiability,config,configurations,4416,"1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:1969,Performance,perform,performing,1969,"tes & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). I",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:2047,Performance,perform,performed,2047,"ion 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], typ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4230,Performance,perform,performance,4230,"; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 3.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 4.]]]. In [15]: print(c); ['' 'a' 'aa' 'aaa' 'aaaa']. Note; New in QuTiP 3. One can also define functions with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only avail",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
https://qutip.org/docs/3.0.0/guide/guide-random.html:257,Deployability,install,installation,257,". Generating Random Quantum States & Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a si",MatchSource.WIKI,docs/3.0.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-random.html
https://qutip.org/docs/3.0.0/guide/guide-random.html:4940,Deployability,update,updated,4940,"00000000+0.j -0.30001540+0.14135167j; -0.48167388-0.23237517j 0.00000000+0.j ]]. In this previous example, we see that the generated Hermitian operator contains a fraction of elements that are identically equal to zero. The number of nonzero elements is called the density and can be controlled by calling any of the random state/operator generators with a second argument between 0 and 1. By default, the density for the operators is 0.75 where as ket vectors are completely dense (1). For example:; In [4]: rand_dm(5, 0.5); Out[4]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+0.j ]; [ 0.00000000+0.j 0.32141161+0.j 0.00000000+0.j; 0.19802585-0.11734087j 0.00000000+0.j ]; [ 0.00000000+0.j 0.00000000+0.j 0.01374332+0.j; 0.00000000+0.j 0.01897778+0.04365046j]; [ 0.00000000+0.j 0.19802585+0.11734087j 0.00000000+0.j; 0.17858839+0.j 0.00000000+0.j ]; [ 0.00000000+0.j 0.00000000+0.j 0.01897778-0.04365046j; 0.00000000+0.j 0.48625668+0.j ]]. has rougly half nonzero elements, or equivalently a density of 0.5. Important; In the case of a density matrix, setting the density too low will result in not enough diagonal elements to satisfy \(Tr(\rho)=1\). Composite random objects¶; In many cases, one is interested in generating random quantum objects that correspond to composite systems generated using the qutip.tensor.tensor function. Specifying the tensor structure of a quantum object is done using the dims keyword argument in the same fashion as one would do for a qutip.Qobj object:; In [5]: rand_dm(4, 0.5, dims=[[2,2], [2,2]]); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0.39065157 0. 0. 0. ]; [ 0. 0.39065157 0. 0. ]; [ 0. 0. 0.10934843 0. ]; [ 0. 0. 0. 0.10934843]]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-random.html
https://qutip.org/docs/3.0.0/guide/guide-random.html:1712,Testability,test,testing,1712,"ion and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [2]: rand_ket(5); Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.62994785+0.1389789j ]; [-0.43288801+0.01284981j]; [-0.22400352-0.20321684j]; [-0.47922421-0.22806793j]; [-0.11912553-0.09464168j]]. or; In [3]: rand_herm(5); Out[3]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.58420310+0.j -0.43073690+0.2344248j 0.00000000+0.j; -0.27393962+0.12764388j -0.48896580+0.09691766j]; [-0.43",MatchSource.WIKI,docs/3.0.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-random.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:247,Deployability,install,installation,247,". Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated v",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:9583,Deployability,update,updated,9583,"is case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [27]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [28]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.6345969256,2.2937984593,-0.0834019751; 1.0101010101,3.6929064190,0.9743342177,-1.6588904559; 2.0202020202,3.0435621859,-0.7571772825,-1.4733799069; 3.0303030303,2.5588500376,-1.4298597237,-0.1269254187. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [29]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [30]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.6345969256e+00,2.2937984593e+00,-8.3401975147e-02; 1.0101010101e+00,3.6929064190e+00,9.7433421768e-01,-1.6588904559e+00; 2.0202020202e+00,3.0435621859e+00,-7.5717728249e-01,-1.4733799069e+00; 3.0303030303e+00,2.5588500376e+00,-1.4298597237e+00,-1.2692541867e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [31]: input_data = file_data_read('expect.dat'). In [32]: shape(input_data); Out[32]: (100, 4). In [33]: from pylab import *. In [34]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[34]: [<matplotlib.lines.Line2D at 0x2ac6d0b3cfd0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:1485,Performance,load,loading,1485,"ide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:1520,Performance,load,loading,1520,"ide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:2107,Performance,perform,performed,2107,"Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:2281,Performance,load,loading,2281," 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:2318,Performance,load,load,2318," 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calcula",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:2741,Performance,load,loads,2741,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example stor",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:3274,Performance,load,loaded,3274,"Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:3691,Performance,load,load,3691,"n qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understo",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:4081,Performance,load,loaded,4081," In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store take",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:4554,Performance,load,loading,4554,"345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [10]: psi0 = rand_ket(10). In [11]: times = np.linspace(0, 10, 10). In [12]: dm_list = mesolve(H, psi0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:4938,Performance,load,load,4938,"i0, times, c_ops, []). In [13]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [14]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [15]: a = destroy(10). In [16]: expect(a.dag() * a, dm_list_loaded.states); Out[16]: ; array([ 3.87543797, 3.11893669, 2.5717301 , 2.17012827, 1.87240607,; 1.65062668, 1.48498272, 1.36107052, 1.26828395, 1.19875921]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [17]: a =",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:8993,Performance,load,loaded,8993,"is case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [27]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [28]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.6345969256,2.2937984593,-0.0834019751; 1.0101010101,3.6929064190,0.9743342177,-1.6588904559; 2.0202020202,3.0435621859,-0.7571772825,-1.4733799069; 3.0303030303,2.5588500376,-1.4298597237,-0.1269254187. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [29]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [30]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.6345969256e+00,2.2937984593e+00,-8.3401975147e-02; 1.0101010101e+00,3.6929064190e+00,9.7433421768e-01,-1.6588904559e+00; 2.0202020202e+00,3.0435621859e+00,-7.5717728249e-01,-1.4733799069e+00; 3.0303030303e+00,2.5588500376e+00,-1.4298597237e+00,-1.2692541867e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [31]: input_data = file_data_read('expect.dat'). In [32]: shape(input_data); Out[32]: (100, 4). In [33]: from pylab import *. In [34]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[34]: [<matplotlib.lines.Line2D at 0x2ac6d0b3cfd0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-saving.html:2843,Usability,simpl,simple,2843,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, ",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:2462,Availability,toler,tolerance,2462,".0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:3517,Availability,toler,tolerance,3517,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:246,Deployability,install,installation,246,". Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:3680,Deployability,update,updated,3680,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:3107,Performance,load,loaded,3107,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:3454,Safety,detect,detect,3454,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:2524,Usability,simpl,simple,2524," Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-settings.html:3280,Usability,simpl,simple,3280,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:14282,Availability,down,down,14282,"[[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; Out[53]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [54]: spin2 = basis(2, 1). In [55]: spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [56]: sigmaz() * spin2; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathr",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:14987,Availability,down,down,14987,"ow apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathrm{up}\right>\) state is label as \(\left|0\right>\), and the \(\left|\mathrm{down}\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806599",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:15259,Availability,down,down,15259,"\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathrm{up}\right>\) state is label as \(\left|0\right>\), and the \(\left|\mathrm{down}\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806599. In [66]: cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). In [67]: expect(c, cat); Out[67]: -0.9999999999999998j. The qutip.expect function also accepts lists or arra",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:17177,Availability,down,down,17177,"arrays of state vectors or density matrices for the second input:; In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:17268,Availability,down,down,17268,"= [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:247,Deployability,install,installation,247,"﻿. Manipulating States and Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations o",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:22836,Deployability,update,updated,22836,"[c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [105]: J = to_choi(S). In [106]: J; Out[106]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True, superrep = choi; Qobj data =; [[ 1.00000000e+00+0.j 0.00000000e+00+0.j 0.00000000e+00+0.j; 8.07531120e-04-0.00234352j]; [ 0.00000000e+00+0.j 0.00000000e+00+0.j 0.00000000e+00+0.j; 0.00000000e+00+0.j ]; [ 0.00000000e+00+0.j 0.00000000e+00+0.j 9.99993856e-01+0.j; 0.00000000e+00+0.j ]; [ 8.07531120e-04+0.00234352j 0.00000000e+00+0.j 0.00000000e+00+0.j; 6.14421235e-06+0.j ]]. In [107]: K = to_kraus(J). In [108]: K; Out[108]: ; [Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = False; Qobj data =; [[ 1.00000000e+00 +5.37487094e-22j 0.00000000e+00 +0.00000000e+00j]; [ 0.00000000e+00 +0.00000000e+00j 8.07531120e-04 +2.34352424e-03j]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = False; Qobj data =; [[ 2.81046030e-14 +7.72131339e-14j 0.00000000e+00 +0.00000000e+00j]; [ 0.00000000e+00 +0.00000000e+00j 2.57568424e-11 -2.08677402e-11j]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 0. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = False; Qobj data =; [[ 0. 0.99999693]; [ 0. 0. ]]]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:12028,Energy Efficiency,energy,energy,12028,"delity(x, x); Out[39]: 1.000000024796918. In [40]: tracedist(y, y); Out[40]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [41]: tracedist(y, x); Out[41]: 0.9771565834831235. In [42]: sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.97715657031452496. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.7782890495537043. In [44]: tracedist(x, z); Out[44]: 0.8559028328862588. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:4399,Integrability,depend,dependence,4399,"]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [8]: c = create(5). In [9]: c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [10]: c * c * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [11]: c ** 2 * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [12]: c * a * vac; Out[12]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [13]: c * a * (c * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [14]: c * a * (c**2 * vac); Out[14]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [15]: c * a * (c**2 ",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:20517,Modifiability,extend,extended,20517,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [105]: J = to_choi(S). In [106]: J; Out[106]: ; Quantum object",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:1912,Performance,perform,performing,1912,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:20355,Security,expose,exposed,20355,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by ",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:1734,Usability,guid,guide,1734,"Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:1889,Usability,guid,guide,1889,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-states.html:8269,Usability,simpl,simplest,8269,"Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0.00000000+0.60628133j]; [-0.43038740+0.j ]; [ 0.00000000-0.24104351j]; [ 0.14552147+0.j ]]. In [28]: d * s * vac; Out[28]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is not longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; In [29]: ket = basis(5, 2). In [30]: ket * ket.dag(); Out[30]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; In [31]: fock_dm(5, 2); Out[31]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. In [32]: ket2dm(ket); Out[32]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 1. 0. 0.]; [ 0. 0. 0. 0. 0.]; [ 0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number state",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5650,Availability,down,downside,5650,"Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These featu",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:6968,Availability,error,error,6968,") that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:7564,Availability,avail,available,7564," invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iter",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:247,Deployability,install,installation,247,". Solving for Steady-State Solutions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathcal{L}\rho_{ss}=0.\]; Although the requirement for time-indepen",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:8420,Deployability,install,installing,8420,"llian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields ",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:11881,Deployability,update,updated,11881,"a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); axhline(y=fexpt, color='r', lw=1.5); ylim([0, 10]); xlabel('Time', fontsize=14); ylabel('Number of excitations', fontsize=14); legend(('Monte-Carlo', 'Master Equation', 'Steady State')); title('Decay of Fock state $\left|10\\rangle\\right.$' +; ' in a thermal environment with $\langle n\\rangle=2$'); show(). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:3132,Energy Efficiency,power,power,3132,"olving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.s",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:3206,Energy Efficiency,power,power,3206,"olving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.s",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:4885,Energy Efficiency,reduce,reduced,4885,"ate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5109,Energy Efficiency,power,power,5109,"or the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster co",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5146,Energy Efficiency,power,power,5146,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5193,Energy Efficiency,power,power,5193,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5333,Energy Efficiency,power,power,5333,"system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, t",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:7686,Energy Efficiency,power,power,7686,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching alg",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:5269,Integrability,rout,routine,5269,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:10683,Modifiability,coupling,coupling,10683,"he incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); axhline(y=fexpt, color='r', lw=1.5); ylim([0, 10]); xlabel('Time', fontsize=14); ylabel('Number of excitations', fontsize=14); legend(('Monte-Carlo', 'Master Equation', 'Steady State')); title('Deca",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:9070,Performance,perform,perform,9070,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:10354,Performance,perform,perform,10354,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, ",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:2384,Usability,simpl,simple,2384,"ving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathcal{L}\rho_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES me",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-steady.html:9877,Usability,simpl,simple,9877,"less explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kapp",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:3750,Availability,down,down,3750,"rmed by taking the tensor product of the two single-qubit ground state vectors:; In [2]: tensor(basis(2, 0), basis(2, 0)); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: t",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:253,Deployability,install,installation,253,". Using Tensor Products and Partial Traces — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace. « Manipulating Sta... Time Evolution a... ». Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:8927,Deployability,update,updated,8927,"he Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [11]: psi = tensor(basis(2, 0), basis(2, 1)). In [12]: psi.ptrace(0); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. In [13]: psi.ptrace(1); Out[13]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.]; [ 0. 1.]]. Note that the partial trace always results in a density matrix (mixed state), regardless of whether the composite system is a pure state (described by a state vector) or a mixed state (described by a density matrix):; In [14]: psi = tensor((basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:5237,Energy Efficiency,energy,energy,5237,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; ",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:5391,Energy Efficiency,energy,energy,5391,"ly on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:6861,Energy Efficiency,energy,energy,6861,"y(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it t",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:7431,Energy Efficiency,reduce,reduces,7431,"5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [11]: psi = tensor(basis(2, 0), basis(2, 1)). In [12]: psi.ptrace(0); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. In [13]: psi.ptrace(1); Out[13]: ; Quantum ",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:3848,Modifiability,extend,extended,3848,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:6757,Modifiability,coupling,coupling,6757,"Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quan",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:5112,Usability,simpl,simple,5112,"its:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tens",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-tensor.html:6613,Usability,simpl,simplest,6613,"Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quan",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:12060,Availability,error,errors,12060,"ds[k]]; ....: for k in range(len(lbls_list))])); ....: . In [72]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [73]: ax.view_init(azim=-55, elev=45). In [74]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [75]: rho_ss = steadystate(H, [sqrt(0.1) * a, sqrt(0.4) * b.dag()]). In [76]: fig, ax = hinton(rho_ss) #, xlabels=xlabels, ylabels=xlabels). In [77]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:258,Deployability,install,installation,258,". Visualization of quantum states and processes — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected opera",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:16497,Deployability,update,updated,16497,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:16320,Integrability,depend,dependent,16320,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:2317,Performance,perform,perform,2317,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide-visualization.html:13401,Security,access,access,13401,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
https://qutip.org/docs/3.0.0/guide/guide.html:224,Deployability,install,installation,224,". Users Guide — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/guide.html:3436,Deployability,update,updated,3436," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/guide.html:2113,Integrability,depend,dependent,2113,"rsion 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/guide.html:2464,Integrability,depend,dependent,2464,"w ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 20",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/guide.html:3123,Performance,load,loading,3123," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/guide.html:3158,Performance,load,loading,3158," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:3151,Availability,down,downside,3151,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:3521,Availability,robust,robust,3521,"ten desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hba",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:243,Deployability,install,installation,243,". Bloch-Redfield master equation — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example d",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5729,Deployability,integrat,integration,5729,"rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\t",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:13657,Deployability,update,updated,13657," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:2385,Energy Efficiency,energy,energy,2385,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:2685,Energy Efficiency,power,power,2685,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:8441,Energy Efficiency,power,power,8441,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:8722,Energy Efficiency,energy,energy,8722," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:9619,Energy Efficiency,power,power,9619,"tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes three mandatory arguments: The system Hamiltonian \(H\), a lis",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5139,Integrability,depend,depends,5139,") are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5679,Integrability,depend,dependence,5679,"\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write ma",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5729,Integrability,integrat,integration,5729,"rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\t",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:2997,Modifiability,coupling,coupling,2997,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5715,Modifiability,extend,extending,5715,"rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\t",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:13187,Modifiability,evolve,evolve,13187," qutip.bloch_redfield.bloch_redfield_tensor also returns a list of eigenkets ekets, since they are calculated in the process of calculating the Bloch-Redfield tensor R, and the ekets are usually needed again later when transforming operators between the computational basis and the eigenbasis.; The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation (5), can be calculated using the QuTiP function qutip.bloch_redfield.bloch_redfield_solve. It takes five mandatory arguments: the Bloch-Redfield tensor R, the list of eigenkets ekets, the initial state psi0 (as a ket or density matrix), a list of times tlist for which to evaluate the expectation values, and a list of operators e_ops for which to evaluate the expectation values at each time step defined by tlist. For example, to evaluate the expectation values of the \(\sigma_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; >>> tlist = linspace(0, 15.0, 1000); >>> psi0 = rand_ket(2); >>> e_ops = [sigmax(), sigmay(), sigmaz()]; >>> expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops); >>>; >>> sphere = Bloch(); >>> sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]); >>> sphere.vector_color = ['r']; >>> # Hamiltonian axis; >>> sphere.add_vectors(array([delta, 0, eps0]) / sqrt(delta ** 2 + eps0 ** 2)); >>> sphere.make_sphere(); >>> show(). The two steps of calculating the Bloch-Redfield tensor and evolve the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, expect for the additional list of spectral callback functions.; >>> output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). where the resulting output is an instance of the class qutip.Odedata. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:2175,Usability,clear,clear,2175,".3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:9724,Usability,simpl,simplify,9724,"; =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes three mandatory arguments: The system Hamiltonian \(H\), a list of operators through which to the bath \(A_\alpha\), and a list of corresponding spectral density functions \(S_\alpha(\omega)\). The spectral density functions are callback functions that takes the (angular) frequency as a single argument.; To illustr",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:240,Deployability,install,installation,240,". Dynamics Simulation Results — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Result class has been renamed to Result, but fo",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:6934,Deployability,update,updated,6934,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:6659,Performance,load,loaded,6659,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:3520,Security,access,access,3520,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:4566,Security,access,access,4566,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation d",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:5144,Security,access,accessed,5144,"the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:1749,Usability,simpl,simplified,1749,"ch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Result class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating wh",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:3583,Usability,guid,guide,3583,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:3759,Usability,simpl,simply,3759,"ata:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-styl",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:5572,Usability,simpl,simplicity,5572,"ulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_r",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:231,Deployability,install,installation,231,"﻿. Floquet Formalism — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independen",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:1859,Deployability,integrat,integration,1859,"iP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:18830,Deployability,update,updated,18830,"port *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, but using:; output = fmmesolve(H, psi0, times, [sigmax()], [num(2)], [noise_spectrum], T, args); p_ex = output.expect[0]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2090,Energy Efficiency,efficient,efficiently,2090,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:12706,Energy Efficiency,efficient,efficiently,12706,"floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_mo",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:12859,Energy Efficiency,efficient,efficiently,12859,"ulate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:17216,Energy Efficiency,power,power,17216,". Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:1745,Integrability,depend,dependent,1745,"tting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:1859,Integrability,integrat,integration,1859,"iP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:1925,Integrability,depend,dependent,1925,"iP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2457,Integrability,depend,dependent,2457,"liography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solut",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2619,Integrability,depend,dependent,2619," period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordin",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2725,Integrability,depend,dependent,2725,"lism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3031,Integrability,depend,dependent,3031,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but onl",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3259,Integrability,depend,dependent,3259," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavef",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3462,Integrability,depend,dependence,3462,"ystem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hb",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:5319,Integrability,depend,dependent,5319,"(t\). (3)\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:6898,Integrability,depend,dependent,6898,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows; >>> delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 2.5 * 2*pi; omega = 1.0 * 2*pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*pi / omega; >>> f_modes, f_energies = floquet_modes(H, T, args); >>> f_energies; array([ 2.83131211, -2.83131211]); >>> f_modes0; [Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.3",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:11400,Integrability,depend,dependent,11400,"69399113j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); >>> psi_t; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[-0.29352582+0.84431304j]; [ 0.30515868+0.32841589j]]. The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; from qutip import *; from scipy import *. delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.5 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:13306,Integrability,depend,dependent,13306,"e period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Note th",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:15060,Integrability,depend,dependent,15060,"gs).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using:; output = fsesolve(H, psi0, times, [num(2)], args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:15669,Integrability,depend,dependent,15669,"results as in the examples above using:; output = fsesolve(H, psi0, times, [num(2)], args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solve",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:17348,Integrability,depend,dependent,17348,"e spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lind",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:16025,Modifiability,coupling,coupling,16025,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:16308,Modifiability,coupling,coupling,16308,"he Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi).",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:16756,Modifiability,extend,extends,16756," list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=comple",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:244,Deployability,install,installation,244,". Lindblad Master Equation Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. « Dynamics Simulat... Monte Carlo Solv... ». Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\)",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:15997,Deployability,update,updated,15997," in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> from pylab import *; >>> plot(times, result.expect[0]); >>> plot(times, result.expect[1]); >>> xlabel('Time'); >>> ylabel('Expectation values'); >>> legend((""Sigma-Z"", ""Sigma-Y"")); >>> show(). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process. Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code:; >>> times = linspace(0.0, 10.0, 200); >>> psi0 = tensor(fock(2,0), fock(10, 5)); >>> a = tensor(qeye(2), destroy(10)); >>> sm = tensor(destroy(2), qeye(10)); >>> H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; >>> 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); >>> result = mesolve(H, psi0, times, ntraj, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); >>> from pylab import *; >>> plot(times, result.expect[0]); >>> plot(times, result.expect[1]); >>> xlabel('Time'); >>> ylabel('Expectation values'); >>> legend((""cavity photon number"", ""atom excitation probability"")); >>> show(). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3124,Energy Efficiency,efficient,efficient,3124,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:8008,Energy Efficiency,energy,energy,8008,"ors is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times:; >>> times = [0.0, 1.0]; >>> result = mesolve(H, psi0, times, [], []); >>> result.states; [; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.+0.j]; [ 0.+0.j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.80901765+0.j ]; [ 0.00000000-0.58778584j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.3090168+0.j ]; [ 0.0000000-0.95105751j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[-0.30901806+0.j ]; [ 0.00000000-0.95105684j]]; ]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:9779,Energy Efficiency,reduce,reduced,9779,"racting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:11813,Energy Efficiency,energy,energy,11813," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:12395,Energy Efficiency,energy,energy,12395,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems)",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:12608,Energy Efficiency,energy,energy,12608,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation a",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:14392,Energy Efficiency,energy,energy,14392," using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> from pylab import *; >>> plot(times, result.expect[0]); >>> plot(times, result.expect[1]); >>> xlabel('Time'); >>> ylabel('Expectation values'); >>> legend((""Sigma-Z"", ""Sigma-Y"")); >>> show(). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process. Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code:; >>> times = lin",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3629,Modifiability,evolve,evolves,3629,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code:; >>> H = 2 * pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = linspace(0.0, 10.0, 20.0); >>> result = mesolve(H, psi0, times, [], [sigmaz()]); >>> result; Result object with mesolve data.; ---------------------------------; expect = True; num_expect = 1, num_collapse = 0; >>> result.expect[0]; array([ 1.00000000+0.j, 0.78914229+0.j, 0.24548596+0.j, -0.40169696+0.j,; -0.87947669+0.j, -0.98636356+0.j",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:2554,Performance,perform,perform,2554,"ndblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:9489,Performance,perform,perform,9489," system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:.",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:10452,Performance,perform,perform,10452,"mics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3138,Security,access,accessible,3138,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:8266,Availability,error,errors,8266," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10116,Availability,avail,available,10116,"ers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0] # <- expectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10487,Availability,down,down,10487,"e, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0] # <- expectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = ten",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:231,Deployability,install,installation,231,". Monte Carlo Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of qu",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:1950,Deployability,continuous,continuously,1950,"(July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10838,Deployability,configurat,configuration,10838,"ectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12762,Deployability,install,installed,12762,"* a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sph",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13689,Deployability,update,updated,13689,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:1963,Energy Efficiency,monitor,monitored,1963,"(July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:7266,Energy Efficiency,efficient,efficient,7266,"how(). The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12524,Integrability,depend,dependent,12524,"(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12579,Integrability,depend,dependent,12579,"+ 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a lis",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10838,Modifiability,config,configuration,10838,"ectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13135,Modifiability,enhance,enhanced,13135,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:5384,Performance,perform,performed,5384,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); # run Monte Carlo solver; data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); plot(times, data.expect[0], times, data.expect[1]); title('Monte Carlo time evolution'); xlabel('Time'); ylabel('Expectation values'); legend((""cavity photon number"", ""atom excitation probability"")); show(). The advantage of the Monte Carlo method over the master equ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12811,Performance,perform,performing,12811,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12926,Performance,perform,performance,12926,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13144,Performance,perform,performance,13144,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:8578,Usability,simpl,simply,8578,"r state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10497,Usability,simpl,simpler,10497,"e, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0] # <- expectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = ten",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:13221,Usability,simpl,simple,13221,"() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
